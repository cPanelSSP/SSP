#!/usr/bin/perl

package SSP;

# SSP - System Status Probe
# Find and print useful troubleshooting info on cPanel servers

=head1 COPYRIGHT

This software is Copyright 2015 by cPanel, Inc.

THE SOFTWARE LICENSED HEREUNDER IS PROVIDED "AS IS" AND CPANEL HEREBY DISCLAIMS ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, RELATING TO THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, OR THE ACCURACY, TIMELINESS, COMPLETENESS, OR ADEQUACY OF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, INCLUDING THE IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  CPANEL DOES NOT WARRANT THAT THE SOFTWARE OR ITS THIRD PARTY COMPONENTS ARE ERROR-FREE OR WILL OPERATE WITHOUT INTERRUPTION.  IF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, OR ANY DATA ACCESSED THEREFROM IS DEFECTIVE, YOU ASSUME THE SOLE RESPONSIBILITY FOR THE ENTIRE COST OF ALL REPAIR OR INJURY OF ANY KIND, EVEN IF CPANEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DEFECTS OR DAMAGES.  NO ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY CPANEL, ITS AFFILIATES, LICENSEES, DEALERS, SUB-LICENSORS, AGENTS OR EMPLOYEES SHALL CREATE A WARRANTY OR IN ANY WAY. 

=cut

use strict;
use warnings;
use Fcntl qw(:mode);
use File::Find;
use Socket;
use IO::Socket::INET;
use Sys::Hostname;
use Term::ANSIColor qw(:constants);
use Storable;
use POSIX;
use Time::Local;
use IPC::Open3;
use Cwd qw(abs_path);
use Getopt::Long;

# Application version (IMPORTANT! Increment this before submitting a pull request)
our $VERSION = '4.99.147';

# Global variables that alter application runtime
our $OPT_BUGREPORT;    # Flag that allows caller to file a bug report
our $OPT_CSI;          # Flag that ensures only customer-service checks are performed
our $OPT_TIMEOUT;      # How long to wait for system commands to finish executing

# Global variables updated throughout application
our $CRIT_BUFFER;      # Critical output to be printed at the end

# Global variables initialized at application initialization
our $LIBKEYUTILS_FILES_REF;
our @PHPINI;
our $EA4;              # Boolean to determine if system is running EasyApache 4
our $EA4_PHP;          # EA4 PHP info
our $HTTPD_PATH;
our $CPANEL_VERSION;    # Current cpanel version of system
our $HOSTNAME;
our $OS;
our $IS_CPANEL     = 0;
our $IS_CLOUDLINUX = 0;
our $IS_KERNELCARE = 0;
our ( $OS_RELEASE, $OS_TYPE, $OS_VERSION, $OS_ISES );
our $EXTERNAL_IP_ADDRESS;
our $EXTERNAL_LICENSE_ADDRESS;
our $TIERS;
our @LOCAL_IPADDRS_LIST;
our @PROCESS_LIST;
our $PROCESS_REF;       # List of processes running on system along with details
our $PORT_REF;          # List of ports being listened on along with user/pid/etc
our $IPCS_REF;
our $HOSTINFO;
our $CPUINFO;
our $MEMINFO;
our $SYSCTL;
our $MYSQL_CONF;
our $MYSQL_DATADIR;
our $MYSQL_ERROR_LOG;
our @MYSQL_RPM_VERSIONS;        # certain installed rpms that begin with MySQL- (e.g., MySQL-server, etc)
our @CUSTOM_OPT_MODS;           # items in /var/cpanel/easy/apache/custom_opt_mods/
our @USR_LOCAL_CPANEL_HOOKS;    # items in /usr/local/cpanel/hooks/
our @EASYAPACHE_TEMPLATES;      # items in /var/cpanel/easy/apache/profile/
our @EXTENDED_RPM_LIST;         # rpm -qa --queryformat '%{ARCH}\t%{NAME}\t%{VERSION}\t%{RELEASE}\n'
our @RPM_LIST;                  # rpm -qa
our %CPCONF;                    # cpanel.config
our $PUREFTPDCONF;              # /etc/pure-ftpd.conf
our $PROFTPDCONF;               # /etc/proftpd.conf
our $OLD_BACKUP_CONF;           # /etc/cpbackup.conf
our $NEW_BACKUP_CONF;           # /var/cpanel/backups/config
our @APACHE_VERSION_OUTPUT;     # httpd -v
our @APACHE_MODULES_OUTPUT;     # httpd -M
our $APACHE_VERSION;            # Version string
our $APACHE_BUILT;              # Build date
our $APACHE_EA_VERSION;         # EA version which built Apache
our $APACHE_PER_USER;           # Type of per-user Apache module in effect such as Mod Ruid2 or MPM ITK
our $APACHE_MODSEC;             # mod_security enabled
our ( $LSWS_FULL_VERSION, $LSWS_NUMERIC_VERSION );
our ( $EA3_PHPVERSION, $EA3_PHP5VERSION, $EA3_PHP4VERSION, $EA3_PHP4HANDLER, $EA3_PHP5HANDLER, $EA3_SUEXEC );
our @LSOF_80;
our $OPENSSL_RPM_CHANGELOG;
our $EA4_PHP_FPM;               # Boolean flag indicating if easyapache4's php fpm is running

# Initialize application by setting loading all global variables
# (except the RPM variables).  That's done within run()
sub init {
    if ( $^O ne 'linux' ) {
        die "Unknown OS: $^O (only Linux is supported)";
    }

    if ( $< != 0 ) {
        die "SSP must be run as root\n";
    }
    $ENV{'PATH'}                = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin';
    $|                          = 1;
    $Term::ANSIColor::AUTORESET = 1;
    @LOCAL_IPADDRS_LIST         = get_local_ipaddrs();
    @PROCESS_LIST               = get_process_list();
    $PROCESS_REF                = get_process_pid_hash();
    $PORT_REF                   = get_lsof_port_hash();
    $IPCS_REF                   = get_ipcs_hash();
    $HOSTINFO                   = get_hostinfo();
    $CPUINFO                    = get_cpuinfo();
    $MEMINFO                    = get_meminfo();
    $SYSCTL                     = get_sysctl();
    $EXTERNAL_IP_ADDRESS        = get_external_ip('80');
    $EXTERNAL_LICENSE_ADDRESS   = get_external_ip('2089');
    $IS_KERNELCARE              = is_kernelcare();
    $LIBKEYUTILS_FILES_REF      = build_libkeyutils_file_list();
    $HOSTNAME                   = hostname();
    $OS                         = get_os();
    ( $OS_RELEASE, $OS_TYPE, $OS_VERSION, $OS_ISES ) = get_os_info();
    if ( $OS_TYPE eq "cloudlinux" ) { $IS_CLOUDLINUX = 1; }
    $MYSQL_CONF      = get_mysql_conf();
    $MYSQL_DATADIR   = get_mysql_datadir();           # needs $MYSQL_CONF
    $MYSQL_ERROR_LOG = get_mysql_error_log();         # needs $MYSQL_CONF
    $IS_CPANEL       = 1 if -d '/usr/local/cpanel';

    if ($IS_CPANEL) {
        $CPANEL_VERSION  = get_cpanel_version();
        $EA4             = is_ea4();
        $EA4_PHP         = _get_installed_ea4_php();
        $HTTPD_PATH      = get_httpd_path();           # location of operative httpd
        @PHPINI          = get_phpini();
        $TIERS           = get_tiers_file();
        $PUREFTPDCONF    = get_pureftpd_conf();
        $PROFTPDCONF     = get_proftpd_conf();
        $EA4_PHP_FPM     = get_ea4_php_fpm_status();
        $APACHE_PER_USER = "none";
        ( $OLD_BACKUP_CONF,   $NEW_BACKUP_CONF )      = get_backup_config();
        ( $LSWS_FULL_VERSION, $LSWS_NUMERIC_VERSION ) = get_lsws_version();

        if ($HTTPD_PATH) {
            @APACHE_VERSION_OUTPUT = split /\n/, timed_run( 0, $HTTPD_PATH, '-v' );
            @APACHE_MODULES_OUTPUT = split /\n/, timed_run( 0, $HTTPD_PATH, '-M' );

            for (@APACHE_VERSION_OUTPUT) {
                if (m{ \A Server \s+ version: \s+ Apache/(.*) \s \(.*\)\z }xms) {
                    $APACHE_VERSION = $1;
                }
                if (m{ \A Server \s+ built: \s+ (.*) \z }xms) {
                    $APACHE_BUILT = $1;
                    $APACHE_BUILT =~ s/^\s+//g;
                }
                if ( !$EA4 ) {
                    if (m{ \A Cpanel::Easy::Apache \s+ (.*) \z }xms) {
                        $APACHE_EA_VERSION = $1;
                    }
                }
            }

            if ($EA4) {
                chomp( $APACHE_EA_VERSION = timed_run( 0, 'rpm', '-qf', $HTTPD_PATH ) );
                $APACHE_EA_VERSION =~ s/\.\w\d{1,3}\D+\d+\n//;
            }

            $APACHE_MODSEC = 0;
            for (@APACHE_MODULES_OUTPUT) {
                if (/ruid2_module/) {    #
                    $APACHE_PER_USER = "ruid2";
                }
                if (/mpm_itk_module/) {
                    $APACHE_PER_USER = "itk";
                }
                if (/security\d?_module/) {
                    $APACHE_MODSEC = 1;
                }
            }
        }

        # TODO: use +c 15 so the entire process name is displayed if >9 chars
        @LSOF_80 = split /\n/, timed_run( 0, 'lsof', '-n', '-i', 'tcp:80' );

        {
            if ( open( my $cpconf_fh, '<', '/var/cpanel/cpanel.config' ) ) {
                local $/ = undef;
                %CPCONF = map { ( split( /=/, $_, 2 ) )[ 0, 1 ] } split( /\n/, readline($cpconf_fh) );
                close $cpconf_fh;
            }
            else {
                die "/var/cpanel/cpanel.config could not be opened. Unable to proceed.\n";
            }
        }
    }
    $SIG{'INT'} = sub {
        print "\n\nJust being impatient, or did SSP actually hang? What if it didn't get a chance to check something really important?\n";
        print "\nIf you really want out of here and it didn't work the first time then you interrupted a child and not the parent process. Keep hitting CTRL+C.\n";
        if ($CRIT_BUFFER) {
            print_magenta("\nThere was critical-level output above, here it is again:");
            print $CRIT_BUFFER;
        }
        die;
    };

    return 1;
}

sub run {
    if ( defined &Getopt::Long::GetOptionsFromArray ) {
        Getopt::Long::GetOptionsFromArray(
            \@ARGV,
            'bugreport' => \$OPT_BUGREPORT,
            'csi'       => \$OPT_CSI,
            'timeout=i' => \$OPT_TIMEOUT,
        );
    }
    elsif ( scalar @ARGV ) {
        print_crit('Perl: ');
        print_critical('there are one or more command-line options passed in but Getopt::Long::GetOptionsFromArray is not found so SSP is unable to parse them.  Try running SSP with a newer version of Perl or Getopt::Long.');
    }

    if ($OPT_TIMEOUT) {
        $OPT_TIMEOUT = int $OPT_TIMEOUT;
        if ( $OPT_TIMEOUT < 5 ) {
            $OPT_TIMEOUT = 5;
        }
    }

    ######################
    ##  END GLOBALS     ##
    ######################

    if ($OPT_BUGREPORT) {
        print_bug_report();
        exit;
    }

    if ($OPT_CSI) {
        csi_checks_only();
        exit;
    }

    if ( -e '/var/cpanel/dnsonly' ) {
        dnsonly_checks_only();
        exit;
    }

    unless ($IS_CPANEL) {
        non_cpanel_checks_only();
        exit;
    }

    print "\n";
    for ( 1 .. 3 ) {
        print BOLD GREEN ON_RED "\tPlease DO NOT paste output from SSP into tickets unless it is relevant to an issue" . RESET . "\n";
    }

    ## [CRIT] -- only stuff that we should check as early as possible
    check_for_hacked_server_touchfile();
    check_for_multiple_tech_logins();
    check_for_lve_environment();
    check_for_os_release_5();
    check_for_os_release_7();
    check_for_os_release_32bit();

    ## [INFO]
    print "\n";
    print_tip();
    print_version();
    print_hostname();
    print_os();
    print_kernel_and_cpu();
    print_kernelcare_info();
    print_cpanel_info();
    check_for_cpanel_update();
    print_uptime();
    check_for_clustering();
    print_apache_info();
    print_lsws_info();
    check_for_lsws_update();
    print_ea3_php_configuration();
    print_ea4_php_configuration();
    print_if_mod_userdir();
    check_sysinfo();
    check_for_remote_mysql();
    print_if_using_mydns_or_nsd();
    print_mysql_version();
    print_backups_info();
    print_mailserver_info();
    print_ftpserver_info();
    check_for_custom_zonetemplates();
    print_news();
    check_for_license_info();

    ## [WARN]
    check_port_hash();
    check_selinux_status();
    check_runlevel();
    check_for_missing_root_cron();
    check_for_missing_usr_bin_crontab();
    check_if_upcp_is_running();
    check_valid_upcp();
    check_interface_lo();
    check_cpanelconfig_filetype();
    check_cpanelsync_exclude();
    check_for_rawopts();
    check_for_rawenv();
    check_for_custom_opt_mods();
    check_for_local_templates();
    check_for_missing_account_suspensions_conf();
    check_for_local_makecpphp_template();
    check_for_custom_apache_includes();
    check_for_tomcatoptions();
    check_for_sneaky_htaccess();
    check_perl_sanity();
    check_for_non_default_permissions();
    check_for_non_default_file_capabilities();
    check_for_non_default_sysctl();
    check_for_stale_lockfiles();
    check_var_cpanel_users_files_ownership();
    check_root_suspended();
    check_limitsconf();
    check_disk_space();
    check_disk_inodes();
    check_for_hooks_in_scripts_directory();
    check_for_huge_logs();
    check_easy_skip_cpanelsync();
    check_pkgacct_override();
    check_for_gdm();
    check_for_redhat_firewall();
    check_easyapache();
    check_for_easyapache_hooks();
    check_for_home_noexec();
    check_for_unsupported_nat();
    check_for_oracle_linux();
    check_for_usr_local_cpanel_hooks();
    check_for_sql_safe_mode();
    check_for_domain_forwarding();
    check_for_empty_apache_templates();
    check_for_empty_postgres_config();
    check_for_empty_easyapache_profiles();
    check_for_missing_timezone_from_phpini();
    check_for_proc_mdstat_recovery();
    check_usr_local_cpanel_path_for_symlinks();
    check_for_system_mem_below_required();
    check_yum_conf();
    check_for_cpanel_files();
    check_bash_history_for_certain_commands();
    check_wwwacctconf_for_incorrect_minuid();
    check_roots_cron_for_certain_commands();
    check_for_missing_or_commented_customlog();
    check_for_cpsources_conf();
    check_for_apache_rlimits();
    check_for_usr_local_lib_libz_so();
    check_for_non_default_modsec_rules();
    check_etc_hosts_sanity();
    check_localhost_resolution();
    check_for_empty_or_missing_files();
    check_for_apache_listen_host_is_localhost();
    check_roundcube_mysql_pass_mismatch();
    check_for_hooks_from_var_cpanel_hooks_yaml();
    check_mysqld_warnings_errors();
    check_mysql_config();
    check_for_extra_mysql_config_files();
    check_perl_version_less_than_588();
    check_for_low_ulimit_for_root();
    check_for_fork_bomb_protection();
    check_for_harmful_php_mode_600_cron();
    check_for_cPanel_lower_than_11_30_7_3();
    check_for_custom_exim_conf_local();
    check_for_maxclients_or_maxrequestworkers_reached();
    check_for_non_default_umask();
    check_for_multiple_imagemagick_installs();
    check_for_custom_locales();
    check_eximstats_size();

    #check_eximstats_corrupt(); # !! Completely remove after shake-down period for new table check
    check_for_broken_mysql_tables();
    check_for_broken_mysql_horde();
    check_for_clock_skew();
    check_for_zlib_h();
    check_if_httpdconf_ipaddrs_exist();
    check_distcache_and_libapr();
    check_for_custom_postgres_repo();
    check_for_rpm_overrides();
    check_var_cpanel_immutable_files();
    check_for_noxsave_in_grub_conf();
    check_for_rpm_dist_ver_unknown();
    check_for_homeloader_php_extension();
    check_for_networkmanager();
    check_for_dhclient();
    check_for_var_cpanel_roundcube_install();
    check_for_missing_etc_localtime();
    check_for_cloudlinux_mysql_gov();
    check_cpanel_config();
    check_cpanel_config_for_bad_root();
    check_pure_ftpd_conf_for_upload_script_and_dead();
    check_for_perl_env_var();
    check_for_disabled_services();
    check_for_cpbackup_exclude_everything();
    check_for_usr_local_include_jpeglib_h();
    check_for_bw_module_and_more_than_1024_vhosts();
    check_for_uppercase_chars_in_hostname();
    check_for_bad_permissions_on_named_ca();
    check_for_use_compiled_dnsadmin();
    check_for_mysql_root_pass_with_single_quote();
    check_for_jailshell_additional_mounts_trailing_slash();
    check_for_allow_query_localhost();
    check_for_nocloudlinux_touchfile();
    check_for_mysql_upgrade_touchfile();
    check_for_stupid_touchfile();
    check_for_phphandler_and_opcode_caching_incompatibility();
    check_for_invalid_HOMEDIR();
    check_for_unsupported_options_in_phpini();    # FB-75397
    check_for_suphp_but_no_fileprotect();
    check_for_assp_hates_appconfig_cron();
    check_for_missing_var_cpanel_dynamicui_ftp();
    check_if_backup_dir_is_nfs();
    check_if_hostname_missing_from_localdomains();
    check_for_eximstats_newline();
    check_for_nfs();
    check_for_processes_killed_by_lfd();
    check_for_processes_killed_by_oom();
    check_for_processes_killed_by_prm();
    check_for_broken_userdatadomains();
    check_ssl_db_perms();
    check_for_nat_plus_mod_evasive();
    check_for_stray_index_php();
    check_for_port_80_not_apache();
    check_for_missing_groups();
    check_for_noquotafs();
    check_for_mod_rpaf();
    check_for_mod_spdy();
    check_for_mod_http2();
    check_for_roundcube_overlay();
    check_for_hostname_park_zoneexists();
    check_for_pgpass_colon_in_password_field();
    check_for_dirs_that_break_ea();
    check_for_extra_uid_0_user();
    check_for_easyparams_attributes();
    check_for_stale_backup_pidfile();
    check_for_allow_update_in_named_conf();
    check_for_mpm_itk_and_suexec();
    check_for_modruid2_warnings();
    check_for_broken_mysqldump();
    check_exim_log_sanity();
    check_updatelog();
    check_for_readonly_filesystems();
    check_for_cl_unsupported_memory_limits();
    check_for_eblockers();
    check_for_php_selector_incompatibilities();
    check_for_missing_cloudlinux_files();
    check_for_modsec2_stage_files();
    check_for_cron_allow();
    check_for_missing_fstab();
    check_for_dev_sandbox();
    check_for_jail_owner();

    # [3RDP]
    check_smtp_processes();
    check_for_varnish();
    check_for_nginx();
    check_for_mailscanner();
    check_for_apf();
    check_for_csf();
    check_for_prm();
    check_for_les();
    check_for_1h();
    check_for_webmin();
    check_for_symantec();
    check_for_newrelic();
    check_for_zamfoo();         # Master reseller software
    check_for_whmreseller();    # Master reseller software
    check_for_whmphp();         # Master reseller software
    check_for_cpremote();
    check_for_els();
    check_for_whmxtra();
    check_for_usr_local_mis();
    check_for_opt_gsi_tools();

    # [CRIT] - Anything that requires a pre-defined response to be sent, escalation, or extreme care.
    check_for_unsupported_php();         # Extreme care!
    check_for_bash_secadv_20140924();    # advisory
    check_for_exim_cve_2016_1531();      # advisory
    all_malware_checks();

    # These are run closer to the end since it has the potential to take the longest due to RPM usage
    build_rpm_list();
    build_openssl_rpm_changelog();

    # These require build_rpm_list() to have been run, so that @rpm_list is populated
    #check_for_ebury_3_digit_rpms();                                 # malware
    check_for_openssl_heartbleed_bug();     # advisory
    check_for_openssl_secadv_20140605();    # advisory
    populate_mysql_rpm_versions_array();
    check_for_mysql_4();
    check_for_additional_rpms();
    check_mysql_rpm_mismatch();
    check_php_libmysqlclient_mismatch();
    check_for_percona_rpms();
    check_for_duplicate_rpms();
    check_for_better_linux();
    check_for_kernel_headers_rpm();
    check_for_frontpage_rpms();
    check_for_prelink();
    check_for_broken_rpm();
    check_for_ea4_mismatch();

    print_info2('Done.');

    if ($CRIT_BUFFER) {
        print_magenta("\n\nThere was critical-level output above, here it is again:");
        print $CRIT_BUFFER;
    }

    return 0;
}

# All checks for non-cPanel systems go here
sub non_cpanel_checks_only {
    print "\n";
    for ( 1 .. 3 ) {
        print BOLD GREEN ON_RED "\tPlease DO NOT paste output from SSP into tickets unless it is relevant to an issue" . RESET . "\n";
    }
    print_critical("\nCPANEL IS NOT INSTALLED ON THIS SERVER! SOME SSP OUTPUT MAY NOT BE RELEVANT!\n");

    print_version();

    ## [CRIT] -- only stuff that we should check as early as possible
    check_for_hacked_server_touchfile();
    check_for_multiple_tech_logins();
    check_for_lve_environment();
    check_for_os_release_5();
    check_for_os_release_32bit();

    ## [INFO]
    print "\n";
    print_hostname();
    print_os();
    print_kernel_and_cpu();
    print_kernelcare_info();
    print_uptime();
    check_for_remote_mysql();
    print_mysql_version();
    check_for_license_info();

    ## [WARN]
    check_selinux_status();
    check_runlevel();
    check_interface_lo();
    check_perl_sanity();
    check_for_non_default_permissions();
    check_for_non_default_sysctl();
    check_limitsconf();
    check_disk_space();
    check_disk_inodes();
    check_for_gdm();
    check_for_unsupported_nat();
    check_for_oracle_linux();
    check_for_proc_mdstat_recovery();
    check_for_system_mem_below_required();
    check_yum_conf();
    check_for_cpsources_conf();
    check_etc_hosts_sanity();
    check_localhost_resolution();
    check_mysql_config();
    check_for_extra_mysql_config_files();
    check_perl_version_less_than_588();
    check_for_low_ulimit_for_root();
    check_for_non_default_umask();
    check_for_clock_skew();
    check_for_custom_postgres_repo();
    check_for_noxsave_in_grub_conf();
    check_for_networkmanager();
    check_for_dhclient();
    check_for_missing_etc_localtime();
    check_for_cloudlinux_mysql_gov();
    check_for_perl_env_var();
    check_for_uppercase_chars_in_hostname();
    check_for_mysql_root_pass_with_single_quote();
    check_for_nocloudlinux_touchfile();
    check_for_processes_killed_by_lfd();
    check_for_processes_killed_by_oom();
    check_for_processes_killed_by_prm();
    check_for_extra_uid_0_user();
    check_for_broken_mysqldump();
    check_for_readonly_filesystems();
    check_for_missing_cloudlinux_files();
    check_for_missing_fstab();
    check_for_dev_sandbox();

    # [3RDP]
    check_for_apf();
    check_for_csf();
    check_for_prm();
    check_for_les();
    check_for_els();
    check_for_usr_local_mis();
    check_for_opt_gsi_tools();

    # [CRIT] - Anything that requires a pre-defined response to be sent, escalation, or extreme care.
    check_for_bash_secadv_20140924();    # advisory
    check_for_exim_cve_2016_1531();      # advisory
    all_malware_checks();

    # These are run closer to the end since it has the potential to take the longest due to RPM usage
    build_rpm_list();
    build_openssl_rpm_changelog();

    # These require build_rpm_list() to have been run, so that @rpm_list is populated
    populate_mysql_rpm_versions_array();
    check_for_mysql_4();
    check_for_additional_rpms();
    check_mysql_rpm_mismatch();
    check_for_percona_rpms();
    check_for_duplicate_rpms();
    check_for_better_linux();
    check_for_kernel_headers_rpm();
    check_for_prelink();

    print_info2('Done.');

    if ($CRIT_BUFFER) {
        print_magenta("\n\nThere was critical-level output above, here it is again:");
        print $CRIT_BUFFER;
    }

    return 0;
}

# All checks for DNSONLY go here
sub dnsonly_checks_only {
    print "\n";
    for ( 1 .. 3 ) {
        print BOLD GREEN ON_RED "\tPlease DO NOT paste output from SSP into tickets unless it is relevant to an issue" . RESET . "\n";
    }

    print_version();
    print_start("\t\tDNSONLY: ");
    print_warning("/var/cpanel/dnsonly detected, assuming DNSONLY\n");

    ## [CRIT] -- only stuff that we should check as early as possible
    check_for_hacked_server_touchfile();
    check_for_multiple_tech_logins();
    check_for_lve_environment();
    check_for_os_release_5();
    check_for_os_release_7();
    check_for_os_release_32bit();

    ## [INFO]
    print_hostname();
    print_os();
    print_kernel_and_cpu();
    print_kernelcare_info();
    print_cpanel_info();
    check_for_cpanel_update();
    print_uptime();
    check_for_clustering();
    check_sysinfo();

    ## [WARN]
    check_port_hash();
    check_selinux_status();
    check_runlevel();
    check_for_missing_root_cron();
    check_if_upcp_is_running();
    check_interface_lo();
    check_cpanelconfig_filetype();
    check_cpanelsync_exclude();
    check_perl_sanity();
    check_for_non_default_permissions();
    check_limitsconf();
    check_disk_space();
    check_disk_inodes();
    check_for_gdm();
    check_for_redhat_firewall();
    check_for_home_noexec();
    check_for_unsupported_nat();
    check_for_oracle_linux();
    check_for_proc_mdstat_recovery();
    check_usr_local_cpanel_path_for_symlinks();
    check_for_system_mem_below_required();
    check_yum_conf();
    check_for_cpanel_files();
    check_bash_history_for_certain_commands();
    check_roots_cron_for_certain_commands();
    check_for_perl_env_var();
    check_cpanel_config();
    check_cpanel_config_for_bad_root();

    # check_for_cpsources_conf();       // does this exist on DNSONLY by default?
    check_etc_hosts_sanity();
    check_localhost_resolution();
    check_perl_version_less_than_588();
    check_for_fork_bomb_protection();
    check_for_cPanel_lower_than_11_30_7_3();
    check_for_non_default_umask();
    check_for_clock_skew();
    check_for_percona_rpms();
    check_for_duplicate_rpms();
    check_for_rpm_overrides();
    check_var_cpanel_immutable_files();
    check_for_noxsave_in_grub_conf();
    check_for_networkmanager();
    check_for_disabled_services();
    check_for_harmful_php_mode_600_cron();
    check_updatelog();
    check_for_readonly_filesystems();
    check_for_dev_sandbox();
    check_for_jail_owner();

    ## [3RDP]
    check_for_apf();
    check_for_csf();
    check_for_prm();
    check_for_les();
    check_for_1h();
    check_for_webmin();
    check_for_symantec();

    ## [CRIT]
    check_for_bash_secadv_20140924();    # advisory
    all_malware_checks();

    # These are run closer to the end since it has the potential to take the longest due to RPM usage
    build_rpm_list();
    build_openssl_rpm_changelog();

    # These require build_rpm_list() to have been run, so that @rpm_list is populated
    check_for_openssl_heartbleed_bug();
    check_for_openssl_secadv_20140605();

    print_info2('Done.');

    if ($CRIT_BUFFER) {
        print_magenta("\n\nThere was critical-level output above, here it is again:");
        print $CRIT_BUFFER;
    }
}

sub csi_checks_only {
    check_port_hash();
    check_for_bash_secadv_20140924();    # advisory
    all_malware_checks();

    # These are run closer to the end since it has the potential to take the longest due to RPM usage
    build_openssl_rpm_changelog();

    # These require build_rpm_list() to have been run, so that @rpm_list is populated
    check_for_openssl_heartbleed_bug();
    check_for_openssl_secadv_20140605();
    print_info2('SSP checks done.');
}

sub all_malware_checks {
    check_for_UMBREON_rootkit();          # malware
    check_for_libms_rootkit();            # malware
    check_for_jynx2_rootkit();            # malware
    check_for_cdorked_A();                # malware
    check_for_cdorked_B();                # malware
    check_for_libkeyutils_filenames();    # malware
                                          #check_for_unowned_libkeyutils_files($LIBKEYUTILS_FILES_REF);    # malware
    check_sha1_sigs_libkeyutils();        # malware
    check_sha1_sigs_httpd();              # malware
    check_sha1_sigs_named();              # malware
    check_sha1_sigs_ssh();                # malware
    check_sha1_sigs_ssh_add();            # malware
    check_sha1_sigs_sshd();               # malware
    check_for_ebury_ssh_G();              # malware
    check_for_ebury_ssh_banner();         # malware
    check_for_ebury_ssh_shmem();          # malware
    check_for_ebury_root_file();          # malware
    check_for_ebury_socket();             # malware
    check_for_bg_botnet();                # malware
    check_for_dragnet();                  # malware
    check_for_xor_ddos();                 # malware
    check_for_shellbot();                 # malware
    check_for_ncom_filenames();           # malware
    check_for_cpro();
}

sub get_phpini {
    my $phpini = '/usr/local/lib/php.ini';
    my @phpini;
    return () if !-f $phpini;

    if ( open my $fh, '<', $phpini ) {
        while (<$fh>) {
            next if (/^(?:;|$|\[)/);
            chomp;
            push @phpini, $_;
        }
        close $fh;
    }

    return @phpini;
}

sub get_httpd_path {
    if ( $EA4 && -x '/usr/sbin/httpd' ) {
        return '/usr/sbin/httpd';
    }
    if ( !$EA4 && -x '/usr/local/apache/bin/httpd' ) {
        return '/usr/local/apache/bin/httpd';
    }
    return undef;
}

sub is_ea4 {
    if ( -f '/etc/cpanel/ea4/is_ea4' ) {
        return 1;
    }
    return undef;
}

sub is_kernelcare {
    return 1 if -e '/usr/bin/kcarectl';
    return 0;
}

sub get_cpanel_version {
    my $cpanel_version_file = '/usr/local/cpanel/version';
    my $version;

    local $/ = undef;
    if ( open my $file_fh, '<', $cpanel_version_file ) {
        $version = <$file_fh>;
        close $file_fh;
    }

    if ($version) {
        if ( $version =~ /(\d+\.\d+\.\d+\.\d+)/ ) {
            $version = $1;
        }
        else {
            $version = q{unknown};
        }
    }
    else {
        $version = q{unknown};
    }

    return $version;
}

sub version_cmp {    # should only be used by version_compare()
    no warnings 'uninitialized';    # Prevent uninitialized value warnings when not using all 4 values
    my ( $a1, $b1, $c1, $d1 ) = split /[\._]/, $_[0];
    my ( $a2, $b2, $c2, $d2 ) = split /[\._]/, $_[1];
    return $a1 <=> $a2 || $b1 <=> $b2 || $c1 <=> $c2 || $d1 <=> $d2;
}

sub version_compare {

    # example: return if version_compare($ver_string, qw( >= 1.2.3.3 ));
    # Must be no more than four version numbers separated by periods and/or underscores.
    my ( $ver1, $mode, $ver2 ) = @_;
    return if ( !defined($ver1) || ( $ver1 =~ /[^\._0-9]/ ) );
    return if ( !defined($ver2) || ( $ver2 =~ /[^\._0-9]/ ) );

    # Shamelessly copied the comparison logic out of Cpanel::Version::Compare
    my %modes = (
        '>' => sub {
            return if $_[0] eq $_[1];
            return version_cmp(@_) > 0;
        },
        '<' => sub {
            return if $_[0] eq $_[1];
            return version_cmp(@_) < 0;
        },
        '==' => sub { return $_[0] eq $_[1] || version_cmp(@_) == 0; },
        '!=' => sub { return $_[0] ne $_[1] && version_cmp(@_) != 0; },
        '>=' => sub {
            return 1 if $_[0] eq $_[1];
            return version_cmp(@_) >= 0;
        },
        '<=' => sub {
            return 1 if $_[0] eq $_[1];
            return version_cmp(@_) <= 0;
        }
    );
    return if ( !exists $modes{$mode} );
    return $modes{$mode}->( $ver1, $ver2 );
}

sub cpanel_version_is {
    return if !defined($CPANEL_VERSION);
    return if $CPANEL_VERSION eq "unknown";
    my ( $mode, $ver ) = @_;
    return version_compare( $CPANEL_VERSION, $mode, $ver );
}

sub timed_run {    # Borrowed from Cpanel::SafeRun::Timed and modified
    my ( $timer, @PROGA ) = @_;
    $timer = $timer       ? $timer       : 25;       # A timer value of 0 means use the default, currently 25.
    $timer = $OPT_TIMEOUT ? $OPT_TIMEOUT : $timer;
    return if ( substr( $PROGA[0], 0, 1 ) eq '/' && !-x $PROGA[0] );

    open( my $save_stderr_fh, '>&STDERR' );
    open( STDERR, '>', '/dev/null' );

    my $output   = "";                               # In the event of time-out or failure, return empty string instead of undef.
    my $complete = 0;
    my $pid;
    my $fh;                                          # FB-63723: must declare $fh before eval block in order to avoid unwanted implicit waitpid on die
    eval {
        local $SIG{'__DIE__'} = 'DEFAULT';
        local $SIG{'ALRM'} = sub { $output = ""; print RED ON_BLACK "Timeout while executing: " . join( ' ', @PROGA ) . "\n"; die; };
        alarm($timer);
        if ( $pid = open( $fh, '-|' ) ) {
            local $/;
            $output = readline($fh);
            close($fh);
        }
        elsif ( defined $pid ) {
            open( STDIN, '<', '/dev/null' );
            exec(@PROGA) or exit 1;
        }
        else {
            warn 'Error while executing: [' . join( ' ', @PROGA ) . ']: ' . $!;
            alarm(0);
            open( STDERR, '>&=' . fileno($save_stderr_fh) );
            return "";
        }
        $complete = 1;
        alarm 0;
    };
    alarm 0;
    if ( !$complete && $pid && $pid > 0 ) {
        kill( 15, $pid );    #TERM
        sleep(2);            # Give the process a chance to die 'nicely'
        kill( 9, $pid );     #KILL
    }
    open( STDERR, '>&=' . fileno($save_stderr_fh) );
    return $output;
}

sub timed_run_trap_stderr {    # Borrowed from Cpanel::SafeRun::Timed and modified
    my ( $timer, @PROGA ) = @_;
    $timer = $timer       ? $timer       : 25;       # A timer value of 0 means use the default, currently 25.
    $timer = $OPT_TIMEOUT ? $OPT_TIMEOUT : $timer;
    return if ( substr( $PROGA[0], 0, 1 ) eq '/' && !-x $PROGA[0] );

    open( my $save_stderr_fh, '>&STDERR' );
    open( STDERR, '>', '/dev/null' );

    my $output   = "";                               # In the event of time-out or failure, return empty string instead of undef.
    my $complete = 0;
    my $pid;
    my $fh;                                          # FB-63723: must declare $fh before eval block in order to avoid unwanted implicit waitpid on die
    eval {
        local $SIG{'__DIE__'} = 'DEFAULT';
        local $SIG{'ALRM'} = sub { $output = ""; print RED ON_BLACK "Timeout while executing: " . join( ' ', @PROGA ) . "\n"; die; };
        alarm($timer);
        if ( $pid = open( $fh, '-|' ) ) {
            local $/;
            $output = readline($fh);
            close($fh);
        }
        elsif ( defined $pid ) {
            open( STDIN, '<', '/dev/null' );
            open( STDERR, '>&STDOUT' );
            exec(@PROGA) or exit 1;
        }
        else {
            warn 'Error while executing: [' . join( ' ', @PROGA ) . ']: ' . $!;
            alarm(0);
            open( STDERR, '>&=' . fileno($save_stderr_fh) );
            return "";
        }
        $complete = 1;
        alarm 0;
    };
    alarm 0;
    if ( !$complete && $pid && $pid > 0 ) {
        kill( 15, $pid );    #TERM
        sleep(2);            # Give the process a chance to die 'nicely'
        kill( 9, $pid );     #KILL
    }
    open( STDERR, '>&=' . fileno($save_stderr_fh) );
    return $output;
}

sub get_local_ipaddrs {
    my @local_ipaddrs_list;
    my @output;

    unless ( @output = split /\n/, timed_run( 0, 'ip', 'addr' ) ) {
        @output = split /\n/, timed_run( 0, 'ifconfig', '-a' );
    }
    for my $line (@output) {
        if ( $line =~ m{ (\d+\.\d+\.\d+\.\d+) }xms ) {
            my $ipaddr = $1;
            unless ( $ipaddr =~ m{ \A 127\. }xms ) {
                push @local_ipaddrs_list, $ipaddr;
            }
        }
    }

    return @local_ipaddrs_list;
}

sub get_os {
    chomp( my $os = lc timed_run( 0, 'uname' ) );
    return $os;
}

# ripped from /usr/local/cpanel/Cpanel/Sys/OS.pm
sub get_os_info {
    my $ises = 0;
    my $version;
    my $os      = "UNKNOWN";
    my $release = "UNKNOWN";
    my $os_release_file;

    foreach my $test_release_file ( 'CentOS-release', 'redhat-release', 'system-release' ) {
        if ( -e '/etc/' . $test_release_file ) {
            if ( ( ($os) = $test_release_file =~ m/^([^\-_]+)/ )[0] ) {
                $os              = lc $os;                         #lc ok here as no danger of utf-8 data
                $os_release_file = '/etc/' . $test_release_file;

                if ( $os eq 'system' ) {
                    $os = 'amazon';
                }

                last;
            }
        }
    }

    if ( open my $fh, '<', $os_release_file ) {
        my $line = readline $fh;
        close $fh;
        chomp $line;
        if    ( length $line >= 4 )                                             { $release = $line; }
        if    ( $line =~ m/(?:Corporate|Advanced\sServer|Enterprise|Amazon)/i ) { $ises    = 1; }
        elsif ( $line =~ /CloudLinux|CentOS/i )                                 { $ises    = 2; }

        if    ( $line =~ /(\d+\.\d+)/ ) { $version = $1; }
        elsif ( $line =~ /(\d+)/ )      { $version = $1; }

        if ( $line =~ /(centos|cloudlinux|amazon)/i ) { $os = lc $1; }
    }

    return ( $release, $os, $version, $ises );
}

sub print_version {
    print BOLD YELLOW ON_BLACK "\tSSP $VERSION\n\n";
}

sub print_tip {
    my @tips = (
        '[FB-86549] (Fixed in 11.42.1.1) cPHulk may report root logins to Pure-FTPd despite no evidence being found',
        '[FB-78617] (By design) sysup always installs bind',
        '[FB-75793] (By design) Proxy subdomains are not created for addon domains',
        '[FB-73369] Can\'t log into SquirrelMail, but Horde and Roundcube work? Check if webmail pass contains "odd" characters',
        '[FB-72801] (By design) File Manager creates new files with 0600 perms, even when saving an existing file as a new one',
        '[FB-72733] (By design) File Manager\'s "Compress" feature has a hard coded timeout due to using cPanel\'s form upload logic',
        '[FB-63530] When setting up a remote MySQL server, that server must have the openssh-clients package installed',
        '[FB-63193] File Manager showing "Out of memory" in cPanel error_log? Try renaming $HOME/$USER/.cpanel/datastore/SYSTEMMIME',
        '[FB-62819] "License File Expired: LTD: 1334782495 NOW: 1246416504 FUT!" likely just means the server clock is wrong',
        '[FB-62054] (By design) The "Dedicated IP" box can only be modified when creating a package - not when editing',
        '[FB-61735] (By design) "/u/l/c/whostmgr/bin/whostmgr2 --updatetweaksettings" destroys custom proxy subdomain records. Use WHM >> Tweak Settings instead.',
        '[FB-59450] (By design) Email quotas cannot exceed 2048MB, but they can be unlimited',
        '[FB-58625] Apache 2.0.x links to the wrong PCRE libs. This can cause preg_match*() errors, and "PCRE is not compiled with UTF-8 support"',
        '[FB-57237] (By design) Per ISO 3166-1, the country code for the UK is GB (not UK). Look for this in WHM >> Generate an SSL Certificate [...]',
        '[FB-50745] (By design) The cPanel UI displays differently (more columns than rows) when changing your locale',
        '[FB-46853] Customer complaining that they can\'t log into cPanel as root? Update FB-46853',
        '[FB-44884] upcp resets Mailman lists\' hostnames. pre/postupcp hooks workaround in ticket 3541643',
        '[FB-42027] "Recently Uploaded Cgi Script Mail" scans and sends email alerts about downloaded files too',
        '[FB-21774] Pure-FTPd is not linked against libwrap. As such, Host Access Control does nothing for it',
        'The cpanel-postgresql* packages are for phpPgAdmin. The postgresql-* packages are for PostgreSQL',
        'For a list of obscure issues, see the RareIssues wiki article',
        '11.35+: Use /scripts/check_cpanel_rpms to fix problems in /usr/local/cpanel/3rdparty/  - not checkperlmodules',
        'php.ini for phpMyAdmin, phpPgAdmin, Horde, and RoundCube can be found in /usr/local/cpanel/3rdparty/etc/',
        'If Dovecot/POP/IMAP dies every day around the same time, the server\'s clock could be skewed. Check /var/log/maillog for "moved backwards"',
        '"Allowed memory size of x bytes exhausted" when uploading a db via phpMyAdmin may be resolved by increasing max_allowed_packet',
        'Need to edit php.ini for Horde, RoundCube, phpMyAdmin, or phpPgAdmin? Edit /u/l/c/3rdparty/etc/php.ini, then run /u/l/c/b/install_php_inis',
        'Seeing "domainadmin" errors (e.g. "domainadmin-domainexistsglobal")? Check the Domainadmin-Errors wiki article',
        'Transfers showing "sshcmdpermissiondeny"? Check for modified openssh-clients package (see ticket 3664533)',
        'Learn how cPanel 11.36+ handles rpms: http://go.cpanel.net/rpmversions',
        'Use "rlog <file>" to see a file\'s revision history, and "co -p1.1 <file>" (for example) to see that revision',
        'Files under revision control: fstab, localdomains, named.conf, passwd, shadow, trueuserowners, httpd.conf, php.ini (system and cPanel)',
        'Imagick install issues on PHP 5.4? You may need to run \'pear config-set preferred_state beta\' (see ticket 3754991)',
        'Need to enable ZTS support for PHP? Try \'--enable-maintainer-zts\' (see ticket 3769493)',
        'WHM\'s "Apache mod_userdir Tweak" can be toggled via /scripts/userdirctl',
        'Issues with MySQL for a single user? Check for /home/${USER}/.my.cnf',
        'Services reported as failing while backups are running? chksrvd may be simply timing out due to excessive disk I/O',
        'Blank page in File Manager\'s HTML Editor and iconv "illegal input sequence" in cPanel error_log? Try windows-1251 encoding (see ticket 4088633)',
        'Older CentOS 5.x and CloudLinux 5.x do not support SNI. See the "SNI" wiki article for more info',
        'domlogs are created 0644 by default. cpanellogd changes permissions on them to 0640 a few minutes later',
        'cPanel >> Error Log only searches "recent" logs in Apache\'s error_log . Showing as blank? Maybe there are no recent errors',
        'Horde showing "server configuration did not allow file to be uploaded"? Check disk/inode usage on /tmp',
        'IMAP/webmail showing no email? The cPanel account may have been over its quota. Try renaming dovecot-uidlist, send account an email (see ticket 4314723)',
        'ClamAV not scanning emails? Check if /var/clamd is missing. This will be reflected in Exim\'s logs as well',
        'Use custom_vhost_template_ap(1|2) in userdata files to make changes for an individual vhost',
        'File Manager upload size limits can be adjusted at WHM >> Tweak Settings >> Max HTTP submission size',
        '/var/cpanel/conf/apache/local can potentially cause issues. See ticket 3915299 for an example',
        'System backups are not uploaded via FTP by default, requires manual config. See http://documentation.cpanel.net/display/1144Docs/System+Backups#SystemBackups-Manualconfigurationmethod',
        '$PATH may differ when executing something via cron rather than the command line. See ticket 4419531',
        '"failed to open scan directory /var/spool/exim/scan/[...]: Too many links" could mean a directory has reached limit of 32,000 files/dirs',
        'If innodb_force_recovery is enabled in the MySQL configuration, this can sometimes prevent mysqldump from working (see ticket 5193581).',
        '"Spawned \'ossec-dbd\' with \'/sbin/service restart ossec-hids\'" is from ASL (Atomic Secured Linux). Have customer contact ASL Support if necessary.',
        'You can run SSP with the --bugreport option to print a pre-filled template for submitting a WHM/cPanel bug report.',
        'The path for the modsec_audit.log changes with Mod Ruid2 or MPM ITK installed to /usr/local/apache/conf/modsec_audit/[user]/YYYYMMDD/YYYYMMDD-HHmm/YYYYMMDD-HHmmSS-[unique-id]',
        'LiteSpeed (lsws) does NOT support the Apache web status page - see: http://www.litespeedtech.com/support/forum/threads/solved-cpanel-after-litespeed-installation-whm-server-status-gives-a-404-error.5536/',
        'You can submit new ideas or bug reports for SSP by emailing ssp-requests(at)cpanel.net',
        'You can format json files for more readability: python -m tool.json < file.json | less',
    );

    my $num = int rand scalar $#tips;
    print BOLD WHITE ON_BLACK "\tDid you know? $tips[$num]" . RESET . "\n\n";
}

sub get_tiers_file {
    my $tier;
    local $SIG{'ALRM'} = sub { return (); };
    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => 'httpupdate.cpanel.net',
        PeerPort => '80',
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /cpanelsync/TIERS HTTP/1.1\r\nUser-Agent: SSP/" . $VERSION . "\r\nHost: httpupdate.cpanel.net\r\n\r\n";
        sysread $sock, $tier, 1000;
        close $sock;
    }

    alarm 0;

    return $tier;
}

sub get_process_list {    # Usage of this needs to be deprecated in favor of the %process hash
    return split /\n/, timed_run( 0, 'ps', 'axwwwf', '-o', 'user,pid,cmd' );
}

sub get_process_pid_hash {
    my %hash;

    for ( split /\n/, timed_run( 0, 'ps', 'axwww', '-o', 'user,pid,ppid,comm,cmd' ) ) {

        # nobody    5403  1666 /usr/local/apache/bin/httpd -k start -DSSL
        if (m{ ^ ([^\s]+) \s+ (\d+) \s+ (\d+) \s+ (.*?) \s+ (.*?) \s* $ }xms) {
            $hash{$2}{USER} = $1;
            $hash{$2}{PPID} = $3;
            $hash{$2}{COMM} = $4;
            $hash{$2}{CMD}  = $5;
        }
    }

    return \%hash;
}

sub get_lsof_port_hash {
    my %hash;

    for ( split /\n/, timed_run( 0, 'lsof', '+c15', '-n', '-P', '-i' ) ) {

        # cmd will be max 15 characaters due to lsof limitation
        # Example from CentOS 6:
        # spamd           1781     root    5u  IPv4  10887      0t0  TCP 127.0.0.1:783 (LISTEN)
        # nc      9468 root    3u  IPv6  84415      0t0  TCP [::1]:25 (LISTEN)
        # Example from an older CentOS 5 system (note empty SIZE column):
        # exim       3066  mailnull    3u     IPv6            2566011                 TCP *:smtp (LISTEN)
        my @lsof = split( /\s+/, $_, 10 );
        if ( defined( $lsof[9] ) && $lsof[9] =~ /LISTEN/ ) {
            splice( @lsof, 6, 1 );    # Drop the SIZE/OFF column which can sometimes be blank and throw everything off
        }
        if ( defined( $lsof[8] ) && $lsof[8] =~ /LISTEN/ ) {    # SIZE/OFF column is blank, or has been dropped
            if ( $lsof[7] =~ /^(.*):(\d+)$/ ) {
                my ( $ip, $port ) = ( $1, $2 );
                push @{ $hash{$port} },
                  {
                    'CMD'   => $lsof[0],
                    'PID'   => $lsof[1],
                    'USER'  => $lsof[2],
                    'IPV'   => $lsof[4],
                    'PROTO' => $lsof[6],
                    'IP'    => $ip
                  };
            }
        }
    }

    return \%hash;
}

sub get_ipcs_hash {
    my %hash;

    my $header = 0;

    # For now, all we need is shared memory segment owner and creator-pid, but the data structure is extensible.
    # ipcs -m -p
    #
    #------ Shared Memory Creator/Last-op --------
    #shmid      owner      cpid       lpid
    #2228224    root       992        992
    #2588673    root       1309       1315
    #2195458    root       985        985
    #2621443    root       1309       1315
    for ( split /\n/, timed_run( 0, 'ipcs', '-m', '-p' ) ) {
        if ( $header == 0 ) {
            $header = 1 if m/^ shmid \s+ owner \s+ cpid \s+ lpid \s* $/ix;
            next;
        }
        my @ipcs = split( /\s+/, $_, 5 );
        push @{ $hash{ $ipcs[1] }{mp} }, {    # Key by owner, type 'mp' (-m -p output)
            'shmid' => $ipcs[0],
            'cpid'  => $ipcs[2],
            'lpid'  => $ipcs[3]
        };
    }

    return \%hash;
}

sub get_mysql_conf {
    my %hash;
    my $lines = 0;
    if ( open( my $mycnf_fh, '<', '/etc/my.cnf' ) ) {
        my $section = 'unknown';
        while (<$mycnf_fh>) {
            chomp;
            next if /^(#|$)/;
            if (m{ \A \s* \[([^\]]+)] }x) {
                $section = lc($1);
                $section =~ s/^\s*//g;
                $section =~ s/\s*$//g;
                $lines++;
                next;
            }
            if (m{ \A \s* ([^=]+?) \s* = \s* (?:["']?) ([^"']*?) (?:["']?) \s* \Z }x) {
                my $key = lc($1);
                $key =~ tr/_-//d;
                $hash{$section}{$key} = [ $1, $2 ];
                $lines++;
                next;
            }
            if (m{ \A \s* ([^\s]+) \s* \Z }x) {
                my $key = lc($1);
                $key =~ tr/_-//d;
                $hash{$section}{$key} = [ $1, 'enabled' ];
                $lines++;
            }
        }
        close $mycnf_fh;
    }
    $hash{'LINES'} = $lines;
    return \%hash;
}

sub get_pureftpd_conf {
    my %conf;
    if ( open( my $pureftpdconf_fh, '<', '/etc/pure-ftpd.conf' ) ) {
        while (<$pureftpdconf_fh>) {
            next if /^(#|$)/;
            if (m{ \A \s* ([^\s]+?) \s+ (.*) \Z }x) {
                my $key = lc($1);
                $conf{$key} = { name => $1, value => $2 };
            }
        }
        close $pureftpdconf_fh;
    }
    return \%conf;
}

sub get_proftpd_conf {
    my %conf;
    if ( open( my $proftpdconf_fh, '<', '/etc/proftpd.conf' ) ) {
        while (<$proftpdconf_fh>) {
            next if /^(#|$)/;
            if (m{ \A \s* ([^\s]+?) \s+ (.*) \Z }x) {
                my $key = lc($1);
                $conf{$key} = { name => $1, value => $2 };
            }
        }
        close $proftpdconf_fh;
    }
    return \%conf;
}

sub get_hostinfo {
    my %hostinfos;

    $hostinfos{'kernel'}   = timed_run( 0, 'uname', '-r' );
    $hostinfos{'hardware'} = timed_run( 0, 'uname', '-i' );
    $hostinfos{'environment'} = get_environment();

    chomp %hostinfos;
    return \%hostinfos;
}

sub get_environment {
    my $envtype;
    if ( open my $envtype_fh, '<', '/var/cpanel/envtype' ) {
        $envtype = readline($envtype_fh);
        close $envtype_fh;
    }
    else {
        $envtype = timed_run( 0, '/usr/local/cpanel/bin/envtype' );
    }
    chomp $envtype if $envtype;
    if ( !$envtype ) {
        return 'unknown-envtype';
    }
    return $envtype;
}

sub get_cpuinfo {
    my %cpuinfos;

    open my $cpuinfo_fh, '<', '/proc/cpuinfo';
    for my $line ( readline $cpuinfo_fh ) {
        if ( $line =~ /^model name/m ) {
            $line =~ s/^model name\s+:\s+//;
            $line =~ s/\(R\)//g;
            $line =~ s/\(tm\)//g;
            $line =~ s/\s{2,}/ /;
            $line =~ s/\s*\@/ \@/;
            $cpuinfos{'model'} = $line;
            $cpuinfos{'numcores'}++;
        }
        if ( $line =~ /^cpu MHz/m ) {
            $line =~ s/^cpu MHz\s+:\s+//;
            $cpuinfos{'mhz'} = $line;
        }
    }
    close $cpuinfo_fh;

    chomp %cpuinfos;
    return \%cpuinfos;
}

sub get_meminfo {

    # General logic from WHM 56 Cpanel::Sys::Hardware::Memory
    my $proc_meminfo      = '/proc/meminfo';
    my $proc_beancounters = '/proc/user_beancounters';
    my %meminfo;

    if ( defined( $HOSTINFO->{'environment'} ) && $HOSTINFO->{'environment'} eq 'virtuozzo' ) {

        # https://wiki.openvz.org/UBC_primary_parameters#vmguarpages
        # https://wiki.openvz.org/UBC_secondary_parameters#privvmpages
        if ( open( my $proc_beancounters_fh, '<', $proc_beancounters ) ) {
            while (<$proc_beancounters_fh>) {
                if (m/^\s*(\S+)\s+(.*)/) {
                    my $type = $1;
                    my $parm = $2;
                    chomp($parm);
                    my ( $held, $maxheld, $barrier, $limit, $failcnt ) = split( /\s+/, $parm );
                    next if $held eq '-';

                    # NOTE: VZ uses the # of 4-KiB pages, convert to KiB.
                    # installed value is the lowest of privvmpages, physpages, or vmguarpages barrier (ignoring 0)
                    if ( $type =~ /^(privvmpages|physpages|vmguarpages)$/ ) {
                        unless ( $barrier eq "0" || ( defined( $meminfo{'installed'} ) && $meminfo{'installed'} <= ( $barrier * 4 ) ) ) {
                            $meminfo{'installed'} = $barrier * 4;
                        }
                    }
                    elsif ( $type eq 'oomguarpages' ) {
                        $meminfo{'used'} = $held * 4;
                    }
                    elsif ( $type eq 'swappages' ) {
                        $meminfo{'swapinstalled'} = $limit * 4;
                    }
                }
            }
            close($proc_beancounters_fh);
            $meminfo{'available'} = $meminfo{'installed'} - $meminfo{'used'};
        }
    }
    elsif ( open my $proc_meminfo_fh, '<', $proc_meminfo ) {
        while (<$proc_meminfo_fh>) {
            if (/^\s*([^\:]+):\s+(\d+)/) {
                $meminfo{ lc($1) } = $2;
            }
        }
        close $proc_meminfo_fh;
        $meminfo{'available'}     = $meminfo{'memfree'} + $meminfo{'buffers'} + $meminfo{'cached'};
        $meminfo{'installed'}     = $meminfo{'memtotal'};
        $meminfo{'used'}          = sprintf( '%u', $meminfo{'memtotal'} - $meminfo{'memfree'} );
        $meminfo{'swapinstalled'} = $meminfo{'swaptotal'};
    }

    chomp %meminfo;
    return \%meminfo;
}

sub format_meminfo {
    my ($num) = @_;
    return 'none or unknown' if ( !defined($num) );

    # The original values are 9223372036854775807 and 2147483647 4-KiB pages
    if ( defined( $HOSTINFO->{'environment'} ) && $HOSTINFO->{'environment'} eq 'virtuozzo' ) {
        return $num = 'unlimited' if $num == '36893488147419103228' + 0;    # KiB
        if ( defined( $HOSTINFO->{'hardware'} ) && $HOSTINFO->{'hardware'} eq 'i386' ) {
            return $num = 'unlimited' if $num == '8589934588' + 0;          # KiB
        }
    }
    return int( $num / 1024 ) . "MB";
}

sub get_sysctl {
    return { map { split( /\s=\s/, $_, 2 ) } split( /\n/, timed_run( 0, 'sysctl', '-a' ) ) };
}

sub print_info {
    my $text = shift;
    print BOLD YELLOW ON_BLACK "[INFO] * $text";
}

sub print_warn {
    my $text = shift;
    print BOLD RED ON_BLACK "[WARN] * $text";
}

sub print_crit {
    my $text = shift;
    $CRIT_BUFFER .= BOLD MAGENTA ON_BLACK '[CRIT] * ' . $text;
    print BOLD MAGENTA ON_BLACK '[CRIT] * ' . $text;
}

sub print_critical {
    my $text = shift;
    $text = $text ? $text : "";
    $CRIT_BUFFER .= BOLD MAGENTA ON_BLACK $text . "\n";
    print BOLD MAGENTA ON_BLACK $text . "\n";
}

sub print_3rdp {
    my $text = shift;
    print BOLD GREEN ON_BLACK "[3RDP] * $text";
}

sub print_3rdp2 {
    my $text = shift;
    print BOLD GREEN ON_BLACK "$text\n";
}

## precedes informational items (e.g., "Hostname:")
sub print_start {
    my $text = shift;
    print BOLD YELLOW ON_BLACK $text;
}
## for informational items (e.g., the server's hostname)
sub print_normal {
    my $text = shift;
    print BOLD CYAN ON_BLACK "$text\n";
}
## for important things (e.g., "Hostname is not a FQDN")
sub print_warning {
    my $text = shift;
    print BOLD RED ON_BLACK "$text\n";
}
## for other imporant things (e.g., "You are in an LVE, do not restart services")
sub print_warning_underline {
    my $text = shift;
    print BOLD UNDERLINE "$text\n";
}

sub print_info2 {
    my $text = shift;
    print BOLD GREEN ON_BLACK "$text\n";
}

sub print_magenta {
    my $text = shift;
    print BOLD MAGENTA ON_BLACK "$text\n";
}

sub print_red {
    my $text = shift;
    print BOLD RED ON_BLACK "$text\n";
}

sub check_for_hacked_server_touchfile {
    my $docdir = '/usr/share/doc';
    return if !-d $docdir;

    opendir( my $fh, $docdir ) or return;

    # .cp.jeff.2014-04-09_10.5.40.209_1234567
    my @touchfiles = grep { /^\.cp\.([^\d]+)\.(\d{4}-\d{2}-\d{2})_([^_]+)_(\d+)$/ } readdir $fh;
    closedir $fh;

    return if scalar @touchfiles == 0;

    print_critical();
    print_crit('HACKED SERVER! ');
    print_critical('[L1/L2 ESCALATE TO L3 NOW]. The following touchfiles were found:');
    for my $touchfile (@touchfiles) {
        if ( $touchfile =~ /^\.cp\.([^\d]+)\.(\d{4}-\d{2}-\d{2})_([^_]+)_(\d+)$/ ) {
            my ( $cptech, $date, $ipaddr, $ticket ) = ( $1, $2, $3, $4 );
            $date =~ s#-#/#g;
            $cptech = ucfirst $cptech;
            print_critical("\t => $docdir/$touchfile");
            print_critical("\t\t $cptech reported this server at $ipaddr as compromised on $date local server time in ticket $ticket");
            if ( !grep { /^$ipaddr$/ } @LOCAL_IPADDRS_LIST ) {
                print_critical("\t\t NOTE: IP addr $ipaddr not found on the server!");
            }
        }
    }
    print_critical();
}

sub check_for_multiple_tech_logins {

    # Prefer 'who' over 'w' because of FROM field length limit in 'w'
    # who -H
    #NAME     LINE         TIME             COMMENT
    #root     pts/0        2014-07-29 07:24 (192.168.130.1)

    # we can sometimes get additional text after the IP or hostname
    #root     pts/2        2014-08-07 07:17 (208.74.121.102:S.0)

    my $who = '/usr/bin/who';
    return if !-x $who;

    my @tech_logins = ();
    my $header      = "";
    my $num_logins  = 0;

    for my $line ( split /\n/, timed_run( 0, $who, '-H' ) ) {
        if ( $line =~ m{ \A NAME\s+ }xms ) {
            $header = $line;
            next;
        }
        if ( $line =~ m{ \((.+)\)\Z }xms ) {
            if (   $1 =~ m{ \A (.*\.)?(cptxoffice\.net|cloudlinux\.com|litespeedtech.com)(:|$) }xms
                || $1 =~ m{ \A (208\.74\.12[0-7]\.\d+|69\.175\.92\.(4[89]|5[0-9]|6[0-4])|69\.10\.42\.69)(:|$) }xms ) {
                push( @tech_logins, $line );
                $num_logins++;
            }
        }
    }

    return if $num_logins <= 1;

    print_critical();
    print_crit('Multiple tech SSH sessions are active (run "who -H -u" for complete list):');
    print_critical("\n");
    print_critical($header) if $header;
    print_critical( join( "\n", @tech_logins ) );
    print_critical();
}

sub check_for_lve_environment {

    # pam_lve 0.2 prints this after su or sudo:
    #
    # # /bin/su -
    # Password:
    # ***************************************************************************
    # *                                                                         *
    # *             !!!!  WARNING: YOU ARE INSIDE LVE !!!!                      *
    # *IF YOU RESTART ANY SERVICES STABILITY OF YOUR SYSTEM WILL BE COMPROMIZED *
    # *        CHANGE UID OF THE USER YOU ARE USING TO SU/SUDO                  *
    # *                             MORE INFO:                                  *
    # *http://www.cloudlinux.com/blog/clnews/read-this-if-you-use-su-or-sudo.php*
    # *                                                                         *
    # ***************************************************************************

    # pam_lve 0.3 won't put wheel users in an LVE after su or sudo:
    # http://cloudlinux.com/blog/clnews/read-this-if-you-use-su-or-sudo.php

    if ( $HOSTINFO->{'kernel'} =~ /\.lve/ and -x '/usr/sbin/lveps' ) {
        my $lve_check = `/usr/sbin/lveps -p | grep " $$ "`;
        if ($lve_check) {
            print_critical();
            print_crit(" You are inside a CloudLinux LVE - DO *NOT* RESTART ANY SERVICES!\n");
            print_critical("          \\_ The pam_lve configuration may not be excluding the wheel group, or your ssh login user was not in the wheel group.");
            print_critical("          \\_ http://docs.cloudlinux.com/index.html?lve_pam_module.html");
            print_critical();
        }
    }
}

sub get_lsws_version {
    my $lshttpd = '/usr/local/lsws/bin/lshttpd';
    return if !-x $lshttpd;
    my ( $lsws_full_version, $lsws_numeric_version ) = ();
    my @lshttpd_version_output = split /\n/, timed_run( 0, $lshttpd, '-v' );
    for (@lshttpd_version_output) {
        if (m{ \A (LiteSpeed/(\d+(?:\.\d+){1,2}).*) }xms) {
            $lsws_full_version    = $1;
            $lsws_numeric_version = $2;
        }
    }

    $lsws_full_version    = "unknown" if !$lsws_full_version;
    $lsws_numeric_version = "unknown" if !$lsws_numeric_version;

    return ( $lsws_full_version, $lsws_numeric_version );
}

sub check_for_os_release_5 {
    return unless version_compare( $OS_VERSION, qw( < 6 ) );
    print_crit('CentOS/RHEL/CL 5 (or older): ');
    print_critical('This operating system is not supported in WHM 58 and later (OS version 6+ only).');
    print_critical('         \_ Send customer this premade: "MIGRATION - CentOS/RHEL/CL 5 EOL"');
}

sub check_for_os_release_7 {
    return unless version_compare( $OS_VERSION, qw( >= 7 ) );
    print_crit('CentOS/RHEL/CL 7+: ');
    print_critical('Use /scripts/restartsrv to restart services, not /etc/init.d scripts.');
}

sub check_for_os_release_32bit {
    return unless ( defined( $HOSTINFO->{'hardware'} ) && $HOSTINFO->{'hardware'} eq 'i386' );
    return unless version_compare( $OS_VERSION, qw( >= 6 ) );    # There is an unofficial CentOS 7 i386 build.
    print_crit('CentOS/RHEL/CL i386 (32-bit): ');
    print_critical('This operating system is not supported in WHM 58 and later (x86_64 only).');
    print_critical('         \_ Send customer this premade: "MIGRATION - 32-bit CentOS/RHEL/CL EOL"');
}

##############################
#  BEGIN [INFO] CHECKS
##############################

sub print_hostname {

    print_info('Hostname: ');

    if ( $HOSTNAME !~ /([\w-]+)\.([\w-]+)\.(\w+)/ ) {
        print_warning("$HOSTNAME may not be a FQDN ( en.wikipedia.org/wiki/Fully_qualified_domain_name )");
    }
    else {
        print_normal($HOSTNAME);
    }
}

sub print_os {
    my $os_info               = $OS_RELEASE . " [$HOSTINFO->{'environment'}]";
    my $php_selector_conf     = '/usr/local/cpanel/base/frontend/x3/dynamicui/dynamicui_lvephpsel.conf';
    my $php_selector_disabled = 0;

    if ($IS_CLOUDLINUX) {
        if ( -f $php_selector_conf ) {
            if ( open my $file_fh, '<', $php_selector_conf ) {
                while (<$file_fh>) {
                    if (/^file=>lvephpsel,skipobj=>1/) {
                        $php_selector_disabled = 1;
                        last;
                    }
                }
                close $file_fh;
            }
        }
        else {
            $php_selector_disabled = 'status unknown';
        }
    }

    if ( $IS_CLOUDLINUX == 1 ) {
        if ( $php_selector_disabled eq 'status unknown' ) {
            $os_info .= ' [PHP Selector: status unknown]';
        }
        elsif ( $php_selector_disabled == 1 ) {
            $os_info .= ' [PHP Selector: disabled for x3]';
        }
        elsif ( $php_selector_disabled == 0 ) {
            $os_info .= ' [PHP Selector: enabled for x3]';
        }
    }

    print_info('OS: ');
    print_normal($os_info);
}

sub print_kernel_and_cpu {
    print_info('Kernel/CPU: ');
    print_normal("$HOSTINFO->{'kernel'} $HOSTINFO->{'hardware'} $HOSTINFO->{'environment'} $CPUINFO->{'model'} w/ $CPUINFO->{'numcores'} core(s)");
    if ( $HOSTINFO->{'environment'} eq 'virtuozzo' && $HOSTINFO->{'kernel'} eq '2.6.32-042stab113.11' ) {
        print_warning('         \\_ This kernel has broken quota support [ https://bugs.openvz.org/browse/OVZ-6661 ]');
    }
}

sub print_kernelcare_info {
    return unless $IS_KERNELCARE;
    my $kcarectl_path = '/usr/bin/kcarectl';
    my $kcarectl_info = "Installed";
    my $license_output;
    my $uname_output;
    if ( -x $kcarectl_path ) {
        chomp( $license_output = timed_run( 0, $kcarectl_path, '--license-info' ) );
        if ( $license_output =~ /Valid license found/ ) {
            $kcarectl_info .= ' and licensed';
        }
        else {
            $kcarectl_info .= ' (license not detected)';
        }
        chomp( $uname_output = timed_run( 0, $kcarectl_path, '--uname' ) );
        if ( ( $uname_output =~ /^\d+\.\d+\.\d+/ ) && ( $uname_output !~ /\n/ ) ) {
            $kcarectl_info .= ' [ ' . $uname_output . ' ]';
        }
    }
    print_info('KernelCare: ');
    print_normal($kcarectl_info);
}

sub print_cpanel_info {
    my $cpanel_tier;
    my ( $birthday_file, $birthday );
    my $output;

    ## cpanel-install-thread0.log is better to be checked before cpanel-install.log
    if ( -f '/var/log/cpanel-install-thread0.log' ) {
        $birthday_file = '/var/log/cpanel-install-thread0.log';
    }
    elsif ( -f '/var/log/cpanel-install.log' ) {
        $birthday_file = '/var/log/cpanel-install.log';
    }

    if ($birthday_file) {
        my $ctime = ( stat($birthday_file) )[9];
        $birthday = localtime $ctime;
    }

    if ( open my $cpupdate_fh, '<', '/etc/cpupdate.conf' ) {
        while (<$cpupdate_fh>) {
            if (m{ \A CPANEL=(.*) }xmsi) {
                chomp( $cpanel_tier = $1 );
            }
        }
        close $cpupdate_fh;
    }
    else {
        $cpanel_tier = 'Unknown (could not open/read /etc/cpupdate.conf ?)';
    }

    my $ctime       = ( stat('/usr/local/cpanel/version') )[10];
    my $last_update = time() - $ctime;
    $last_update = $last_update / 86400;
    $last_update = sprintf '%.1f', $last_update;

    $output = "${CPANEL_VERSION} " . '(' . uc($cpanel_tier) . ' tier)' . " Last update: $last_update days ago";
    $output .= " [ Installed $birthday ]" if $birthday;

    print_info('cPanel Info: ');
    print_normal($output);

    if ( cpanel_version_is(qw ( >= 11.59.0.0 )) && ( $cpanel_tier =~ /current|edge/i || -e '/var/cpanel/feature_toggles/ea4migration' ) ) {
        print_info('cPanel Info: ');
        print_warning("EA4 Migration UI is enabled/available");
    }
}

sub check_for_cpanel_update {
    my ( $TIERS_DATA, @tiers );
    my ( $tier,       $available_tier_version );
    my $local_tier_name;
    my $local_tier_version = $CPANEL_VERSION;
    my $match              = 0;
    my $update_available   = 0;

    #
    # get local tier name (e.g., edge)
    #
    my $cpupdate_conf = '/etc/cpupdate.conf';
    return if !-f $cpupdate_conf;

    if ( open my $file_fh, '<', $cpupdate_conf ) {
        while (<$file_fh>) {
            if (/\bcpanel=(.*)/i) {
                $local_tier_name = $1;
                last;
            }
        }
        close $file_fh;
    }

    return if !$local_tier_name;

    #
    # get local tier version (e.g., 11.36.0.4)
    #
    if ( $local_tier_version !~ /(\d+\.\d+\.\d+\.\d+)/ ) {
        print_info('cPanel update check: ');
        print_warning("unknown or old cPanel version $local_tier_version");
        return;
    }

    #
    # get available tiers and versions (e.g., edge:11.36.0.4)
    #
    local $SIG{'ALRM'} = sub { return (); };

    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => 'httpupdate.cpanel.net',
        PeerPort => 80,
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /cpanelsync/TIERS HTTP/1.1\r\nHost: httpupdate.cpanel.net\r\n\r\n";
        sysread $sock, $TIERS_DATA, 1000;
        close $sock;
    }

    alarm 0;

    return if !$TIERS_DATA;

    @tiers = split /\n/, $TIERS_DATA;

    #
    # does the local server use a recognized tier?
    #
    for my $line (@tiers) {
        if ( $line =~ m{ \A (.*) : (\d+\.\d+\.\d+\.\d+) \z }xms ) {
            ( $tier, $available_tier_version ) = ( $1, $2 );
            if ( $tier =~ /^${local_tier_name}$/i ) {
                $match = 1;
                last;
            }
        }
    }

    if ( $match == 0 ) {
        print_info('cPanel update check: ');
        print_warning("server is configured to use an unknown tier ($local_tier_name)");
        return;
    }

    #
    # does the local tier version match the available tier version?
    #
    return if ( $local_tier_version eq $available_tier_version );

    my ( $l1, $l2, $l3, $l4 ) = split /\./, $local_tier_version;
    my ( $r1, $r2, $r3, $r4 ) = split /\./, $available_tier_version;

    if ( $l1 < $r1 ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 < $r2 ) ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 == $r2 ) and ( $l3 < $r3 ) ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 == $r2 ) and ( $l3 == $r3 ) and ( $l4 < $r4 ) ) {
        $update_available = 1;
    }

    if ( $update_available == 1 ) {
        print_info('cPanel update check: ');
        print_warning("UPDATE AVAILABLE ($local_tier_version -> $available_tier_version)");
    }
}

sub check_perl_version_less_than_588 {
    my $perl_version = $^V;
    if ( $perl_version =~ /^v(.+)$/ ) {
        $perl_version = $1;
    }

    return if !$perl_version;

    if ( version_compare( $perl_version, qw( < 5.8.8 ) ) ) {
        print_warn('Perl Version: ');
        print_warning( 'less than 5.8.8: [ ' . $perl_version . ' ]' );
    }
    if ( version_compare( $perl_version, qw( < 5.14.0 ) ) ) {
        print_warn('Perl Version: ');
        print_warning('better resolver results can be obtained when running SSP with Perl 5.14 or later');
    }
}

sub print_uptime {
    my $uptime = timed_run( 0, 'uptime' );
    chomp $uptime if $uptime;
    $uptime = $uptime ? $uptime : 'UNKNOWN';
    print_info('Uptime: ');
    print_normal($uptime);
}

sub check_for_clustering {
    if ( -e '/var/cpanel/useclusteringdns' ) {
        print_info('DNS Clustering: ');
        print_normal('is enabled');
    }
    else {
        return;
    }

    my $cluster_dir = '/var/cpanel/cluster/root/config';
    my @dir_contents;
    my @cluster_members;
    my ( $cluster_member, $cluster_member_hostname, $cluster_member_role );

    if ( -d $cluster_dir ) {
        opendir( my $dir_fh, $cluster_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    chdir $cluster_dir or return;

    for my $dirent (@dir_contents) {

        # only active cluster members have -dnsrole files
        if ( $dirent =~ m{ \A (.+)-dnsrole \z }xms ) {
            $cluster_member = $1;

            if ( open my $file_fh, '<', "${cluster_member}.cache" ) {
                my $cache_ref;
                eval 'local $SIG{__DIE__}; local $SIG{__WARN__}; $cache_ref = Storable::fd_retrieve($file_fh);';    # from upcp.static
                close $file_fh;
                if ($cache_ref) {
                    $cluster_member_hostname = $cache_ref->{'host'};
                }
                close $file_fh;
            }
            else {
                $cluster_member_hostname = '?';
            }

            if ( !$cluster_member_hostname ) {
                $cluster_member_hostname = '?';
            }
            if ( ${cluster_member} =~ m{ \A (vps\.net|softlayer) \z}xmsi ) {
                $cluster_member_hostname = '';
            }

            if ( open my $file_fh, '<', "${cluster_member}-dnsrole" ) {
                while (<$file_fh>) {
                    $cluster_member_role = $_;
                }
                close $file_fh;
            }
            else {
                $cluster_member_role = '?';
            }

            push @cluster_members, $cluster_member_hostname . '_SSP_' . $cluster_member . '_SSP_' . "[${cluster_member_role}]";
        }
    }

    ## print sorted output for cluster members, by hostname
    if (@cluster_members) {
        @cluster_members = sort @cluster_members;

        for my $member (@cluster_members) {
            $member =~ s/_SSP_/ /g;
            print_magenta("\t \\_ $member");
        }
    }
}

sub print_apache_info {
    my $output;
    my $apache_status;

    $output .= "[ EA4 ] " if $EA4;

    if ( !$APACHE_VERSION or !$APACHE_BUILT or !$APACHE_EA_VERSION ) {
        $output .= 'could not determine Apache info!';
    }
    else {
        $output .= "[ $APACHE_VERSION ] [ $APACHE_BUILT w/ $APACHE_EA_VERSION ]";
    }

    my ( $apache_uptime, $apache_generations );

    local $SIG{'ALRM'} = sub { };
    alarm 5;

    my $apache_configured_port = 80;
    my $attempted_port = ( split( ':', $CPCONF{'apache_port'} ) )[1];
    if ($attempted_port) {
        $apache_configured_port = $attempted_port;
    }

    my $sock = IO::Socket::INET->new(
        PeerAddr => '127.0.0.1',
        PeerPort => $apache_configured_port,
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /whm-server-status HTTP/1.0\r\n\r\n";
        sysread $sock, $apache_status, 10_000;
        close $sock;
    }

    alarm 0;

    if ($apache_status) {
        my @apache_status = split /\n/, $apache_status;

        for my $line (@apache_status) {
            if ( $line =~ m{ Server \s uptime: \s+ (.*) </dt> }xms ) {
                $apache_uptime = $1;
                $apache_uptime = 'Up ' . $apache_uptime;
            }
            if ( $line =~ m{ Parent \s Server \s Generation: (.*) </dt> }xms ) {
                $apache_generations = $1;
            }
        }
        if ( $apache_uptime and $apache_generations ) {
            $output .= " [ $apache_uptime w/ $apache_generations generation(s) ]";
        }
    }
    else {
        my $warning = "";
        if ( $apache_configured_port == 80 ) {
            $warning = 'Is Apache up/slow to respond? (failed: http://localhost/whm-server-status). ';
        }
        else {
            $warning = 'Is Apache up/slow to respond? (failed: http://localhost:' . $apache_configured_port . '/whm-server-status). ';
        }

        if (@LSOF_80) {
            $warning .= 'Something is listening on port 80.';
        }
        else {
            $warning .= 'Nothing is listening on port 80';
        }

        print_info('Apache: ');
        print_warning($warning);
    }

    if ($output) {
        print_info('Apache: ');
        print_normal($output);
    }

    my %apache_ports;

    while ( my ( $portnum, $aref ) = each(%$PORT_REF) ) {
        for my $href (@$aref) {
            next if not $href->{USER} eq "root";
            next if not $href->{CMD} eq "httpd";
            $apache_ports{$portnum} = 1;
        }
    }

    if ( scalar keys(%apache_ports) ) {
        print_info('Apache: ');
        print_normal( 'is listening on ports [ ' . join( " ", sort( keys(%apache_ports) ) ) . ' ]' );
    }
}

sub print_ea3_php_configuration {
    return if $EA4;
    my $phpconf;
    $phpconf = '/usr/local/apache/conf/php.conf.yaml';

    if ( !-f $phpconf ) {
        print_info('PHP: ');
        print_warning( $phpconf . " missing.  PHP checks will be skipped." );
        return;
    }

    open my $phpconf_fh, '<', $phpconf;
    while (<$phpconf_fh>) {
        chomp;
        if (/^phpversion: (\d)/) {
            $EA3_PHPVERSION = $1;
        }
        if (/^php4:[ \t]+['"]?([^'"]+)/) {
            $EA3_PHP4HANDLER = $1;
        }
        if (/^php5:[ \t]+['"]?([^'"]+)/) {
            $EA3_PHP5HANDLER = $1;
        }
        if (/^suexec:[ \t]+['"]?([^'"]+)/) {
            $EA3_SUEXEC = $1;
        }
    }
    close $phpconf_fh;

    if ( $EA3_SUEXEC && $EA3_SUEXEC eq '1' ) {
        $EA3_SUEXEC = 'with suexec';
    }
    else {
        $EA3_SUEXEC = 'without suexec';
    }

    if ( $EA3_PHPVERSION == 5 ) {
        if ( -x '/usr/bin/php' ) {
            my @php_v = split /\n/, timed_run( 0, '/usr/bin/php', '-n', '-v' );
            if ( @php_v && $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $EA3_PHP5VERSION = $1;
            }
            else {
                $EA3_PHP5VERSION = '(version unknown)';
            }

            if ($EA3_PHP5HANDLER) {
                print_info('PHP Default: ');
                print_normal("PHP $EA3_PHP5VERSION $EA3_PHP5HANDLER $EA3_SUEXEC");
            }
        }

        if ( $EA3_PHP4HANDLER && $EA3_PHP4HANDLER ne 'none' ) {
            my @php_v = split /\n/, timed_run( 0, '/usr/local/php4/bin/php', '-v' );
            if ( @php_v && $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $EA3_PHP4VERSION = $1;
            }
            else {
                $EA3_PHP4VERSION = '(version unknown)';
            }

            print_info('PHP Secondary: ');
            print_normal("PHP $EA3_PHP4VERSION $EA3_PHP4HANDLER $EA3_SUEXEC");
        }
    }

    if ( $EA3_PHPVERSION && $EA3_PHPVERSION == 4 ) {
        if ( -x '/usr/local/php4/bin/php' ) {
            my @php_v = split /\n/, timed_run( 0, '/usr/local/php4/bin/php', '-v' );
            if ( $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $EA3_PHP4VERSION = $1;
            }
            else {
                $EA3_PHP4VERSION = '(version unknown)';
            }

            if ( $EA3_PHP4HANDLER && $EA3_PHP4HANDLER eq 'fcgi' ) {
                print_info('PHP Default: ');
                print_warning("PHP $EA3_PHP4VERSION $EA3_PHP4HANDLER $EA3_SUEXEC (mod_userdir style URLs don't work with fcgi!)");
            }
            else {
                print_info('PHP Default: ');
                print_normal("PHP $EA3_PHP4VERSION $EA3_PHP4HANDLER $EA3_SUEXEC");
            }
        }

        if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER ne 'none' ) {
            my @php_v = split /\n/, timed_run( 0, '/usr/bin/php', '-n', '-v' );
            if ( $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $EA3_PHP5VERSION = $1;
            }
            else {
                $EA3_PHP5VERSION = '(version unknown)';
            }

            print_info('PHP Secondary: ');
            print_normal("PHP $EA3_PHP5VERSION $EA3_PHP5HANDLER $EA3_SUEXEC");
        }
    }

    if ( ( ( $EA3_PHP4HANDLER && $EA3_PHP5HANDLER ) && ( $EA3_PHP4HANDLER eq 'none' && $EA3_PHP5HANDLER eq 'none' ) ) || !( $EA3_PHP4HANDLER && $EA3_PHP5HANDLER ) ) {
        print "\n";
        print_warn('PHP: ');
        print_warning('no handler defined for PHP4 or PHP5!');
    }
}

sub print_ea4_php_configuration {
    return if !$EA4;
    my $info;
    my $cgi_handler = 0;
    print_info("PHP Default: ");
    if ( defined($EA4_PHP) && defined( $EA4_PHP->{default} ) && defined( $EA4_PHP->{ $EA4_PHP->{default} }->{release_version} ) && defined( $EA4_PHP->{ $EA4_PHP->{default} }->{handler} ) ) {
        $cgi_handler = 1 if $EA4_PHP->{ $EA4_PHP->{default} }->{handler} eq "cgi";
        $info .= "[ EA4 ]";
        $info .= " [ " . $EA4_PHP->{ $EA4_PHP->{default} }->{release_version} . " ( " . $EA4_PHP->{default} . " ) ]";
        $info .= " [ " . $EA4_PHP->{ $EA4_PHP->{default} }->{handler} . " ]";
    }
    else {
        $info .= "UNKNOWN";
    }
    print_normal($info);
}

sub _get_installed_ea4_php {
    return if !$EA4;
    my $php = {};
    my @available_php;
    my @current_php;
    my ( $available_php, $current_php );
    if ( cpanel_version_is(qw ( >= 11.53 )) ) {
        (@current_php) = split( /\n/, timed_run( 0, '/usr/local/cpanel/bin/rebuild_phpconf', '--current' ) );
        foreach my $line (@current_php) {
            my $pkg;
            if ( $line =~ /DEFAULT PHP: (ea-php\d{1,2})/ ) {
                $pkg                        = $1;
                $php->{$pkg}->{default_php} = 1;
                $php->{default}             = $pkg;
                next;
            }
            if ( $line =~ /(ea-php\d{1,2}) SAPI:\s(\w+)/ ) {
                $pkg                    = $1;
                $php->{$pkg}->{handler} = $2;
                $php->{$pkg}->{path}    = "/opt/cpanel/$1/root/usr/bin/php";
                foreach ( split( /\n/, timed_run( 0, $php->{$pkg}->{path}, '-v' ) ) ) {
                    if (/PHP\s(\d\.\d+\.\d+)\s\(cli\)\s\(built:\s(\w+\s+\d+\s\d+\s\d+:\d+:\d+)/) {
                        $php->{$pkg}->{release_version} = $1;
                        $php->{$pkg}->{build_time}      = $2;
                        $php->{$pkg}->{build_time} =~ s/  / /;
                    }
                    if (/Zend\sEngine\sv(\d+\.\d+\.\d+)/) {
                        $php->{$pkg}->{zend} = $1;
                    }
                }

                # Gather a list of modules for this given PHP Binary
                @{ $php->{$pkg}->{module_list} } = grep { !/\[PHP\sModules\]/ && /\w/ && !/Zend/ } split( /\n/, timed_run( 0, $php->{$pkg}->{path}, '-m' ) );
            }
        }
    }
    else {    # WHM <= 11.52
        ( $available_php, $current_php ) = split( /\nC/, timed_run( 0, '/usr/local/cpanel/bin/rebuild_phpconf', '--current' ) );
        @available_php = grep { !/handlers/ } split( /\n/, $available_php );
        @current_php   = grep { !/handlers/ } split( /\n/, $current_php );
        foreach my $line (@current_php) {
            if ( $line =~ /(ea-php\d{1,2}):\s(\w+)/m ) {
                my $pkg = $1;
                $php->{$pkg}->{handler} = $2;
                $php->{$pkg}->{path}    = "/opt/cpanel/$1/root/usr/bin/php";
                if ( $line =~ /DEFAULT/i ) {
                    $php->{$pkg}->{default_php} = 1;
                    $php->{default} = $pkg;
                }
                foreach ( split( /\n/, timed_run( 0, $php->{$pkg}->{path}, '-v' ) ) ) {
                    if (/PHP\s(\d\.\d+\.\d+)\s\(cli\)\s\(built:\s(\w+\s+\d+\s\d+\s\d+:\d+:\d+)/) {
                        $php->{$pkg}->{release_version} = $1;
                        $php->{$pkg}->{build_time}      = $2;
                        $php->{$pkg}->{build_time} =~ s/  / /;
                    }
                    if (/Zend\sEngine\sv(\d+\.\d+\.\d+)/) {
                        $php->{$pkg}->{zend} = $1;
                    }
                }

                # Gather a list of modules for this given PHP Binary
                @{ $php->{$pkg}->{module_list} } = grep { !/\[PHP\sModules\]/ && /\w/ && !/Zend/ } split( /\n/, timed_run( 0, $php->{$pkg}->{path}, '-m' ) );
            }
        }
    }
    return $php;
}

sub check_sysinfo {
    return if !-x '/scripts/gensysinfo';

    my $sysinfo_config = '/var/cpanel/sysinfo.config';

    my $rebuild = 0;

    if ( !-e $sysinfo_config ) {
        print_info('sysinfo: ');
        print_warning('does not exist, running /scripts/gensysinfo to fix');
        timed_run( 0, '/scripts/gensysinfo' );
    }
    else {
        open my $sysinfo_fh, '<', $sysinfo_config;
        while (<$sysinfo_fh>) {
            chomp;
            if (m{ \A rpm_arch=(.*) }xms) {
                if ( $HOSTINFO->{'hardware'} ne $1 ) {
                    $rebuild = 1;
                }
            }
            if (m{ \A release=(.*) }xms) {
                if ( $OS_VERSION ne $1 ) {
                    $rebuild = 1;
                }
            }
            if (m{ \A ises=(.*) }xms) {
                if ( $OS_ISES ne $1 ) {
                    $rebuild = 1;
                }
            }
        }
        close $sysinfo_fh;
    }

    if ( $rebuild == 1 ) {
        timed_run( 0, 'mv', $sysinfo_config, "${sysinfo_config}.ssp.$^T" );
        timed_run( 0, '/scripts/gensysinfo' );
        print_info('sysinfo: ');
        print_warning('/var/cpanel/sysinfo.config contained errors and was rebuilt');
    }
}

sub check_for_remote_mysql {
    my $mysql_host;
    my $mysql_is_local;

    ## obtain mysql host, if exists
    my $my_cnf = '/root/.my.cnf';
    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A host \s* = \s* (?:["']?) ([^"']+) }xms ) {
                $mysql_host = $1;
            }
        }
        close $my_cnf;
    }

    if ($mysql_host) {
        if ( $mysql_host =~ m{ ( \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} )  }xms ) {
            return if ( $mysql_host eq '127.0.0.1' );
            for my $ipaddr (@LOCAL_IPADDRS_LIST) {
                if ( $ipaddr eq $mysql_host ) {
                    $mysql_is_local = 1;
                    last;
                }
            }
        }
        elsif ( $mysql_host eq 'localhost' or $mysql_host eq hostname() ) {
            $mysql_is_local = 1;
        }
        if ( !$mysql_is_local ) {
            print_info('Remote MySQL Host: ');
            print_warning($mysql_host);
        }
    }
}

sub print_if_using_mydns_or_nsd {
    if ( -e '/var/cpanel/usensd' ) {
        print_info('DNS Service: ');
        print_normal('NSD ');
    }
    elsif ( -e '/var/cpanel/usemydns' ) {
        print_info('DNS Service: ');
        print_normal('MyDNS ');
    }
}

sub print_if_mod_userdir {
    if ( $EA4 && cpanel_version_is(qw( >= 11.59.0.0 )) ) {
        print_info('Mod Userdir: ');
        print_warning("will not execute PHP scripts via PHP-FPM");
    }
    if ( defined($EA4_PHP) && defined( $EA4_PHP->{default} ) && defined( $EA4_PHP->{ $EA4_PHP->{default} }->{handler} ) && $EA4_PHP->{ $EA4_PHP->{default} }->{handler} eq "cgi" ) {
        print_info('Mod Userdir: ');
        print_warning("will not execute PHP scripts via cgi handler");
    }
    if ( $APACHE_PER_USER eq "ruid2" ) {
        print_info('Mod Userdir: ');
        print_warning('doesn\'t work with Mod Ruid2');
        return;
    }
    if ( $APACHE_PER_USER eq "itk" ) {
        print_info('Mod userdir: ');
        print_warning('doesn\'t work with MPM ITK');
        return;
    }
}

sub print_mysql_version {
    my $mysql_output = timed_run( 0, 'mysql', '-V' );
    if ($mysql_output) {
        chomp $mysql_output;
        print_info('MySQL Version: ');
        print_normal($mysql_output);
        if ($IS_CPANEL) {
            my $mysql_distrib = "Distrib " . $CPCONF{'mysql-version'};
            chomp($mysql_distrib);
            if ( !( $mysql_output =~ m/$mysql_distrib/ ) ) {
                print_warning( "\t \\_ mysql-version=" . $CPCONF{'mysql-version'} . ' in cpanel.config does not match installed version!' );
            }
        }
    }
}

sub get_backup_config {
    my $new_backup_dir    = '/var/cpanel/backups/';
    my $new_backup_config = $new_backup_dir . 'config';
    my $old_backup_config = '/etc/cpbackup.conf';
    my ( $new, $old );

    if ( -f $new_backup_config && open( my $backupconf_fh, '<', $new_backup_config ) ) {
        local $/ = undef;
        $new = { map { ( split( /:\s/, $_, 2 ) )[ 0, 1 ] } split( /\n/, readline($backupconf_fh) ) };
        close $backupconf_fh;
    }

    if ( -f $old_backup_config && open( my $backupconf_fh, '<', $old_backup_config ) ) {
        local $/ = undef;
        $old = { map { ( split( /\s/, $_, 2 ) )[ 0, 1 ] } split( /\n/, readline($backupconf_fh) ) };
        close $backupconf_fh;
    }

    return ( $old, $new );
}

sub print_backups_info {
    my %new      = ();
    my %new_dest = ();
    my %old      = ();
    my ( $new_backups_cron, $new_backups_status ) = ( 0, 'No Config' );
    my ( $old_backups_cron, $old_backups_status ) = ( 0, 'No Config' );
    my $warning           = 0;
    my $new_backup_dir    = '/var/cpanel/backups/';
    my $new_backup_config = $new_backup_dir . 'config';
    my $old_backup_config = '/etc/cpbackup.conf';

    my ( $new, $old ) = get_backup_config();

    if ( defined( $NEW_BACKUP_CONF->{'BACKUPENABLE'} ) && $NEW_BACKUP_CONF->{'BACKUPENABLE'} =~ /yes/ ) {
        my @dir_contents = ();
        if ( opendir( my $dir_fh, $new_backup_dir ) ) {
            @dir_contents = readdir $dir_fh;
            closedir $dir_fh;
        }

        for my $dest (@dir_contents) {
            if ( $dest =~ m{ \.backup_destination \z }xms ) {
                if ( open( my $destconf_fh, '<', $new_backup_dir . $dest ) ) {
                    local $/ = undef;
                    %{ $new_dest{$dest} } = map { ( split( /:\s/, $_, 2 ) )[ 0, 1 ] } split( /\n/, readline($destconf_fh) );
                    close $destconf_fh;
                }
            }
        }
    }

    if ( ( defined( $OLD_BACKUP_CONF->{'BACKUPENABLE'} ) and $OLD_BACKUP_CONF->{'BACKUPENABLE'} eq 'yes' ) or ( defined( $NEW_BACKUP_CONF->{'BACKUPENABLE'} ) and $NEW_BACKUP_CONF->{'BACKUPENABLE'} =~ /yes/ ) ) {
        if ( open my $file_fh, '<', '/var/spool/cron/root' ) {
            while (<$file_fh>) {
                if (m{ \A [^#] .+ /usr/local/cpanel/scripts/cpbackup }xms) {
                    $old_backups_cron = 1;
                }
                if (m{ \A [^#] .+ /usr/local/cpanel/bin/backup }xms) {
                    $new_backups_cron = 1;
                }
            }
            close $file_fh;
        }
    }

    if ( defined( $NEW_BACKUP_CONF->{'BACKUPENABLE'} ) ) {
        if ( $NEW_BACKUP_CONF->{'BACKUPENABLE'} =~ /yes/ ) {
            $new_backups_status = 'Enabled';
            if ( defined( $NEW_BACKUP_CONF->{'BACKUPACCTS'} ) && $NEW_BACKUP_CONF->{'BACKUPACCTS'} =~ /yes/ ) {
                $new_backups_status .= '/WithAccounts';
            }
            elsif ( defined( $NEW_BACKUP_CONF->{'BACKUPACCTS'} ) && $NEW_BACKUP_CONF->{'BACKUPACCTS'} =~ /no/ ) {
                $new_backups_status .= '/NoAccounts';
            }

            if ( defined( $NEW_BACKUP_CONF->{'BACKUPTYPE'} ) && $NEW_BACKUP_CONF->{'BACKUPTYPE'} =~ /uncompressed/ ) {
                $new_backups_status .= '/Uncompressed';
            }
            elsif ( defined( $NEW_BACKUP_CONF->{'BACKUPTYPE'} ) && $NEW_BACKUP_CONF->{'BACKUPTYPE'} =~ /compressed/ ) {
                $new_backups_status .= '/Compressed';
            }
            elsif ( defined( $NEW_BACKUP_CONF->{'BACKUPTYPE'} ) && $NEW_BACKUP_CONF->{'BACKUPTYPE'} =~ /incremental/ ) {
                $new_backups_status .= '/Incremental';
            }
            else {
                $new_backups_status .= '/Unknown';
            }

            if ( $new_backups_cron != 1 ) {
                $new_backups_status .= ' (MISSING CRON!)';
                $warning = 1;
            }
        }
        elsif ( $NEW_BACKUP_CONF->{'BACKUPENABLE'} =~ /no/ ) {
            $new_backups_status = 'Disabled';
        }
    }

    if ( defined( $OLD_BACKUP_CONF->{'BACKUPENABLE'} ) ) {
        if ( $OLD_BACKUP_CONF->{'BACKUPENABLE'} eq 'restoreonly' ) {
            $old_backups_status = 'RestoreOnly';
        }
        elsif ( $OLD_BACKUP_CONF->{'BACKUPENABLE'} eq 'yes' ) {
            $old_backups_status = 'Enabled';
            if ( defined( $old->{'BACKUPACCTS'} ) && $old->{'BACKUPACCTS'} eq 'yes' ) {
                $old_backups_status .= '/WithAccounts';
            }
            elsif ( defined( $OLD_BACKUP_CONF->{'BACKUPACCTS'} ) && $OLD_BACKUP_CONF->{'BACKUPACCTS'} eq 'no' ) {
                $old_backups_status .= '/NoAccounts';
            }

            if ( defined( $OLD_BACKUP_CONF->{'BACKUPINC'} ) && $OLD_BACKUP_CONF->{'BACKUPINC'} eq 'yes' ) {
                $old_backups_status .= '/Incremental';
            }
            elsif ( defined( $OLD_BACKUP_CONF->{'COMPRESSACCTS'} ) && $OLD_BACKUP_CONF->{'COMPRESSACCTS'} eq 'yes' ) {
                $old_backups_status .= '/Compressed';
            }
            elsif ( defined( $OLD_BACKUP_CONF->{'COMPRESSACCTS'} ) && $OLD_BACKUP_CONF->{'COMPRESSACCTS'} eq 'no' ) {
                $old_backups_status .= '/Uncompressed';
            }
            else {
                $old_backups_status .= '/Unknown';
            }

            if ( $old_backups_cron != 1 ) {
                $old_backups_status .= ' (MISSING CRON!)';
                $warning = 1;
            }
        }
        elsif ( $OLD_BACKUP_CONF->{'BACKUPENABLE'} eq 'no' ) {
            $old_backups_status = 'Disabled';
        }
    }

    if ( keys(%new_dest) ) {
        if ( defined( $NEW_BACKUP_CONF->{'KEEPLOCAL'} ) && $NEW_BACKUP_CONF->{'KEEPLOCAL'} =~ /1/ ) {
            $new_backups_status .= '/RetainLocal';
        }
        else {
            $new_backups_status .= '/NoRetainLocal';
        }
    }

    print_info('Backups: ');
    if ($warning) {
        print_warning("[New: $new_backups_status] [Legacy: $old_backups_status]");
    }
    else {
        print_normal("[New: $new_backups_status] [Legacy: $old_backups_status]");
    }

    for my $dest ( keys(%new_dest) ) {
        my $type = exists $new_dest{$dest}->{'type'} ? $new_dest{$dest}{'type'} : 'UNKNOWN';
        my $disabled    = exists $new_dest{$dest}{'disabled'}  ? ( $new_dest{$dest}{'disabled'} ? "Yes" : "No" ) : 'UNKNOWN';
        my $name        = exists $new_dest{$dest}{'name'}      ? $new_dest{$dest}{'name'}                        : 'UNKNOWN';
        my $timeoutdest = exists $new_dest{$dest}->{'timeout'} ? $new_dest{$dest}{'timeout'}                     : 'UNKNOWN';
        print_normal( "\t\t\\_ Remote dest: [Type: " . $type . "] [Disabled: " . $disabled . "] [Name: " . $name . "] [Timeout: " . $timeoutdest . "]" );
        if ( $type eq "SFTP" && exists $new_dest{$dest}{'privatekey'} && exists $new_dest{$dest}{'passphrase'} ) {
            my $key_is_encrypted = 0;
            if ( open my $privatekey_fh, '<', $new_dest{$dest}->{'privatekey'} ) {
                while (<$privatekey_fh>) {
                    if (/ENCRYPTED/) {
                        $key_is_encrypted = 1;
                        last;
                    }
                }
                close $privatekey_fh;
            }
            if ( !$key_is_encrypted ) {
                print_warning("\t\t   \\_ The SFTP private key is not encrypted but the transport config contains a passphrase.  See FB-152341 and FB-152337.");
            }
        }
    }
}

sub print_mailserver_info {
    print_info('Mailserver: ');
    if ( defined $CPCONF{'mailserver'} ) {
        print_normal( $CPCONF{'mailserver'} );
    }
    else {
        print_warning('missing setting in cpanel.config');
    }
}

sub print_ftpserver_info {
    print_info('FTP Server: ');

    my $passiveports = "";

    if ( defined( $CPCONF{'ftpserver'} ) ) {
        if ( $CPCONF{'ftpserver'} eq 'pure-ftpd' ) {
            if ( defined( $PUREFTPDCONF->{'passiveportrange'} ) && defined( $PUREFTPDCONF->{'passiveportrange'}->{value} ) ) {
                $passiveports = $PUREFTPDCONF->{'passiveportrange'}->{value};
            }
        }
        if ( $CPCONF{'ftpserver'} eq 'proftpd' ) {
            if ( defined( $PROFTPDCONF->{'passiveports'} ) && defined( $PROFTPDCONF->{'passiveports'}->{value} ) ) {
                $passiveports = $PROFTPDCONF->{'passiveports'}->{value};
            }
        }
    }
    my $fwppactive = 0;
    if ($passiveports) {
        $passiveports =~ s/\s+/:/;
        my @fwcommand = timed_run( 10, '/sbin/iptables', '-nL' );
        foreach my $fwline (@fwcommand) {
            chomp($fwline);
            if ( $fwline =~ m/$passiveports/ and $fwline =~ m/ACCEPT/ ) {
                $fwppactive = 1;
                last;
            }
        }
    }

    my $passivetext = $passiveports ? "enabled - " . ( $fwppactive ? "allowed in iptables" : "not found in iptables" ) : "not enabled";

    if ( defined( $CPCONF{'ftpserver'} ) ) {
        print_normal( $CPCONF{'ftpserver'} . " ( Passive ports " . $passivetext . " )" );
    }
    else {
        print_warning('missing ftpserver setting in cpanel.config');
        return;
    }
}

sub check_for_custom_zonetemplates {
    my $template_dir = '/var/cpanel/zonetemplates';
    return if !-e $template_dir;

    my $is_empty = 0;

    opendir( my $fh, $template_dir ) or return;
    my @dirents = grep { !/^\.\.?/ } readdir $fh;
    closedir $fh;

    return if !@dirents;

    for my $file (@dirents) {
        if ( -z "${template_dir}/${file}" ) {
            $is_empty = 1;
            last;
        }
    }

    print_info('Zone templates: ');
    if ( $is_empty == 1 ) {
        print_red("found in $template_dir - some may be empty! See ticket 4897373");
    }
    else {
        print_normal("found in $template_dir");
    }
}

sub print_lsws_info {
    return if !$LSWS_FULL_VERSION;
    print_info('LiteSpeed Web Server: ');
    print_normal( 'version [ ' . $LSWS_FULL_VERSION . ' ]' );

    my %lshttpd_ports = ();

    while ( my ( $portnum, $aref ) = each(%$PORT_REF) ) {
        for my $href (@$aref) {
            next if not $href->{USER} eq "root";
            next if not $href->{CMD} eq "litespeed";
            $lshttpd_ports{$portnum} = 1;
        }
    }
    if ( scalar keys(%lshttpd_ports) ) {
        print_info('LiteSpeed Web Server: ');
        print_normal( 'is listening on ports [ ' . join( " ", sort( keys(%lshttpd_ports) ) ) . ' ]' );
    }
    if ( $LSWS_FULL_VERSION =~ /Enterprise/ ) {
        print_info('LiteSpeed Web Server: ');
        print_normal('is supported, see http://cpanel.wiki/display/LS/LiteSpeed');
    }
    else {
        print_info('LiteSpeed Web Server: ');
        print_warning('non-Enterprise editions of LiteSpeed are NOT directly supported');
        if ( cpanel_version_is(qw( < 11.59.9999.111 )) ) {
            print_info('LiteSpeed Web Server: ');
            print_warning('Only WHM 60 and later support SNI with OpenLiteSpeed - see CPANEL-8151');
        }
    }
    print_info('LiteSpeed Web Server: ');
    print_warning('whm-server-status is incompatible with LiteSpeed');
}

sub check_for_lsws_update {
    return unless defined($LSWS_NUMERIC_VERSION);
    return if $LSWS_NUMERIC_VERSION eq "unknown";
    return unless $LSWS_FULL_VERSION =~ /Enterprise/;

    my ( $LSWS_DATA, @lsws_data ) = ();
    my $available_lsws_version;

    local $SIG{'ALRM'} = sub { return (); };

    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => 'update.litespeedtech.com',
        PeerPort => 80,
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /ws/latest.php HTTP/1.1\r\nUser-Agent: SSP/" . $VERSION . "\r\nHost: update.litespeedtech.com\r\n\r\n";
        sysread $sock, $LSWS_DATA, 1000;
        close $sock;
    }

    alarm 0;

    return if !$LSWS_DATA;

    @lsws_data = split /\n/, $LSWS_DATA;

    for (@lsws_data) {
        if (m{ \A LSWS=(\d+\.\d+\.\d+) \z }xms) {
            $available_lsws_version = $1;
            last;
        }
    }
    return unless $available_lsws_version;

    if ( version_compare( $LSWS_NUMERIC_VERSION, '<', $available_lsws_version ) ) {
        print_info('LiteSpeed Web Server: ');
        print_warning("UPDATE AVAILABLE ($LSWS_NUMERIC_VERSION -> $available_lsws_version)");
    }
}

sub print_news {
    if ( cpanel_version_is(qw( >= 11.52.0.0 )) ) {
        print_info('WHM 11.52+: ');
        print_normal('Slow email delivery or monitoring service detects SMTP has failed? 11.52 added SMTP connection delays, see DOC-6092.');
    }
}

##############################
#  END [INFO] CHECKS
##############################

##############################
#  BEGIN [WARN] CHECKS
##############################

sub check_port_hash {
    return if ( scalar keys(%$PORT_REF) >= 1 );
    print_warn('lsof: ');
    print_warning('Did not return a list of TCP ports in LISTEN state.');
    print_warning('  Either lsof is broken or there are zero listening services.');
    print_warning('  Some port-based checks will be skipped!');
}

sub check_selinux_status {
    my @selinux_status = split /\n/, timed_run( 0, 'sestatus' );

    return if !@selinux_status;

    for my $line (@selinux_status) {
        if ( $line =~ m{ \A SELinux \s status: \s+ ([^\s\n]+) }xms ) {
            return if $1 eq "disabled";
            print_warn('SELinux: ');
            print_warning('is NOT disabled!');
        }
    }
}

sub check_runlevel {
    if ( $OS eq 'linux' ) {
        my $runlevel;
        my $who_r = timed_run( 0, 'who', '-r' );

        # CentOS 5.7, 5.8:
        #         run-level 3  2012-01-25 10:38                   last=S
        if ( $who_r =~ m{ \A \s* run-level \s (\S+) }xms ) {
            $runlevel = $1;

            if ( $runlevel ne "3" ) {
                print_warn('Runlevel: ');
                print_warning("runlevel is not 3 (current runlevel: $runlevel)");
            }
        }
    }
}

sub check_for_missing_root_cron {
    my $cron;
    $cron = '/var/spool/cron/root';

    if ( !-f $cron ) {
        print_warn('Missing cron: ');
        print_warning("root's cron file $cron is missing!");
    }
}

sub check_for_missing_usr_bin_crontab {
    my $crontab = '/usr/bin/crontab';
    if ( !-f $crontab ) {
        print_warn('Missing crontab binary: ');
        print_warning( 'file ' . $crontab . ' is missing!  Seeing "warn [jail_safe_crontab] Cpanel::Wrap::send_cpwrapd_request error"?  This may be why.' );
    }
}

sub check_if_upcp_is_running {
    my $upcp_running   = 0;
    my $upcp_touchfile = 0;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A root (?:.*) cPanel \s Update \s \(upcp\) }xms ) {
            $upcp_running = 1;
            last;
        }
    }

    if ( -e '/usr/local/cpanel/upgrade_in_progress.txt' ) {
        $upcp_touchfile = 1;
    }

    if ( $upcp_running == 1 ) {
        print_warn('upcp check: ');
        print_warning('upcp is currently running');
    }
    elsif ( $upcp_touchfile == 1 ) {
        print_warn('upcp check: ');
        print_warning('/usr/local/cpanel/upgrade_in_progress.txt found, but upcp doesn\'t appear to be running. Last run failed? If Tweak Settings is not loading, this may be why.');
    }
}

sub check_valid_upcp {
    my $updatenow_static = '/scripts/updatenow.static';
    my $updatenow_valid  = 0;

    if ( !-f $updatenow_static ) {
        print_warn('Valid updatenow.static: ');
        print_warning("$updatenow_static does not exist as a file!");
    }
    else {
        open my $updatenow_fh, '<', $updatenow_static;
        local $/ = undef;
        my $update_now_text = readline($updatenow_fh);
        close $updatenow_fh;
        if ( $update_now_text =~ m/our \$VERSION_BUILD/s ) {
            $updatenow_valid = 1;
        }
    }
    if ( !$updatenow_valid ) {
        print_warn('Valid updatenow.static: ');
        print_warning("No VERSION_BUILD info found in $updatenow_static, could be broken!");
    }
}

sub check_interface_lo {
    my $is_up = 0;
    my $output;

    unless ( $output = timed_run( 0, 'ip', 'addr', 'show', 'dev', 'lo' ) ) {
        $output = timed_run( 0, 'ifconfig', 'lo' );
    }

    if ( $output =~ /UP.LOOPBACK|LOOPBACK.UP/ ) {    # ip addr and ifconfig swap the LOOPBACK and UP keywords
        $is_up = 1;
    }

    if ( !$is_up ) {
        print_warn('Loopback Interface: ');
        print_warning('loopback interface is not up!');
    }
    else {
        check_loopback_connection();
    }
}

sub check_loopback_connection {
    return unless $IS_CPANEL;
    my @ports     = qw( 25 80 143 );
    my $connected = 0;

    for my $port (@ports) {
        my $sock = IO::Socket::INET->new(
            PeerAddr => '127.0.0.1',
            PeerPort => $port,
            Proto    => 'tcp',
            Timeout  => '1',
        );

        if ($sock) {
            $connected = 1;
            close $sock;
        }

        last if $connected == 1;
    }

    if ( !$connected ) {
        print_warn('Loopback connectivity: ');
        print_warning('could not connect to 127.0.0.1 on ports 25, 80, or 143');
    }
}

sub check_cpanelconfig_filetype {
    chomp( my $file = timed_run( 0, 'file', '/var/cpanel/cpanel.config' ) );
    if ( $file !~ m{ \A /var/cpanel/cpanel.config: \s ASCII \s text (, \s with \s very \s long \s lines)? \z }xms ) {
        print_warn('/var/cpanel/cpanel.config: ');
        print_warning("filetype is something other than 'ASCII text'! ($file)");
    }
}

sub check_cpanelsync_exclude {
    my $cpanelsync_exclude = '/etc/cpanelsync.exclude';

    my $rpmversions_file      = '/usr/local/cpanel/etc/rpm.versions';
    my $excluding_rpmversions = 0;

    if ( -f $cpanelsync_exclude and !-z $cpanelsync_exclude ) {
        if ( open my $file_fh, '<', $cpanelsync_exclude ) {
            while (<$file_fh>) {
                chomp;
                if (m{ \A \s* $rpmversions_file \s* \z }xms) {
                    $excluding_rpmversions = 1;
                    last;
                }
            }
            close $file_fh;
        }
    }

    if ( $excluding_rpmversions == 1 ) {
        print_warn('cpanelsync exclude: ');
        print_warning("$rpmversions_file found! This should NEVER be done!");
    }
    else {
        # sloppy, as we check this above already, but I'm too busy to care
        if ( -f $cpanelsync_exclude and !-z $cpanelsync_exclude ) {
            print_warn('cpanelsync exclude: ');
            print_warning("$cpanelsync_exclude is not empty!");
        }
    }
}

sub check_for_rawopts {
    my $rawopts_dir = '/var/cpanel/easy/apache/rawopts';
    my @dir_contents;

    if ( -d $rawopts_dir ) {
        opendir( my $dir_fh, $rawopts_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if (@dir_contents) {
        print_warn('Rawopts Detected: ');
        print_warning('check /var/cpanel/easy/apache/rawopts !');
    }
}

sub check_for_rawenv {
    my $rawenv_dir = '/var/cpanel/easy/apache/rawenv';
    my @dir_contents;

    if ( -d $rawenv_dir ) {
        opendir( my $dir_fh, $rawenv_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if (@dir_contents) {
        print_warn('Rawenv detected: ');
        print_warning('check /var/cpanel/easy/apache/rawenv !');
    }
}

sub check_for_custom_opt_mods {
    my $custom_opt_mods;
    my $dir = '/var/cpanel/easy/apache/custom_opt_mods';

    return if !-e $dir;

    find( \&find_custom_opt_mods, $dir );

    if ( scalar @CUSTOM_OPT_MODS > 10 ) {
        print_warn("$dir: ");
        print_warning('many custom opt mods exist, check manually');
    }
    elsif (@CUSTOM_OPT_MODS) {
        for my $custom_opt_mod (@CUSTOM_OPT_MODS) {
            $custom_opt_mods .= "$custom_opt_mod ";
        }

        print_warn("$dir: ");
        print_warning($custom_opt_mods);
    }
}

sub find_custom_opt_mods {

    # ignore these, Attracta:
    #  /var/cpanel/easy/apache/custom_opt_mods/Cpanel/Easy/ModFastInclude.pm
    #  /var/cpanel/easy/apache/custom_opt_mods/Cpanel/Easy/ModFastInclude.pm.tar.gz

    my $file = $File::Find::name;
    if ( -f $file and $file !~ m{ /ModFastInclude\.pm(.*) }xms ) {
        $file =~ s#/var/cpanel/easy/apache/custom_opt_mods/##;
        push @CUSTOM_OPT_MODS, $file;
    }
}

sub check_for_local_templates {
    my @templatedirs = qw(
      /var/cpanel/templates/apache2_4
      /var/cpanel/templates/apache2_2
      /var/cpanel/templates/apache2_0
      /var/cpanel/templates/apache2
      /var/cpanel/templates/apache1_3
      /var/cpanel/templates/apache1
      /var/cpanel/templates/dovecot2.2
      /var/cpanel/templates/dovecotSNI
      );    # Order is somewhat important above for cosmetic reasons, due to symlinks
    my %templatedirs = ();

    for my $templatedir (@templatedirs) {    # Canonicalize symlinks so we only check a real path once, but store original name for printing.
        next if !-d $templatedir;
        $templatedirs{ abs_path($templatedir) } = $templatedir;
    }
    for my $templatedir ( sort( keys(%templatedirs) ) ) {
        my @dir_contents = ();
        if ( opendir( my $dir_fh, $templatedir ) ) {
            @dir_contents = readdir $dir_fh;
            closedir $dir_fh;
        }

        my $templates = undef;
        for my $template (@dir_contents) {
            if ( $template =~ m{ \.local \z }xms ) {
                $templates .= " $template";
            }
        }
        if ($templates) {
            print_warn( 'Custom templates (' . $templatedirs{$templatedir} . '): ' );
            print_warning($templates);
        }
    }
}

sub check_for_missing_account_suspensions_conf {
    return if !-f '/usr/local/apache/conf/includes/account_suspensions.conf';
    my @templates = qw(
      /var/cpanel/templates/apache2_4/main.local
      /var/cpanel/templates/apache2_2/main.local
      /var/cpanel/templates/apache2_0/main.local
      /var/cpanel/templates/apache2/main.local
      /var/cpanel/templates/apache1_3/main.local
      /var/cpanel/templates/apache1/main.local
      );    # Order is somewhat important above for cosmetic reasons, due to symlinks

    my %templates = ();
    for my $template (@templates) {    # Canonicalize symlinks so we only check a real path once, but store original name for printing.
        next if !-f $template;
        $templates{ abs_path($template) }[0] = $template;
    }

    for my $template ( sort( keys(%templates) ) ) {
        next if !-f $template;
        $templates{$template}[1] = 0;
        if ( open my $template_fh, '<', $template ) {
            while (<$template_fh>) {
                if (m{ \A \s* Include .+ account_suspensions.conf }x) {
                    $templates{$template}[1] = 1;
                }
            }
            close $template_fh;
        }
    }

    for my $template ( keys(%templates) ) {
        if ( !$templates{$template}[1] ) {
            print_warn("Custom templates: ");
            print_warning( $templates{$template}[0] . " is missing include for account_suspensions.conf!\n\t\\_ Use predefined \"WEBSERVER - Suspensions Template Update\"" );
        }
    }
}

sub check_for_local_makecpphp_template {
    return if cpanel_version_is(qw( >= 11.36.0.0 ));    # makecpphp has been removed from 11.36+

    my $makecpphp_local_profile = '/var/cpanel/easy/apache/profile/makecpphp.profile.yaml.local';

    if ( -e $makecpphp_local_profile ) {
        print_warn('makecpphp Local Profile: ');
        print_warning("exists at $makecpphp_local_profile !");
    }
}

sub check_for_custom_apache_includes {
    my $include_dir = '/usr/local/apache/conf/includes';

    return if !-d $include_dir;

    my @includes = qw(
      post_virtualhost_1.conf
      post_virtualhost_2.conf
      post_virtualhost_global.conf
      pre_main_1.conf
      pre_main_2.conf
      pre_main_global.conf
      pre_virtualhost_1.conf
      pre_virtualhost_2.conf
      pre_virtualhost_global.conf
    );

    my $custom_includes;
    for my $include (@includes) {
        if ( -s "${include_dir}/${include}" ) {
            if ( $include eq 'pre_virtualhost_global.conf' ) {
                my $md5 = timed_run( 0, 'md5sum', '/usr/local/apache/conf/includes/pre_virtualhost_global.conf' );
                next if ( $md5 && $md5 =~ m{ \A 1693b9075fa54ede224bfeb8ad42a182 \s }xms );
                $custom_includes .= " [$include]";
            }
            else {
                $custom_includes .= " [$include]";
            }
        }
    }

    if ($custom_includes) {
        print_warn('Apache Includes: ');
        print_warning($custom_includes);
    }
}

sub check_for_tomcatoptions {
    my $tomcat_options = '/var/cpanel/tomcat.options';
    if ( -f $tomcat_options and !-z $tomcat_options ) {
        print_warn('Tomcat options: ');
        print_warning("$tomcat_options exists");
    }
}

sub check_for_sneaky_htaccess {
    ## this is lazy checking. ideally we'd check HOMEMATCH from wwwacct.conf and go from there.
    ## but then, nothing guarantees the current HOMEMATCH has always been the same, either.
    my @dirs = qw( / /home/ /home2/ /home3/ /home4/ /home5/ /home6/ /home7/ /home8/ /home9/ );
    my $htaccess;

    for my $dir (@dirs) {
        if ( -f $dir . '.htaccess' and !-z $dir . '.htaccess' ) {
            $htaccess .= $dir . '.htaccess ';
        }
    }

    if ($htaccess) {
        print_warn('Sneaky .htaccess file(s) found: ');
        print_warning($htaccess);
    }
}

sub check_perl_sanity {
    my $usr_bin_perl       = '/usr/bin/perl';
    my $usr_local_bin_perl = '/usr/local/bin/perl';

    if ( !-e $usr_bin_perl ) {
        print_warn('perl: ');
        print_warning("$usr_bin_perl does not exist!");
    }

    if ( -l $usr_bin_perl and -l $usr_local_bin_perl ) {
        my $usr_bin_perl_link       = readlink $usr_bin_perl;
        my $usr_local_bin_perl_link = readlink $usr_local_bin_perl;
        if ( -l $usr_bin_perl_link and -l $usr_local_bin_perl_link ) {
            print_warn('perl: ');
            print_warning("$usr_bin_perl and $usr_local_bin_perl are both symlinks!");
        }
    }

    ## a symlink will test true for both -x AND -l
    if ( -x $usr_bin_perl and !-l $usr_bin_perl ) {
        if ( -x $usr_local_bin_perl and !-l $usr_local_bin_perl ) {
            print_warn('perl: ');
            print_warning("$usr_bin_perl and $usr_local_bin_perl are both binaries!");
        }
    }

    if ( -x $usr_bin_perl and !-l $usr_bin_perl ) {
        my $mode = ( stat($usr_bin_perl) )[2] & 07777;
        $mode = sprintf "%lo", $mode;
        if ( $mode != 755 ) {
            print_warn('Perl Permissions: ');
            print_warning("$usr_bin_perl is $mode");
        }
    }

    if ( -x $usr_local_bin_perl and !-l $usr_local_bin_perl ) {
        my $mode = ( stat($usr_local_bin_perl) )[2] & 07777;
        $mode = sprintf "%lo", $mode;
        if ( $mode != 755 ) {
            print_warn('Perl Permissions: ');
            print_warning("$usr_local_bin_perl is $mode");
        }
    }
}

sub check_for_non_default_permissions {
    local $OPT_TIMEOUT = $OPT_TIMEOUT ? $OPT_TIMEOUT : 10;    # This only applies to the recursive loop.

    # Example: '/path' => { mode => ['0755','0555',...], user => 'root', group => 'root', perms_help => 'Additional info if mode/user/group incorrect', attr_check => [ 'IMMUTABLE' ], attr_recursive => 1, attr_help => 'Additional info if immutable/append-only/etc', symlink => '/path', symlink_no_absolute => 1, check_missing => 1 },
    # Attributes are always checked, mode is only checked if specified.
    # User is always checked if mode is specified, which defaults to 'root'.
    # A '*' can be used to specify any user or group is allowed.
    # Only symlink ownership can be verified, not its mode.
    # attr_recursive only works on directories, default is 0 (do not recurse).
    # attr_check is optional, default is to check all of IMMUTABLE, APPEND-ONLY, UNDELETABLE.
    # symlink_no_absolute defines whether the absolute target path of a symlink will be computed before comparing. Default behavior is to resolve the absolute target path.  Enabling this option allows you to compare a symlink at face-value.
    # check_missing causes a missing object to be reported
    # tidyoff
    my %check = (
        '/'                                     => { mode => [ '0755', '0555' ], perms_help => '.ftpquota issues? see ticket 4429843', attr_help => 'This can break EA. See ticket 4929961' },
        '/bin/bash'                             => { mode => ['0755'] },
        '/bin/crontab'                          => { symlink => '/usr/local/cpanel/bin/jail_safe_crontab' },
        '/bin/gtar'                             => { symlink => 'tar', symlink_no_absolute => 1, perms_help => 'May prevent creating backups via cPanel UI if users can not use this.' },
        '/bin/gzip'                             => { mode => ['755'], perms_help => 'May prevent creating backups via cPanel UI if users can not use this.' },
        '/bin/ln'                               => { mode => [ '0755', '0555' ] },
        '/bin/passwd'                           => { symlink => '/usr/local/cpanel/bin/jail_safe_passwd' },
        '/bin/rpm'                              => { mode => [ '755',  '555' ],  perms_help => 'If users cannot execute /bin/rpm it will break Cron Jobs in x3 UI (CPANEL-1487)' },
        '/bin/rm'                               => { mode => [ '0755', '0555' ], perms_help => 'File Manager unable to delete files?  This may be why.' },
        '/bin/tar'                              => { mode => ['755'], perms_help => 'May prevent creating backups via cPanel UI if users can not use this.' },
        '/dev'                                  => { mode => ['0755'], perms_help => 'Breaks many things if non-root users can\'t access this.' },
        '/dev/log'                              => { mode => ['0666'], perms_help => 'CSF RESTRICT_SYSLOG can change this. See ticket 4875833. Non-root users may not be able to log to syslog, including user cron jobs to /var/log/cron.' },
        '/dev/null'                             => { mode => ['0666'], perms_help => 'Breaks many things if non-root users can\'t write to this.' },
        '/dev/random'                           => { mode => [ '0666', '0664', '0644', '0444' ], perms_help => 'Breaks many things if non-root users can\'t read this.' },
        '/dev/stderr'                           => { symlink => '/proc/self/fd/2', symlink_no_absolute => 1, check_missing => 1 },
        '/dev/stdin'                            => { symlink => '/proc/self/fd/0', symlink_no_absolute => 1, check_missing => 1 },
        '/dev/stdout'                           => { symlink => '/proc/self/fd/1', symlink_no_absolute => 1, check_missing => 1 },
        '/dev/urandom'                          => { mode => [ '0666', '0664', '0644', '0444' ], perms_help => 'Breaks many things if non-root users can\'t read this.' },
        '/etc'                                  => { mode => ['0755'] },
        '/etc/cpbackup.conf'                    => { mode => ['0644'] },
        '/etc/exim.conf'                        => { mode => ['0644'] },
        '/etc/group'                            => { mode => ['0644'] },
        '/etc/hosts'                            => { mode => ['0644'] },
        '/etc/localdomains'                     => { mode => ['0640'], group => 'mail', perms_help => 'Failing to properly create an email forwarder? See ticket 5234627.' },
        '/etc/nsswitch.conf'                    => { mode => ['0644'] },
        '/etc/passwd'                           => { mode => ['0644'] },
        '/etc/shadow'                           => { mode => [ '0600', '0400', '0200', '0000' ] },
        '/etc/stats.conf'                       => { mode => ['0644'] },
        '/home'                                 => { mode => [ '0755', '0711' ] },
        '/home1'                                => { mode => [ '0755', '0711' ] },
        '/home2'                                => { mode => [ '0755', '0711' ] },
        '/home3'                                => { mode => [ '0755', '0711' ] },
        '/home4'                                => { mode => [ '0755', '0711' ] },
        '/home5'                                => { mode => [ '0755', '0711' ] },
        '/opt'                                  => { mode => ['0755'] },
        '/proc'                                 => { mode => ['0555'] , perms_help => 'If users cannot read /proc/mounts it can break cPanel quota reporting.' },
        '/root/cpanel3-skel'                    => { mode => ['0755'] },
        '/sbin/ifconfig'                        => { mode => [ '0755', '0555' ] },
        '/tmp'                                  => { mode => ['1777'] },
        '/usr'                                  => { mode => ['0755'] },
        '/usr/bin'                              => { mode => [ '0755', '0711', '0555' ] },
        '/usr/bin/screen'                       => { mode => ['2755'], group => 'screen', perms_help => 'Screen doesn\'t work? Run "rpm --setugids screen && rpm --setperms screen" to fix.' },
        '/usr/local'                            => { mode => ['0755'] },
        '/usr/local/apache'                     => { mode => ['0755'], attr_recursive => 1 },
        '/usr/local/apache/conf'                => { mode => ['0755'] },
        '/usr/local/bin'                        => { mode => [ '0755', '0711', '0555' ] },
        '/usr/local/cpanel'                     => { mode => ['0711'] },
        '/usr/local/cpanel/base/3rdparty/phpMyAdmin/index.php'                          => { mode => ['0644'] },
        '/usr/local/cpanel/base/3rdparty/phpPgAdmin/index.php'                          => { mode => ['0644'] },
        '/usr/local/cpanel/base/3rdparty/roundcube/index.php'                           => { mode => ['0644'] },
        '/usr/local/cpanel/base/3rdparty/roundcube/plugins/cpanellogin/cpanellogin.php' => { mode => ['0644'] },
        '/usr/local/cpanel/base/3rdparty/squirrelmail/index.php'                        => { mode => ['0644'] },
        '/usr/local/cpanel/base/horde/index.php'                                        => { mode => ['0644'] },
        '/usr/local/cpanel/bin/cpwrap'          => { mode => ['0755'] },
        '/usr/local/cpanel/bin/sendmail'        => { mode => ['0755'] },
        '/usr/local/cpanel/cpanel.lisc'         => { mode => ['0644'] },
        '/usr/local/cpanel/cpsanitycheck.so'    => { mode => ['0754'] },
        '/usr/local/cpanel/php/cpanel.php'      => { mode => ['0644'] },
        '/usr/local/sbin'                       => { mode => [ '0755', '0711', '0555' ] },
        '/usr/sbin'                             => { mode => [ '0755', '0711', '0555' ] },
        '/usr/sbin/exim'                        => { mode => ['4755'] },
        '/usr/share'                            => { mode => ['0755'] },
        '/usr/share/zoneinfo'                   => { mode => ['0755'] },
        '/var'                                  => { mode => ['0755'] },
        '/var/cpanel'                           => { mode => [ '0755', '0711', '0555' ], attr_recursive => 1 },
        '/var/cpanel/backups'                   => { mode => [ '0755', '0750' ] },
        '/var/cpanel/backups/config'            => { mode => ['0644'] },
        '/var/cpanel/bandwidth.cache'           => { mode => ['0711'] },
        '/var/cpanel/cpanel.config'             => { mode => ['0644'] },
        '/var/cpanel/datastore'                 => { mode => ['0755'] },
        '/var/cpanel/domain_keys_private'       => { mode => ['0640'], group => 'wheel' },
        '/var/cpanel/features'                  => { mode => ['0755'] },
        '/var/cpanel/locale'                    => { mode => ['0755'] },
        '/var/cpanel/locale/themes'             => { mode => ['0755'] },
        '/var/cpanel/resellers'                 => { mode => ['0644'] },
        '/var/cpanel/userhomes'                 => { mode => [ '0755', '0711' ] },
        '/var/cpanel/userhomes/cpanelroundcube' => { mode => ['0711'], user => 'cpanelroundcube', group => 'cpanelroundcube' },
        '/var/lib'                              => { mode => ['0755'] },
        '/var/lib/mysql'                        => { mode => ['0751'], user => 'mysql', group => 'mysql' },
        '/var/lib/mysql/mysql.sock'             => { mode => ['0777'], user => 'mysql', group => 'mysql' },
        '/var/log'                              => { mode => [ '0755', '0751', '0711' ], perms_help => 'If non-root users cannot write to log files it can cause service failure' },
        '/var/log/exim_mainlog'                 => { mode => ['0640'], user => 'mailnull', group => 'mail' },
        '/var/log/exim_paniclog'                => { mode => ['0640'], user => 'mailnull', group => 'mail' },
        '/var/log/exim_rejectlog'               => { mode => ['0640'], user => 'mailnull', group => 'mail' },
    );
    # tidyon

    ## If EA4 is running we need to redefine some of the paths from %check as these paths have turned into symlinks.
    ## We also conditionally need to add the new paths that EA4 introduces.
    if ($EA4) {
        $check{'/etc/apache2'}                      = { mode    => ['0755'] };
        $check{'/etc/apache2/conf'}                 = { mode    => ['0755'] };
        $check{'/etc/apache2/conf.d'}               = { mode    => ['0755'] };
        $check{'/etc/apache2/conf.modules.d'}       = { mode    => ['0755'] };
        $check{'/etc/apache2/logs'}                 = { symlink => '/var/log/apache2', check_missing => 1 };
        $check{'/etc/apache2/logs/error_log'}       = { mode    => ['0644'], user => '*', perms_help => 'If users can\'t read error_log, cPanel Errors (Last 300) won\'t work.' };
        $check{'/etc/apache2/logs/domlogs'}         = { mode    => [ '0711', '0755' ], perms_help => 'If users can\'t access logs, stats won\'t process.  See ticket 5413079.' };
        $check{'/etc/apache2/run'}                  = { symlink => '../../var/run/apache2', symlink_no_absolute => 1, check_missing => 1 };
        $check{'/etc/cpanel'}                       = { mode    => [ '0755', '0751', '0711' ], perms_help => 'cPanel MultiPHP needs execute access to this directory.  See CPANEL-905.' };
        $check{'/etc/cpanel/ea4'}                   = { mode    => ['0755'], perms_help => 'cPanel MultiPHP needs read access to this directory.  See CPANEL-905.' };
        $check{'/usr/local/apache/bin/apachectl'}   = { symlink => '/usr/sbin/apachectl', check_missing => 1 };
        $check{'/usr/local/apache/bin/httpd'}       = { symlink => '/usr/sbin/httpd', check_missing => 1 };
        $check{'/usr/local/apache/bin/suexec'}      = { symlink => '/usr/sbin/suexec', check_missing => 1 };
        $check{'/usr/local/apache/conf/httpd.conf'} = { symlink => '/etc/apache2/conf/httpd.conf', check_missing => 1 };
        $check{'/usr/local/apache/conf/includes'}   = { symlink => '/etc/apache2/conf.d/includes', check_missing => 1 };
        $check{'/usr/local/apache/conf/mime.types'} = { symlink => '/etc/mime.types', check_missing => 1 };
        $check{'/usr/local/apache/conf/php.conf'}   = { symlink => '/etc/apache2/conf.d/php.conf', check_missing => 1 };
        $check{'/usr/local/apache/domlogs'}         = { symlink => '/etc/apache2/logs/domlogs', check_missing => 1 };
        $check{'/usr/local/apache/htdocs'}          = { symlink => '/var/www/html', check_missing => 1 };
        $check{'/usr/local/apache/logs'}            = { symlink => '/etc/apache2/logs', check_missing => 1 };
        $check{'/usr/local/apache/modules'}         = { symlink => '/etc/apache2/modules', check_missing => 1 };
        $check{'/usr/sbin/httpd'}                   = { mode    => ['0755'] };
        $check{'/var/log/apache2'}                  = { mode    => ['0711'] };
        $check{'/var/www/html'}                     = { mode    => ['0755'] };
        if ( defined( $HOSTINFO->{'hardware'} ) && $HOSTINFO->{'hardware'} eq 'i386' ) {
            $check{'/etc/apache2/modules'} = { symlink => '/usr/lib/apache2/modules', check_missing => 1 };
        }
        else {
            $check{'/etc/apache2/modules'} = { symlink => '/usr/lib64/apache2/modules', check_missing => 1 };
        }
    }
    else {
        $check{'/usr/local/apache/bin/httpd'}      = { mode => ['0755'] };
        $check{'/usr/local/apache/domlogs'}        = { mode => ['0711'], perms_help => 'If users can\'t access logs, stats won\'t process.  See ticket 5413079.' };
        $check{'/usr/local/apache/htdocs'}         = { mode => ['0755'] };
        $check{'/usr/local/apache/logs/error_log'} = { mode => ['0644'], user => '*', perms_help => 'If users can\'t read error_log, cPanel Errors (Last 300) won\'t work.' };
    }

    if ( -l '/var/tmp' ) {
        $check{'/var/tmp'} = { symlink => '/tmp' };
    }
    else {
        $check{'/var/tmp'} = { mode => ['1777'] };
    }

    my $wwwacctconf = '/etc/wwwacct.conf';
    if ( open my $wwwacctconf_fh, '<', $wwwacctconf ) {
        while (<$wwwacctconf_fh>) {
            if (m{ ^ HOMEDIR \s ([/\-_A-Za-z0-9]+) $ }x) {
                $check{$1} = { mode => [ '0755', '0711' ] };
                last;
            }
        }
        close $wwwacctconf_fh;
    }

    if ( version_compare( $OS_VERSION, qw( < 7 ) ) ) {
        $check{'/bin'}             = { mode => [ '0755', '0711', '0555' ] };
        $check{'/sbin'}            = { mode => [ '0755', '0711', '0555' ] };
        $check{'/usr/bin/crontab'} = { mode => [ '6755', '4755', '4711', '4555' ] };
        $check{'/usr/bin/passwd'}  = { mode => [ '6755', '4755', '4555', '4511' ] };
        $check{'/var/run'} = { mode => ['0755'], perms_help => 'Exim auth can fail if this is too restrictive. See ticket 7455551.' };
    }
    if ( version_compare( $OS_VERSION, qw( >= 7 ) ) ) {    # https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Migration_Planning_Guide/sect-Red_Hat_Enterprise_Linux-Migration_Planning_Guide-File_System_Layout.html
        $check{'/bin'}   = { symlink => '/usr/bin',   check_missing => 1 };
        $check{'/lib'}   = { symlink => '/usr/lib',   check_missing => 1 };
        $check{'/lib64'} = { symlink => '/usr/lib64', check_missing => 1 };
        $check{'/run'} = { mode => ['0755'], perms_help => 'Exim auth can fail if this is too restrictive. See ticket 7455551.' };
        $check{'/sbin'}     = { symlink => '/usr/sbin', check_missing => 1 };
        $check{'/var/lock'} = { symlink => '/run/lock', check_missing => 1 };
        $check{'/var/run'}  = { symlink => '/run',      check_missing => 1 };
    }
    if ( cpanel_version_is(qw( >= 11.57.0.0 )) ) {         # CPANEL-6180 results in these log files having the APPEND-ONLY attribute, so only check other attributes.
        $check{'/usr/local/cpanel/logs/cpdavd_error_log'}   = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/cphulkd.log'}        = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/cphulkd_errors.log'} = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/cpdavd_error_log'}   = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/dnsadmin_log'}       = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/error_log'}          = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/queueprocd.log'}     = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/spamd_error_log'}    = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/stats_log'}          = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
        $check{'/usr/local/cpanel/logs/tailwatchd_log'}     = { attr_check => [ 'IMMUTABLE', 'UNDELETABLE' ] };
    }
    if ( cpanel_version_is(qw( < 11.49.0.0 )) ) {
        $check{'/var/cpanel/userhomes/cpanelhorde'} = { mode => [ '0700', '0711' ], user => 'cpanelhorde', group => 'cpanelhorde', perms_help => 'might affect Horde attachments.  See ticket 6139315.' };
    }
    if ( cpanel_version_is(qw( < 11.48.2.1 )) ) {
        $check{'/etc/localdomains'} = { group => 'root' };
    }
    if ( ( cpanel_version_is(qw( >= 11.44.0.0 )) && cpanel_version_is(qw( < 11.44.0.8 )) ) || ( cpanel_version_is(qw( >= 11.42.0.0 )) && cpanel_version_is(qw( < 11.42.1.18 )) ) ) {
        $check{'/usr/local/cpanel/bin/sendmail'} = { mode => ['4755'], perms_help => 'CGIEmail wants suid /u/l/cpanel/bin/sendmail (FB-86561)' };
    }
    if ( cpanel_version_is(qw( <= 11.36.0.0 )) ) {
        $check{'/usr/local/cpanel/bin/cpwrap'} = { mode => ['4755'] };
    }
    if ( cpanel_version_is(qw( >= 11.29.0.0)) ) {
        $check{'/scripts'} = { symlink => '/usr/local/cpanel/scripts', check_missing => 1 };
    }
    if ( defined $CPCONF{'skipawstats'} && $CPCONF{'skipawstats'} == 0 ) {
        $check{'/usr/local/cpanel/3rdparty/bin/awstats.pl'} = { mode => ['0755'] };
    }
    if ( defined $CPCONF{'skipwebalizer'} && $CPCONF{'skipwebalizer'} == 0 ) {
        $check{'/usr/local/cpanel/3rdparty/bin/webalizer_lang/english'} = { mode => ['0755'], user => 'bin', group => 'bin' };
    }
    if ($IS_CLOUDLINUX) {
        if ( version_compare( $OS_VERSION, qw( >= 7 ) ) ) {
            $check{'/usr/bin/python'} = { symlink => '/usr/bin/python2.7', check_missing => 1, perms_help => 'If the Python binary is not executable by non-root users it can break CloudLinux functions in cPanel UI' };
            $check{'/usr/bin/python2.7'} = { mode => ['0755'], perms_help => 'If the Python binary is not executable by non-root users it can break CloudLinux functions in cPanel UI' };
        }
        else {
            $check{'/usr/bin/python'} = { mode => ['0755'], perms_help => 'If the Python binary is not executable by non-root users it can break CloudLinux functions in cPanel UI' };
        }
    }

    foreach my $backup_path ( $NEW_BACKUP_CONF->{BACKUPDIR}, $OLD_BACKUP_CONF->{BACKUPDIR} ) {
        if ( defined $backup_path ) {
            my @backup_path_parts = split( '/', $backup_path );

            # the first element will be an empty string. We don't want to check the permissions of /.
            shift @backup_path_parts;
            my $backup_path_parent;
            foreach my $part (@backup_path_parts) {
                $backup_path_parent .= '/' . $part;
                $check{$backup_path_parent} = { mode => [ '0755', '0751', '0711' ], perms_help => "All backup directories MUST be traversable (+x) by all users. See CPANEL-4336." };
            }
        }
    }

    for my $path ( sort keys %check ) {
        my ( $mode, $uid, $gid ) = ( lstat($path) )[ 2, 4, 5 ];    # _ can now be used in place of $path for -d, -e, -f, -l, etc...
        if ( exists $check{$path}->{check_missing} ) {
            my $symlink    = '';
            my $perms_help = '';
            if ( exists $check{$path}->{symlink} && !-l _ ) {
                $symlink = exists $check{$path}->{symlink} ? ' symlink to ' . $check{$path}->{symlink} : '';
            }
            if ( $symlink || !-e _ ) {
                $perms_help = exists $check{$path}->{perms_help} ? ' - ' . $check{$path}->{perms_help} : '';
                print_warn('Missing: ');
                print_warning( $path . $symlink . $perms_help );
            }
        }
        if ( -l _ ) {
            my $linktarget = readlink($path);
            if ( !exists $check{$path}{'symlink_no_absolute'} || $check{$path}{'symlink_no_absolute'} == 0 ) {
                if ( !( $linktarget =~ m{ \A / }x ) ) {    # If a symlink has a relative prefix, try to prepend the base path and convert to absolute
                    my @basepath = split( m{/}, $path );
                    my $fullpath = join( '/', @basepath[ 0 .. $#basepath - 1 ] ) . '/' . $linktarget;
                    $linktarget = defined( abs_path($fullpath) ) ? abs_path($fullpath) : $linktarget;
                }
                elsif ( $linktarget =~ m{ / .{1,2} / }x ) {    # If a symlink is relative, convert to absolute
                    $linktarget = defined( abs_path($linktarget) ) ? abs_path($linktarget) : $linktarget;
                }
            }
            if ( !exists $check{$path}{'symlink'} || $linktarget ne $check{$path}{'symlink'} ) {
                my $perms_help = exists $check{$path}->{perms_help} ? ' - ' . $check{$path}->{perms_help} : '';
                print_warn('Non-default symlink: ');
                print_warning( '[ ' . $path . ' -> ' . $linktarget . ' ] ( default -> ' . ( exists $check{$path}{'symlink'} ? $check{$path}{'symlink'} : 'no symlink' ) . ' )' . $perms_help );
            }
        }
        elsif ( -e _ ) {
            if ( exists $check{$path}->{mode} ) {
                $mode &= 07777;
                $mode = sprintf "%lo", $mode;
                my $user = getpwuid($uid);
                $user = $user || $uid;
                my $group = getgrgid($gid);
                $group = $group || $gid;
                my $checkuser  = defined( $check{$path}->{user} )   ? $check{$path}->{user}               : 'root';
                my $checkgroup = defined( $check{$path}->{group} )  ? $check{$path}->{group}              : '*';
                my $perms_help = exists $check{$path}->{perms_help} ? ' - ' . $check{$path}->{perms_help} : '';

                if ( !( $checkuser eq '*' || $user eq $checkuser ) || !( $checkgroup eq '*' || $group eq $checkgroup ) ) {
                    print_warn('Non-default Perms: ');
                    print_warning( $path . ' [owner ' . $user . ':' . $group . '] (default ' . $checkuser . ':' . $checkgroup . ')' . $perms_help );
                }
                my $default = 0;
                for my $checkmode ( @{ $check{$path}->{mode} } ) {
                    if ( $mode == $checkmode ) {
                        $default = 1;
                    }
                }
                if ( !$default == 1 ) {
                    print_warn('Non-default Perms: ');
                    print_warning( $path . ' [mode ' . sprintf( "%04d", $mode ) . '] (default ' . join( ' or ', @{ $check{$path}->{mode} } ) . ')' . $perms_help );
                }
            }
            my @attr_check   = exists $check{$path}->{attr_check}     ? @{ $check{$path}->{attr_check} }   : qw( APPEND-ONLY IMMUTABLE UNDELETABLE );
            my $attr_help    = exists $check{$path}->{attr_help}      ? ' - ' . $check{$path}->{attr_help} : '';
            my $is_recursive = exists $check{$path}->{attr_recursive} ? $check{$path}->{attr_recursive}    : 0;
            my $recursive_report_limit = 15;
            my %recursive_report_count_by_path;
            my $test_ref = sub {
                my $linktarget;
                if ($is_recursive) {
                    $linktarget = -l $_ ? readlink($_) : "";
                    return if exists $check{$_} && !exists $check{$_}->{attr_recursive};    # If we check a path directly then we don't need to check it in a recursive sweep.
                    return if exists $check{$linktarget};                                   # Don't check a link target that we've explicitly checked.
                    $recursive_report_count_by_path{$path} = 0 if !defined( $recursive_report_count_by_path{$path} );
                    return if $recursive_report_count_by_path{$path} >= $recursive_report_limit;
                }
                if ( ( -f $_ || -d _ ) && ( my %attr = get_attributes( $_, @attr_check ) ) ) {
                    my $attributes = join( ' & ', keys(%attr) );
                    my $linktext = $linktarget ? " -> " . $linktarget : "";
                    print_warn('Non-default Perms: ');
                    print_warning( $_ . $linktext . ' [' . $attributes . '] ' . $attr_help );
                    $recursive_report_count_by_path{$path}++;
                    if ( $recursive_report_count_by_path{$path} >= $recursive_report_limit ) {
                        print_warn('Non-default Perms: ');
                        print_warning( 'recursive reporting limit reached for ' . $path . ' -- there may be more files like this!' );
                    }
                }
            };
            if ($is_recursive) {
                eval {
                    local $SIG{'ALRM'} = sub {
                        print_warn('Non-default Perms: ');
                        print_warning( 'recursive check of ' . $path . ' timed out after ' . $OPT_TIMEOUT . ' seconds.' );
                        die;
                    };
                    alarm $OPT_TIMEOUT;
                    find( { wanted => $test_ref, no_chdir => 1 }, $path );
                    alarm 0;
                };
            }
            else {
                local $_ = $path;
                &$test_ref();
            }
        }
    }
}

sub check_for_non_default_file_capabilities {

    # Check for at least these capabilities, more is OK
    # Example: '/path' => { cap => ['cap_setgid','cap_setuid+ep'], help => 'Some help text' },
    # tidyoff
    my %check = (
    );
    # tidyon

    if ( $EA4 && !$IS_CLOUDLINUX ) {
        $check{'/usr/sbin/suexec'} = { cap => [ 'cap_setgid', 'cap_setuid', '+ep' ], help => 'Will break cpanel/webmail redirects and other suexec usage, \'yum reinstall ea-apache24\' to fix' };
    }

    for my $path ( sort keys %check ) {
        next unless -e $path;
        my @result = get_fcap($path);
        next unless scalar @result;
        my @missing;
        foreach my $cap ( @{ $check{$path}->{cap} } ) {
            push @missing, $cap unless grep( /^\Q${cap}\E$/, @result );
        }
        if ( scalar @missing ) {
            my $help = exists $check{$path}->{help} ? ' - ' . $check{$path}->{help} : '';
            print_warn('Non-default capabilities: ');
            print_warning( $path . ' is missing ' . join( ',', @missing ) . $help );
        }
    }
}

sub get_attributes {

    # @want is optional, not specifying anything returns all checked attributes
    my ( $path, @want ) = @_;
    open( my $fh, '<', $path ) or return;
    my %attributes = (
        'APPEND-ONLY' => 0x00000020,    # FS_APPEND_FL in linux/fs.h
        'IMMUTABLE'   => 0x00000010,    # FS_IMMUTABLE_FL in linux/fs.h
        'UNDELETABLE' => 0x00000002,    # FS_UNRM_FL in linux/fs.h
    );
    my $FS_IOC_GETFLAGS = 0x80086601;    # Tested on CentOS 6.7 and 7.2 using: strace -e trace=ioctl -e raw=ioctl lsattr -d /
    my $flags = pack 'i', 0;
    return unless defined ioctl( $fh, $FS_IOC_GETFLAGS, $flags );
    close $fh;
    $flags = unpack 'i', $flags;
    @want = keys(%attributes) if !scalar @want;
    my %result;

    foreach my $attr (@want) {
        next unless exists $attributes{$attr};
        $result{$attr} = 1 if $flags & $attributes{$attr};
    }
    return %result;
}

sub get_fcap {
    my ($path) = @_;
    my $getcap = '/usr/sbin/getcap';
    return unless -x $getcap;
    return unless -e $path;
    my $output = timed_run( 0, $getcap, $path );
    my @result;
    if ( $output =~ m/^$path = ([^+]*)(\+.*)?$/ ) {
        @result = split( /,/, $1 );
        push @result, $2 if defined $2;
    }
    @result = ('none') unless scalar @result;
    return @result;
}

sub check_for_non_default_sysctl {
    my %check = (    # 'sysctl_key' => [ ['default1', 'default2', ...], 'Additional info' ]
        'kernel.user_ptrace'      => [ ['1'], ' - Disabling this is known to break remote logins from WHM Transfer Tool - see FB-167393' ],
        'net.ipv4.tcp_tw_recycle' => [ ['0'], ' - This should generally never be enabled. Clients behind NAT or Proxy can have problems connecting to this server.' ],
        'net.ipv4.tcp_tw_reuse'   => [ ['0'], ' - This should generally never be enabled. Clients behind NAT or Proxy can have problems connecting to this server.' ],
        'vm.overcommit_memory' => [ [ '0', '1' ], ' - Seeing "Out of memory" but there is free memory and no limits?  This might be why.' ],
    );

    for my $key ( sort keys %check ) {
        if ( exists $SYSCTL->{$key} ) {
            my $default = 0;
            for my $checksysctl ( @{ $check{$key}[0] } ) {
                if ( $SYSCTL->{$key} eq $checksysctl ) {
                    $default = 1;
                }
            }
            if ( !$default == 1 ) {
                print_warn('Non-default sysctl: ');
                print_warning( $key . ' = ' . $SYSCTL->{$key} . ' (default: ' . join( ' or ', @{ $check{$key}[0] } ) . ')' . $check{$key}[1] );
            }
        }
    }
}

sub check_for_stale_lockfiles {
    my %check = (    # '/path' => [ 'type', 'Additional info' ]; # type is pid, fcntl, touch, etc., for future use.
        '/etc/digestshadow.lock' => [ 'fcntl', 'Can prevent modifying system digestshadow file, check if active with lsof and MOVE ONLY IF STALE.' ],
        '/etc/group.lock'        => [ 'fcntl', 'Can prevent modifying system group file, check if active with lsof and MOVE ONLY IF STALE.' ],
        '/etc/gshadow.lock'      => [ 'fcntl', 'Can prevent modifying system gshadow file, check if active with lsof and MOVE ONLY IF STALE.' ],
        '/etc/gtmp'              => [ 'touch', 'Can prevent modifying system group file, check if active with lsof and MOVE ONLY IF STALE.' ],
        '/etc/passwd.lock'       => [ 'fcntl', 'Can prevent modifying system passwd file, check if active with lsof and MOVE ONLY IF STALE.' ],
        '/etc/ptmp'              => [ 'touch', 'Can prevent modifying system passwd file, check if active with lsof and MOVE ONLY IF STALE. See ticket 5315853.' ],
        '/etc/shadow.lock'       => [ 'fcntl', 'Can prevent modifying system shadow file, check if active with lsof and MOVE ONLY IF STALE.' ]
    );

    for my $resource ( sort keys %check ) {
        if ( -e $resource ) {
            print_warn('Lockfile exists: ');
            print_warning( $resource . ' (' . $check{$resource}[1] . ')' );
        }
    }
}

sub check_var_cpanel_users_files_ownership {
    my $var_cpanel_users = '/var/cpanel/users';
    return if !-d $var_cpanel_users;
    return unless opendir( my $dir_fh, $var_cpanel_users );
    my @files = grep { !m/^(?:\.\.?|root|system|nobody)$/ } readdir $dir_fh;
    closedir $dir_fh;

    my $group_root_files;
    for my $file (@files) {
        next if ( $file !~ /^[a-z0-9]+$/ );
        next if ( $file =~ /^cp[0-9]{7,8}[a-z]{6}$/ );    # ticket system creates temporary user in cp12345678abcdef format, ignore these
        my $gid = ( stat( '/var/cpanel/users/' . $file ) )[5];
        if ( $gid == 0 ) {
            $group_root_files .= " $file";
        }
    }

    if ($group_root_files) {
        print_warn('/v/c/users file(s) owned by group "root": ');
        print_warning($group_root_files);
    }
}

sub check_root_suspended {
    if ( -e '/var/cpanel/suspended/root' ) {
        print_warn('root suspended: ');
        print_warning('the root account is suspended! Unsuspend it to avoid problems.');
    }
}

sub check_limitsconf {
    my @limitsconf;

    if ( open my $limitsconf_fh, '<', '/etc/security/limits.conf' ) {
        while (<$limitsconf_fh>) {
            push @limitsconf, $_;
        }
        close $limitsconf_fh;
    }

    @limitsconf = grep { !/^(\s+|#)/ } @limitsconf;

    if (@limitsconf) {
        print_warn('/etc/security/limits.conf: ');
        print_warning('customizations found. DON\'T move/alter! Seeing "Unable to set uids"? See CronUnableToSetUID article, FB-76597.');
    }
}

sub check_disk_space {
    my @df = split /\n/, timed_run( 0, 'df' );
    for my $line (@df) {
        if ( $line =~ m{ (9[8-9]|100)% \s+ (.*) }xms ) {
            my ( $usage, $partition ) = ( $1, $2 );
            unless ( $line =~ m{ /virtfs | /(dev|proc) \z }xms ) {
                print_warn('Disk space: ');
                print_warning("${usage}% usage on $partition");
            }
        }
    }
}

sub check_disk_inodes {
    my @df_i = split /\n/, timed_run( 0, 'df', '-i' );
    for my $line (@df_i) {
        if ( $line =~ m{ (9[8-9]|100)% \s+ (.*) }xms ) {
            my ( $usage, $partition ) = ( $1, $2 );
            unless ( $line =~ m{ /virtfs | /(dev|proc) \z }xms ) {
                print_warn('Disk inodes: ');
                print_warning("${usage}% inode usage on $partition");
            }
        }
    }
}

sub check_for_hooks_in_scripts_directory {
    if ( -f '/usr/local/cpanel/Cpanel/CustomEventHandler.pm' ) {
        print_warn('Hooks: ');
        print_warning('/usr/local/cpanel/Cpanel/CustomEventHandler.pm exists!');
    }

    # default CloudLinux, cPGs hooks that can be ignored
    my %hooks_ignore = qw(
      16d94b5426681a977e2beedd0ad871e9  /scripts/posteasyapache
      e5e13640299ec439fb4c7f79a054e42b  /scripts/posteasyapache
      4988be925a6f50ec505618a7cec702e2  /scripts/postkillacct
      28620050548a2e4b500ab7426aaa0df5  /scripts/postmodifyacct
      42a624c843f34085f1532b0b4e17fe8c  /scripts/postmodifyacct
      67cefa439c7ea3b1b7643ec739c60006  /scripts/postmodifyacct
      423370856f0be1b80f39d28043d7d4f8  /scripts/postrestoreacct
      05b7f8b4f2c83f033d124479a1c3eca0  /scripts/postupcp
      22cf7db1c069fd9672cd9dad3a3d371d  /scripts/postupcp
      50bfcdbca45dc5813b5b354ceb24d977  /scripts/postupcp
      57f8ea2d494e299827cc365c86a357ac  /scripts/postupcp
      6db9b6bfb975adbe908300cc802774a8  /scripts/postupcp
      843f9a04ceed5d03dc34616b371abf06  /scripts/postupcp
      941772daaa48999f1d5ae5fe2f881e36  /scripts/postupcp
      e464adf0531fea2af4fe57361d9a43fb  /scripts/postupcp
      03a0dc919c892bde254c52cefe4d0673  /scripts/postwwwacct
      2401d6260dac6215596be1652b394200  /scripts/postwwwacct
      677da3bdd8fbd16d4b8917a9fe0f6f89  /scripts/postwwwacct
      9de3100a4f39d98ae49449350af8928a  /scripts/postwwwacct
      a4df04a6440073fe40363cfd241b1fe7  /scripts/postwwwacct
      d296b6bc92e8a60424c6e017219ddaf6  /scripts/postwwwacct
      44caf075fc0f9847ede43de5dd563edc  /scripts/prekillacct
      46fee9faf2d5f83cbcda17ce0178a465  /scripts/prekillacct
      677da3bdd8fbd16d4b8917a9fe0f6f89  /scripts/prekillacct
      86f9b53c81a8f2fd77a8626ddd3b2c71  /scripts/prekillacct
      88f73e4fd1384479e4069a68ae4e1489  /scripts/prekillacct
    );

    my @hooks;
    if ( -d '/scripts' ) {
        opendir( my $scripts_fh, '/scripts' );
        @hooks = grep { /^(pre|post)/ } readdir $scripts_fh;
        closedir $scripts_fh;
    }

    # these exist by default
    @hooks = grep { !/postsuexecinstall/ && !/post_sync_cleanup/ } @hooks;

    # CloudLinux stuff
    @hooks = grep { !/postwwwacct\.l\.v\.e-manager\.bak/ } @hooks;

    my $hooks_output;
    if (@hooks) {
        for my $hook (@hooks) {
            $hook = '/scripts/' . $hook;
            chomp( my $checksum = timed_run( 0, 'md5sum', $hook ) );
            $checksum =~ s/\s.*//g;
            next if exists $hooks_ignore{$checksum};

            if ( !-z $hook ) {
                $hooks_output .= " $hook ";
            }
        }
    }

    if ($hooks_output) {
        print_warn('Hooks: ');
        print_warning($hooks_output);
    }
}

sub check_for_huge_logs {

    # Default size is 2_100_000_000, with no additional help text.
    # Example: '/path/to/file' => { size => 1_000_000_000, help => 'If file is too hyooge, THERE IS MUCH FAIL' }
    my %logs = (
        '/usr/local/apache/logs/access_log'       => {},
        '/usr/local/apache/logs/error_log'        => {},
        '/usr/local/apache/logs/mod_jk.log'       => {},
        '/usr/local/apache/logs/modsec_audit.log' => {},
        '/usr/local/apache/logs/modsec_debug.log' => {},
        '/usr/local/apache/logs/suexec_log'       => {},
        '/usr/local/apache/logs/suphp_log'        => {},
        '/var/cpanel/secdatadir/ip.pag'           => { help => 'Apache using a lot of CPU for no good reason? Try moving aside and restarting Apache. See EA-4092.' },
        '/var/named/data/named.run'               => {},
    );
    for my $log ( keys(%logs) ) {
        if ( -e $log ) {
            my $size       = ( stat($log) )[7];
            my $check_size = exists( $logs{$log}->{size} ) ? $logs{$log}->{size} : 2_100_000_000;
            my $help       = exists( $logs{$log}->{help} ) ? ' - ' . $logs{$log}->{help} : '';
            if ( $size > $check_size ) {
                $size = sprintf( "%0.2fGB", $size / 1073741824 );
                print_warn('M-M-M-MONSTER LOG!: ');
                print_warning( $log . ' (' . $size . ')' . $help );
            }
        }
    }
}

sub check_easy_skip_cpanelsync {
    if ( -e '/var/cpanel/easy_skip_cpanelsync' ) {
        print_warn('Touchfile: ');
        print_warning('/var/cpanel/easy_skip_cpanelsync exists! ');
    }
}

sub check_pkgacct_override {
    if ( -d '/var/cpanel/lib/Whostmgr' ) {
        print_warn('pkgacct override: ');
        print_warning(' /var/cpanel/lib/Whostmgr exists, override may exist');
    }
}

sub check_for_gdm {
    my $gdm = 0;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A root (?:.*) gdm }xms ) {
            $gdm = 1;
            last;
        }
    }

    if ( $gdm == 1 ) {
        print_warn('gdm Process: ');
        print_warning('is running');
    }
}

sub check_for_redhat_firewall {
    my $iptables = timed_run( 0, 'iptables', '-L', 'RH-Firewall-1-INPUT' );

    if ($iptables) {
        print_warn('Default Redhat Firewall Check: ');
        print_warning('RH-Firewall-1-INPUT table exists. /scripts/configure_rh_firewall_for_cpanel to open ports.');
    }
}

sub check_easyapache {
    my $ea_is_running_file       = '/usr/local/apache/AN_EASYAPACHE_BUILD_IS_CURRENTLY_RUNNING';
    my $ea_in_process_list       = 0;
    my $apache_update_no_restart = '/var/cpanel/mgmt_queue/apache_update_no_restart';
    my $ea_is_running            = 0;

    if ( -e $ea_is_running_file ) {
        for my $process (@PROCESS_LIST) {
            if ( $process =~ m{ \A root (?:.*) easyapache }xms ) {
                $ea_in_process_list = 1;
                last;
            }
            else {
                $ea_in_process_list = 0;
            }
        }
        if ( $ea_in_process_list == 0 ) {
            print_warn('EasyApache: ');
            print_warning("$ea_is_running_file exists, but 'easyapache' not found in process list");
        }
        else {
            $ea_is_running = 1;
            print_warn('EasyApache: ');
            print_warning('is running');
        }
    }

    if ( -e $apache_update_no_restart and $ea_is_running == 0 ) {
        print_warn('EasyApache: ');
        print_warning("$apache_update_no_restart exists! This will prevent EA from completing successfully.");
    }
}

sub check_for_easyapache_hooks {
    my $hooks;

    my @hooks = qw( /scripts/before_apache_make
      /scripts/after_apache_make_install
      /scripts/before_httpd_restart_tests
      /scripts/after_httpd_restart_tests
    );

    # default CloudLinux hooks that can be ignored
    my %hooks_ignore = qw(
      24214790021e1df53a0a6e3741ca74c3  /scripts/before_apache_make
      2af1cea5d3eea8d837b719131ec6d67e  /scripts/before_apache_make
      407df66f28c8822cd4f51fe56160f74e  /scripts/before_apache_make
      41ec2d3f35d8cd7cb01b60485fb3bdbb  /scripts/before_apache_make
    );

    for my $hook (@hooks) {
        if ( -f $hook and !-z $hook ) {
            chomp( my $checksum = timed_run( 0, 'md5sum', $hook ) );
            $checksum =~ s/\s.*//g;
            next if exists $hooks_ignore{$checksum};
            $hooks .= " $hook";
        }
    }

    if ($hooks) {
        print_warn('EA hooks: ');
        print_warning($hooks);
    }
}

sub check_for_home_noexec {
    my @mount = split /\n/, timed_run( 0, 'mount' );

    for my $mount (@mount) {
        if ( $mount =~ m{ \s on \s (/home([^\s]?)) \s (:?.*) noexec }xms ) {
            my $noexec_partition = $1;
            print_warn('mounted noexec: ');
            print_warning($noexec_partition);
        }
    }
}

## compare external IP addr with local IP addrs, OR
## check if only internal IP addrs are bound to server (this is not as reliable,
## as NAT can still be used with external IP addrs of course)
sub check_for_unsupported_nat {
    my @external_ipaddrs;
    return if -e '/var/cpanel/cpnat';

    if ( defined($EXTERNAL_IP_ADDRESS) ) {
        if ( !grep { /$EXTERNAL_IP_ADDRESS/ } @LOCAL_IPADDRS_LIST ) {
            print_warn('NAT: ');
            print_warning("external IP address $EXTERNAL_IP_ADDRESS is not bound to server");
        }
    }
    else {
        for my $ipaddr (@LOCAL_IPADDRS_LIST) {

            # Matches any local IP (127.0.0.0/8) or RFC-1918 IP (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
            if ( $ipaddr !~ /(?:10\.|127\.|172\.(?:1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)/ ) {
                push @external_ipaddrs, $ipaddr;
            }
        }
        if ( !@external_ipaddrs ) {
            print_warn('NAT: ');
            print_warning('no external IP addresses detected');
        }
    }
}

sub check_for_oracle_linux {
    my $centos_5_oracle_release_file = '/etc/enterprise-release';
    my $centos_6_oracle_release_file = '/etc/oracle-release';

    if ( -f $centos_5_oracle_release_file ) {
        print_warn('Oracle Linux: ');
        print_warning("$centos_5_oracle_release_file detected!");
    }
    elsif ( -f $centos_6_oracle_release_file ) {
        print_warn('Oracle Linux: ');
        print_warning("$centos_6_oracle_release_file detected!");
    }
}

sub check_for_usr_local_cpanel_hooks {
    my $hooks;
    my $dir = '/usr/local/cpanel/hooks';
    find( \&find_usr_local_cpanel_hooks, $dir );

    # default CloudLinux hooks that can be ignored
    my %hooks_ignore = qw(
      677da3bdd8fbd16d4b8917a9fe0f6f89    /usr/local/cpanel/hooks/addondomain/addaddondomain
      677da3bdd8fbd16d4b8917a9fe0f6f89    /usr/local/cpanel/hooks/addondomain/deladdondomain
      677da3bdd8fbd16d4b8917a9fe0f6f89    /usr/local/cpanel/hooks/subdomain/addsubdomain
      677da3bdd8fbd16d4b8917a9fe0f6f89    /usr/local/cpanel/hooks/subdomain/delsubdomain
      289b2b4c8b5293103def4557d3538060    /usr/local/cpanel/hooks/mysql/adduser
      289b2b4c8b5293103def4557d3538060    /usr/local/cpanel/hooks/mysql/deluser
    );

    if (@USR_LOCAL_CPANEL_HOOKS) {
        for my $hook (@USR_LOCAL_CPANEL_HOOKS) {
            my $tmp_hook = '/usr/local/cpanel/hooks/' . $hook;
            if ( -f $tmp_hook and !-z $tmp_hook ) {
                chomp( my $checksum = timed_run( 0, 'md5sum', $tmp_hook ) );
                $checksum =~ s/\s.*//g;
                next if exists $hooks_ignore{$checksum};
                $hooks .= "$hook ";
            }
        }
    }

    if ($hooks) {
        print_warn("$dir: ");
        print_warning($hooks);
    }
}

sub find_usr_local_cpanel_hooks {
    my $file = $File::Find::name;
    if ( -f $file and $file !~ m{ ( README | \.example ) \z }xms ) {
        $file =~ s#/usr/local/cpanel/hooks/##;
        push @USR_LOCAL_CPANEL_HOOKS, $file;
    }
}

sub check_for_sql_safe_mode {
    if ( grep { m# \A (?:[ \t]+)? sql\.safe_mode \s* = \s* on #ixms } @PHPINI ) {
        print_warn('/usr/local/lib/php.ini: ');
        print_warning('sql.safe_mode is enabled! This may break PHP SQL authentication.');
    }
}

sub get_mysql_datadir {
    my $datadir = '/var/lib/mysql/';
    if ( $MYSQL_CONF->{'LINES'} && $MYSQL_CONF->{'mysqld'}{'datadir'} ) {
        $datadir = $MYSQL_CONF->{'mysqld'}{'datadir'}[1];
        if ( $datadir !~ m{ / \z }xms ) {
            $datadir .= '/';
        }
    }
    return $datadir;
}

sub check_mysqld_warnings_errors {
    foreach my $mysql_err ( grep ( m{\[(?:err)}i, split( /\n/, timed_run_trap_stderr( 0, 'mysqld', '-u', 'mysql', '--help' ) ) ) ) {
        if ( $mysql_err =~ m/open_files_limit=/ ) {
            print_warn('MySQL config missing newline [see FB-64008]: ');
            print_warning($mysql_err);
        }
        else {
            print_warn('MySQL config errors: ');
            print_warning($mysql_err);
        }
    }
}

sub check_for_domain_forwarding {
    my $domainfwdip = '/var/cpanel/domainfwdip';

    if ( -f $domainfwdip and !-z $domainfwdip ) {
        print_warn('Domain Forwarding: ');
        print_warning("cat $domainfwdip to see what is being forwarded!");
    }
}

sub check_for_empty_apache_templates {
    return unless defined $APACHE_VERSION;
    my $apache2_template_dir = '/var/cpanel/templates/apache2';
    if ( version_compare( $APACHE_VERSION, qw( >= 2.4.0 ) ) ) {
        $apache2_template_dir = '/var/cpanel/templates/apache2_4';
    }

    my @dir_contents;
    my $empty_templates;

    if ( -d $apache2_template_dir ) {
        opendir( my $dir_fh, $apache2_template_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if ( !@dir_contents ) {
        print_warn('Apache templates: ');
        print_warning("none found in $apache2_template_dir !");
    }
    else {
        for my $template (@dir_contents) {
            if ( -z "$apache2_template_dir/$template" ) {
                $empty_templates .= "$template ";
            }
        }
    }

    if ($empty_templates) {
        print_warn("Empty Apache templates in $apache2_template_dir (this can affect the ability to remove domains): ");
        print_warning("$empty_templates");
    }
}

sub check_for_empty_postgres_config {
    my $postgres_config = '/var/lib/pgsql/data/pg_hba.conf';
    if ( -f $postgres_config and -z $postgres_config ) {
        print_warn('Postgres config: ');
        print_warning("$postgres_config is empty (install via WHM >> Postgres Config)");
    }
}

sub check_for_empty_easyapache_profiles {
    return if $EA4;
    my $templates;
    my $dir = '/var/cpanel/easy/apache/profile';
    return unless -d $dir;
    find( \&find_easyapache_templates, $dir );

    if (@EASYAPACHE_TEMPLATES) {
        for my $template (@EASYAPACHE_TEMPLATES) {
            $templates .= "$template ";
        }

        print_warn("Empty template(s) in $dir: ");
        print_warning($templates);
    }
}

sub find_easyapache_templates {
    my $file = $File::Find::name;
    if ( -f $file and -z $file ) {
        $file =~ s#/var/cpanel/easy/apache/profile/##g;
        push @EASYAPACHE_TEMPLATES, $file;
    }
}

sub check_for_missing_timezone_from_phpini {
    my $timezone;

    for my $line (@PHPINI) {
        if ( $line =~ m{ \A date\.timezone (?:\s+)? = (?:\s+)? (?:["'])? ([^/"']+) / ([^/"']+) (?:["'])? (?:\s+)? \z }xms ) {
            $timezone = $1 . '/' . $2;
            last;
        }
    }

    if ($timezone) {
        my ( $tz1, $tz2 ) = split /\//, $timezone;
        my $path = '/usr/share/zoneinfo/' . $tz1 . '/' . $tz2;

        if ( !-f $path ) {
            print_warn("date.timezone from /usr/local/lib/php.ini: ");
            print_warning("$path not found!");
        }
    }
}

sub check_for_proc_mdstat_recovery {
    my $mdstat = '/proc/mdstat';

    my $recovery = 0;

    if ( open my $mdstat_fh, '<', $mdstat ) {
        while (<$mdstat_fh>) {
            if (/recovery/) {
                $recovery = 1;
                last;
            }
        }
        close $mdstat_fh;
    }

    if ( $recovery == 1 ) {
        print_warn('Software RAID recovery: ');
        print_warning("cat $mdstat to check the status");
    }
}

sub check_usr_local_cpanel_path_for_symlinks {
    my @dirs = qw(  /usr
      /usr/local
      /usr/local/cpanel
    );

    for my $dir (@dirs) {
        if ( -l $dir ) {
            print_warn('Directory is a symlink: ');
            print_warning("$dir (this can cause Internal Server Errors for redirects like /cpanel, etc)");
        }
    }
}

sub populate_mysql_rpm_versions_array {
    return if !@RPM_LIST;

    my @tmp = grep { /^MySQL(?:55)?-(server|shared|devel|client|test|embedded)-(.*)$/ } @RPM_LIST;
    for my $rpm (@tmp) {
        $rpm =~ s/.*-(server|shared|devel|client|test|embedded)-//g;
        push @MYSQL_RPM_VERSIONS, $rpm;
    }
}

sub check_for_mysql_4 {
    return if !@MYSQL_RPM_VERSIONS;

    my $mysql_4 = 0;

    for my $rpm (@MYSQL_RPM_VERSIONS) {
        if ( $rpm =~ m{ \A 4 }xms ) {
            $mysql_4 = 1;
            last;
        }
    }

    if ( $mysql_4 == 1 ) {
        print_warn('MySQL 4.x RPM: ');
        print_warning('found! This can interfere with cPanel updates');
    }
}

sub check_for_additional_rpms {
    return if !@RPM_LIST;

    my @additional_rpms = grep { /^(php-|kde-|psa-|clamav|clamd|rrdtool-)|(http|apache|pear|sendmail)/ } @RPM_LIST;
    @additional_rpms = grep { !/httpd-tools|cpanel-|alt-php|apache-tomcat-apis|^ea-/ } @additional_rpms;
    if (@additional_rpms) {
        print "\n";
        print_magenta('This is informational only. Unless these rpms directly relate to an issue, they can be ignored:');
        @additional_rpms = sort @additional_rpms;
        for my $rpm (@additional_rpms) {
            print_start('Additional RPM: ');
            print_warning($rpm);
        }
    }
}

sub check_mysql_rpm_mismatch {
    return if !@RPM_LIST;

    my $first_rpm = pop @MYSQL_RPM_VERSIONS;
    for ( 1 .. scalar @MYSQL_RPM_VERSIONS ) {
        my $next_rpm = pop @MYSQL_RPM_VERSIONS;
        if ( $first_rpm ne $next_rpm ) {
            print_warn('MySQL RPMs: ');
            print_warning('version mismatch!');
            last;
        }
    }
}

sub check_php_libmysqlclient_mismatch {
    return if !@RPM_LIST;

    my ( @php4_ldd,                    @php5_ldd );
    my ( $php4_libmysqlclient_version, $php5_libmysqlclient_version );

    my $php4_binary = '/usr/local/php4/bin/php';
    my $php5_binary = '/usr/bin/php';

    my $php4_mismatch = 0;
    my $php5_mismatch = 0;

    my $mysql_shared_rpm_version_orig;
    my $mysql_shared_rpm_version;

    ## Get the MySQL-shared rpm major and minor version.
    for my $rpm (@RPM_LIST) {
        if ( $rpm =~ /MySQL-shared-(\d)\.(\d)/ ) {
            $mysql_shared_rpm_version_orig = $rpm;
            $mysql_shared_rpm_version      = $1 . $2;
            last;
        }
        elsif ( $rpm =~ /^MySQL(\d\d)-shared/ ) {
            $mysql_shared_rpm_version_orig = $rpm;
            $mysql_shared_rpm_version      = $1;
            last;
        }
    }

    return if !$mysql_shared_rpm_version;

    ## Run ldd against whichever major php version is active
    if ( open my $phpconfyaml_fh, '<', '/usr/local/apache/conf/php.conf.yaml' ) {
        while ( my $line = <$phpconfyaml_fh> ) {
            if ( $line =~ m{ \A php4: \s (.*) }xms ) {
                if ( $1 ne 'none' ) {
                    @php4_ldd = split /\n/, timed_run( 0, 'ldd', $php4_binary );
                }
            }
            elsif ( $line =~ m{ \A php5: \s (.*) }xms ) {
                if ( $1 ne 'none' ) {
                    @php5_ldd = split /\n/, timed_run( 0, 'ldd', $php5_binary );
                }
            }
        }
        close $phpconfyaml_fh;
    }

    ## Get the linked libmysqlclient version
    if (@php4_ldd) {
        for my $libs (@php4_ldd) {
            if ( $libs =~ m{ \A \s+ libmysqlclient\.so\.(\d+) \s => \s (?:\S+) \s (?:\S+) \z }xms ) {
                $php4_libmysqlclient_version = $1;
                last;
            }
        }
    }

    if (@php5_ldd) {
        for my $libs (@php5_ldd) {
            if ( $libs =~ m{ \A \s+ libmysqlclient\.so\.(\d+) \s => \s (?:\S+) \s (?:\S+) \z }xms ) {
                $php5_libmysqlclient_version = $1;
                last;
            }
        }
    }

    ## Compare the linked libmysqlclient lib with the MySQL-shared rpm version
    ##
    ## libmysqlclient.so.18 = MySQL-shared 5.6
    ## libmysqlclient.so.18 = MySQL-shared 5.5
    ## libmysqlclient.so.16 = MySQL-shared 5.1
    ## libmysqlclient.so.15 = MySQL-shared 5.0

    if ($php4_libmysqlclient_version) {
        if ( $php4_libmysqlclient_version == 18 and !( $mysql_shared_rpm_version == 56 or $mysql_shared_rpm_version == 55 ) ) {
            $php4_mismatch = 1;
        }
        elsif ( $php4_libmysqlclient_version == 16 and $mysql_shared_rpm_version != 51 ) {
            $php4_mismatch = 1;
        }
        elsif ( $php4_libmysqlclient_version == 15 and $mysql_shared_rpm_version != 50 ) {
            $php4_mismatch = 1;
        }

        if ( $php4_mismatch == 1 ) {
            print_warn('PHP/libmysqlclient mismatch: ');
            print_warning("$php4_binary linked against libmysqlclient.so.$php4_libmysqlclient_version, but MySQL-shared rpm is $mysql_shared_rpm_version_orig");
        }
    }

    if ($php5_libmysqlclient_version) {
        if ( $php5_libmysqlclient_version == 18 and !( $mysql_shared_rpm_version == 56 or $mysql_shared_rpm_version == 55 ) ) {
            $php5_mismatch = 1;
        }
        elsif ( $php5_libmysqlclient_version == 16 and $mysql_shared_rpm_version != 51 ) {
            $php5_mismatch = 1;
        }
        elsif ( $php5_libmysqlclient_version == 15 and $mysql_shared_rpm_version != 50 ) {
            $php5_mismatch = 1;
        }

        if ( $php5_mismatch == 1 ) {
            print_warn('PHP/libmysqlclient mismatch: ');
            print_warning("$php5_binary linked against libmysqlclient.so.$php5_libmysqlclient_version, but MySQL-shared rpm is $mysql_shared_rpm_version_orig");
        }
    }
}

sub check_for_system_mem_below_required {

    # Calculations have a 64-96MB fudge factor for overhead
    return unless defined( $MEMINFO->{installed} ) && $MEMINFO->{installed} =~ /[0-9]+/;
    my $memtotal   = int( $MEMINFO->{installed} / 1024 );
    my $memmin     = 704;                                   # 768 - 64
    my $memmintext = "768MB";

    if ( version_compare( $OS_VERSION, qw( >= 7 ) ) ) {
        $memmin     = 928;                                  # 1024 - 96
        $memmintext = "1024MB";
    }

    if ( $memtotal < $memmin ) {
        print_warn('Memory: ');
        print_warning( "Server has less than ${memmintext} installed memory! [ " . format_meminfo( $MEMINFO->{installed} ) . " ]" );
    }

    #TECH-74 recommends >= 1024MB swap on systems with <= 1024MB RAM
    return if $memtotal > 928;
    my $swaptotal = 0;
    $swaptotal = int( $MEMINFO->{swapinstalled} / 1024 ) if defined( $MEMINFO->{swapinstalled} ) && $MEMINFO->{swapinstalled} =~ /[0-9]+/;
    my $swapmin     = 928;
    my $swapmintext = "1024MB";
    if ( $swaptotal < $swapmin ) {
        print_warn('Memory: ');
        print_warning( "Server has less than ${swapmintext} swap! [ " . format_meminfo( $MEMINFO->{swapinstalled} ) . " ]" );
    }
}

sub check_yum_conf {
    my $yum_conf                = '/etc/yum.conf';
    my $exclude_line_count      = 0;
    my $exclude_kernel          = 0;
    my $exclude_wget            = 0;
    my $distroverpkg_cloudlinux = 0;

    if ( !-e $yum_conf ) {
        print_warn('YUM: ');
        print_warning( $yum_conf . ' is missing!' );
    }
    elsif ( -z $yum_conf ) {
        print_warn('YUM: ');
        print_warning( $yum_conf . ' is empty!' );
    }

    if ( open my $file_fh, '<', $yum_conf ) {
        while (<$file_fh>) {
            if (/^\s*exclude/i) {
                $exclude_line_count += 1;
            }
            if (/^\s*exclude.*kernel/) {
                $exclude_kernel = 1;
            }
            if (/^\s*exclude.*wget/) {
                $exclude_wget = 1;
            }
            if (/^\s*distroverpkg=cloudlinux-release/) {
                $distroverpkg_cloudlinux = 1;
            }
        }
        close $file_fh;
    }

    if ( $exclude_line_count > 1 ) {
        print_warn('YUM: ');
        print_warning('yum.conf contains multiple "exclude" lines!');
    }

    if ($exclude_kernel) {
        print_warn('YUM: ');
        print_warning('yum.conf may be excluding kernel updates!');
    }

    if ($exclude_wget) {
        print_warn('YUM: ');
        print_warning('yum.conf may be excluding wget updates!');
    }

    if ($distroverpkg_cloudlinux) {
        print_warn('YUM: ');
        print_warning('yum.conf has distroverpkg=cloudlinux-release set! This is known to cause issues with installing EA4, see ticket 7615739.');
    }
}

sub check_for_cpanel_files {
    my @files = qw(
      /usr/local/cpanel/cpanel
      /usr/local/cpanel/cpsrvd
    );

    push @files, '/usr/local/cpanel/cpsrvd-ssl' if cpanel_version_is(qw( < 11.45.0.0 ));

    for my $file (@files) {
        if ( !-e $file ) {
            print_warn('Critical file missing: ');
            print_warning("$file");
        }
    }
}

sub check_bash_history_for_certain_commands {
    my $bash_history     = '/root/.bash_history';
    my %history_commands = ();
    my $commands;

    if ( -l $bash_history ) {
        my $link = readlink $bash_history;
        print_warn("$bash_history: ");
        print_warning("is a symlink! Linked to $link");
    }
    elsif ( -f $bash_history ) {
        if ( open my $history_fh, '<', $bash_history ) {
            while (<$history_fh>) {
                if (/chattr/) {
                    $history_commands{'chattr'} = 1;
                }
                if (/chmod/) {
                    $history_commands{'chmod'} = 1;
                }
                if (/openssl(?:.*)\.tar/) {
                    $history_commands{'openssl*.tar'} = 1;
                }
            }
            close $history_fh;
        }
    }

    if (%history_commands) {
        while ( my ( $key, $value ) = each(%history_commands) ) {
            $commands .= "[$key] ";
        }

        print_warn("$bash_history commands found: ");
        print_warning($commands);
    }
}

sub check_wwwacctconf_for_incorrect_minuid {
    return unless cpanel_version_is(qw ( < 11.52.0.0 ));
    my $wwwacctconf = '/etc/wwwacct.conf';
    my $minuid;
    my $floor = 500;
    if ( version_compare( $OS_VERSION, qw( >= 7 ) ) ) {
        $floor = 1000;
    }

    if ( open my $wwwacctconf_fh, '<', $wwwacctconf ) {
        while (<$wwwacctconf_fh>) {
            if (/^MINUID\s(\d+)$/) {
                $minuid = $1;
                last;
            }
        }
        close $wwwacctconf_fh;
    }

    if ( $minuid and $minuid =~ /\d+/ ) {
        if ( $minuid < $floor or $minuid > 60000 ) {
            print_warn('MINUID: ');
            print_warning("$wwwacctconf has a MINUID value of $minuid (must be between $floor and 60000 or will cause issues with account creation)");
        }
    }
}

sub check_roots_cron_for_certain_commands {
    my @cronlist = glob(
        q{
        /etc/cron.d/*
        /etc/cron.hourly/*
        /etc/cron.daily/*
        /etc/cron.weekly/*
        /etc/cron.monthly/*
        /var/spool/cron/root
    }
    );

    my %cron_ignore = (    # These contain 'interesting' commands that should be ignored if they aren't going to cause problems
        '7440999604d3517ca235c7949f803ece' => '/etc/cron.daily/maldet',                  # Default
        'aede9174c0a1b0cf225165e204aa6fd8' => '/etc/cron.hourly/modsecparse.pl',         # Default
        '195ddc2ac97502c2a96cc758cb7c9097' => '/etc/cron.daily/freshclam',               # Default
        'de7d9c2df94e20af5aa401e708c3119d' => '/etc/cron.daily/prelink',                 # Default
        'c7a32553c9f6d3d16c07281cae8572e9' => '/etc/cron.daily/tmpwatch',                # Default
        '3ffb5926bb7533bb077e2ec37f767851' => '/etc/cron.daily/tmpwatch',                # modified to not remove symlinks
        'ff511360a325783a06f494a05b514689' => '/etc/cron.d/kill_orphaned_php-cron',      # standard CloudLinux script
        'f392372e36f56fb3e70e850a6bd1a550' => '/etc/cron.d/lvedbgovernor-utils-cron',    # standard CloudLinux script
    );

    my %found = ();

    for my $cron (@cronlist) {
        next if !( -f $cron || -l $cron );
        next
          if (
            $cron =~ m{ /(
            freshclam |
            kill_orphaned_php-cron |
            lvedbgovernor-utils-cron |
            makewhatis\.cron |
            maldet |
            man-db\.cron |
            modsecparse\.pl |
            prelink |
            rpm
            ) $ }x
          );    # Common false-positives to filter out entirely.
        chomp( my $checksum = timed_run( 0, 'md5sum', $cron ) );
        $checksum =~ s/\s.*//g;
        next if ( $checksum && $cron_ignore{$checksum} );
        if ( open my $cron_fh, '<', $cron ) {
            while (<$cron_fh>) {
                if (m{ \A [^#]* (?:^|\s|\/)(rm|unlink|ch(?:mod|own|attr)|(?:p|s)?kill(?:all)?5?|tmpwatch)\s }x) {
                    $found{$cron}{$1} = 1;
                }
            }
            close $cron_fh;
        }
    }

    if (%found) {
        for my $cron ( keys(%found) ) {
            print_warn("cron: ");
            print_warning( $cron . " contains [ " . join( ' ', sort( keys( %{ $found{$cron} } ) ) ) . " ]" );
        }
    }
}

sub check_for_missing_or_commented_customlog {
    return if not defined $APACHE_VERSION;
    my $commented_templates;
    my $missing_customlog_templates;
    my $httpdconf = '/usr/local/apache/conf/httpd.conf';
    my $httpdconf_commented_customlog;
    my $httpdconf_customlog_exists;

    my $templates_dir = '/var/cpanel/templates/apache2';
    if ( version_compare( $APACHE_VERSION, qw( >= 2.4.0 ) ) ) {
        $templates_dir = '/var/cpanel/templates/apache2_4';
    }

    my %templates = (
        'main.default'      => 0,
        'main.local'        => 0,
        'vhost.default'     => 0,
        'vhost.local'       => 0,
        'ssl_vhost.default' => 0,
        'ssl_vhost.local'   => 0,
    );

    for my $template ( keys %templates ) {
        my $template_full_path = $templates_dir . '/' . $template;
        if ( -f $template_full_path ) {
            if ( open my $template_fh, '<', $template_full_path ) {
                while (<$template_fh>) {
                    if (/#(?:\s+)?CustomLog\s/i) {
                        $commented_templates .= "$template_full_path ";
                        $templates{$template} = 1;
                        last;
                    }
                    elsif (/CustomLog\s/i) {
                        $templates{$template} = 1;
                    }
                }
                close $template_fh;
            }
        }
    }

    while ( my ( $template, $value ) = each(%templates) ) {
        if ( $value == 0 and -f "$templates_dir/$template" ) {
            $missing_customlog_templates .= "$templates_dir/$template ";
        }
    }

    if ( open my $httpdconf_fh, '<', $httpdconf ) {
        local $/ = undef;
        my $httpdconf_txt = readline($httpdconf_fh);
        close $httpdconf_fh;
        if ( $httpdconf_txt =~ m/\n[\t ]*#[\t ]*CustomLog\s/si ) {
            $httpdconf_commented_customlog = 1;
        }
        if ( $httpdconf_txt =~ m/\n[\t ]*CustomLog\s/si ) {
            $httpdconf_customlog_exists = 1;
        }
    }

    if ($httpdconf_commented_customlog) {
        $commented_templates .= ' httpd.conf';
    }
    elsif ( !$httpdconf_customlog_exists ) {
        $missing_customlog_templates .= ' httpd.conf';
    }

    if ($commented_templates) {
        print_warn('CustomLog commented out: ');
        print_warning($commented_templates);
    }

    if ($missing_customlog_templates) {
        print_warn('CustomLog entries missing: ');
        print_warning($missing_customlog_templates);
    }
}

sub check_for_cpsources_conf {
    my $cpsources_conf = '/etc/cpsources.conf';

    if ( -f $cpsources_conf and !-z $cpsources_conf ) {
        print_warn('/etc/cpsources.conf: ');
        print_warning('exists! This can affect upcp and EA.');

        open( my $cpsources_conf_fh, '<', $cpsources_conf );
        my @cpsources_servers;
        while (<$cpsources_conf_fh>) {
            my ( $key, $value ) = split( '=', $_ );
            if ( $key eq 'HTTPUPDATE' ) {
                push @cpsources_servers, $value;
            }
        }

      CPSOURCES_SERVER:
        foreach my $cpsources_server (@cpsources_servers) {
            chomp $cpsources_server;
            my ( $host, $port ) = split( ':', $cpsources_server );
            if ( !defined($port) ) {
                $port = 80;
            }

            local $SIG{'ALRM'} = sub {
                print_warn('/etc/cpsources.conf: ');
                print_warning("Unresponsive mirror: http://$host:$port");
                next CPSOURCES_SERVER;
            };

            my $sock = IO::Socket::INET->new(
                PeerAddr => $host,
                PeerPort => $port,
                Proto    => 'tcp',
                Timeout  => 3,
            );

            my $tiers_data;

            if ($sock) {
                print $sock "GET /cpanelsync/TIERS HTTP/1.1\r\nHost: $host\r\n\r\n";
                sysread $sock, $tiers_data, 1000;
                close $sock;
            }

            alarm 0;

            if ( !$tiers_data ) {
                print_warn('/etc/cpsources.conf: ');
                print_warning("Unresponsive mirror: http://$host:$port");
                next CPSOURCES_SERVER;
            }

            # We care about the first line.
            # HTTP/1.1 200 OK

            ( my $http_response ) = split( '\n', $tiers_data );
            ($http_response) = split( '\r', $http_response );

            if ( $http_response =~ /^HTTP\/(\d*?)\.(\d*?) (\d\d\d) (.*?)$/ ) {
                if ( $3 != 200 ) {
                    print_warn('/etc/cpsources.conf: ');
                    print_warning("Server $host:$port responds with $http_response when grabbing TIERS file.");
                }
            }
            else {
                print_warn('/etc/cpsources.conf: ');
                print_warning("Server $host:$port responds with weird HTTP response $http_response");
            }
        }
    }
}

sub check_for_apache_rlimits {
    my $httpdconf = '/usr/local/apache/conf/httpd.conf';
    my ( $rlimitmem, $rlimitcpu );
    my $output;

    if ( open my $httpdconf_fh, '<', $httpdconf ) {
        while (<$httpdconf_fh>) {
            if (m/\A \s* RLimitMEM \s+ (\d+)/xi) {
                $rlimitmem = $1;
            }
            if (m/\A \s* RLimitCPU \s+ (\d+)/xi) {
                $rlimitcpu = $1;
            }
        }
        close $httpdconf_fh;
    }

    if ($rlimitmem) {
        my $rlimitmem_converted = sprintf( '%.0f MB', $rlimitmem / 1024 / 1024 );
        $output = "RLimitMEM $rlimitmem [$rlimitmem_converted]";
    }

    if ($rlimitcpu) {
        $output .= " / RLimitCPU $rlimitcpu";
    }

    if ($output) {
        print_warn('Apache RLimits: ');
        print_warning($output);
    }
}

sub check_for_usr_local_lib_libz_so {
    if ( -f '/usr/local/lib/libz.so' ) {
        print_warn('/usr/local/lib/libz.so: ');
        print_warning('exists. This can prevent EA from completing');
    }
}

sub check_for_non_default_modsec_rules {
    return unless $APACHE_MODSEC;

    my $modsec2_conf      = '/usr/local/apache/conf/modsec2.conf';
    my $modsec2_user_conf = '/usr/local/apache/conf/modsec2.user.conf';
    my $modsec_rules_dir  = '/usr/local/apache/conf/modsec_rules';

    if ( -f $modsec2_conf ) {
        my $modsec2_conf_size     = ( stat($modsec2_conf) )[7];
        my $modsec2_conf_max_size = 1500;
        if ( $modsec2_conf_size > $modsec2_conf_max_size ) {
            print_warn('modsec: ');
            print_warning("$modsec2_conf is > $modsec2_conf_max_size bytes, may contain custom rules");
        }
    }

    if ( -f $modsec2_user_conf ) {
        my $modsec2_user_conf_size = ( stat($modsec2_user_conf) )[7];
        if ( $modsec2_user_conf_size != 0 ) {
            print_warn('modsec: ');
            print_warning("$modsec2_user_conf is not empty, may contain rules");
        }
    }

    if ( -d $modsec_rules_dir ) {
        print_warn('modsec: ');
        print_warning("$modsec_rules_dir exists, 3rd party rules may be in use");
    }
}

sub check_etc_hosts_sanity {
    my $hosts             = '/etc/hosts';
    my $localhost         = 0;
    my $httpupdate        = 0;
    my $localhost_not_127 = 0;
    my $hostname_entry    = 0;

    if ( !-f $hosts ) {
        print_warn('/etc/hosts: ');
        print_warning('missing!');
        return;
    }

    if ( open my $hosts_fh, '<', $hosts ) {
        while ( my $line = <$hosts_fh> ) {
            chomp $line;

            next if ( $line =~ /^(\s+)?#/ );

            if ( $line =~ m{  127\.0\.0\.1 (.*) localhost }xms ) {
                $localhost = 1;
            }
            if ( ( $line =~ m{ \s localhost (\s|\z) }xmsi ) and ( $line !~ m{ 127\.0\.0\.1 | ::1 }xms ) ) {
                $localhost_not_127 = 1;
            }
            if ( $line =~ m{ httpupdate\.cpanel\.net }xmsi ) {
                $httpupdate = 1;
            }
            if ( $line =~ m{ $HOSTNAME }xmsi ) {
                $hostname_entry = 1;
            }
        }
        close $hosts_fh;
    }

    if ( $localhost == 0 ) {
        print_warn('/etc/hosts: ');
        print_warning('no entry for localhost, or commented out');
    }

    if ( $httpupdate == 1 ) {
        print_warn('/etc/hosts: ');
        print_warning('contains an entry for httpupdate.cpanel.net');
    }

    if ( $localhost_not_127 == 1 ) {
        print_warn('/etc/hosts: ');
        print_warning('contains an entry for "localhost" that isn\'t 127.0.0.1! This can break EA and webmail logins');
    }

    if ( $hostname_entry == 0 ) {
        print_warn('/etc/hosts: ');
        print_warning("no entry found for the server's hostname! [$HOSTNAME] (Can break EA or Apache when mod_unique_id is enabled)");
    }
}

sub check_localhost_resolution {

    # At this time we only require localhost to resolve to "127.0.0.1", but "::1" is accounted for
    my $print_check;
    my $found_127_forward;
    my @localhost = _resolve( 'localhost', 1 );
    foreach my $addr (@localhost) {
        unless ( $addr eq '127.0.0.1' or $addr eq '::1' ) {
            print_warn('Resolver: ');
            print_warning( 'returned unexpected address [ ' . $addr . ' ] (out of ' . scalar @localhost . ' total addresses) for "localhost"!' );
            $print_check = 1;
        }
        $found_127_forward = 1 if $addr eq '127.0.0.1';
    }
    unless ($found_127_forward) {
        print_warn('Resolver: ');
        print_warning('did not return expected "127.0.0.1" when resolving "localhost"!');
        $print_check = 1;
    }

    # Check 127.0.0.1 -> name (may be "localhost.domain") -> 127.0.0.1 match
    my $found_127_reverse;
    my @reverse = _resolve( '127.0.0.1', 1 );
    foreach my $host (@reverse) {
        unless ( $host =~ '^localhost' ) {
            print_warn('Resolver: ');
            print_warning( 'returned unexpected name [ ' . $host . ' ] (out of ' . scalar @reverse . ' total names) when resolving "127.0.0.1"!' );
            $print_check = 1;
        }
        my @forward = _resolve( $host, 1 );
        foreach my $addr (@forward) {
            unless ( $addr eq '127.0.0.1' or $addr eq '::1' ) {
                print_warn('Resolver: ');
                print_warning( '"127.0.0.1" resolved to [ ' . $host . ' ] (out of ' . scalar @forward . ' total addresses) which resolved to unexpected localhost address [ ' . $addr . ' ]!' );
                $print_check = 1;
            }
            $found_127_reverse = 1 if $addr eq '127.0.0.1';
        }
    }
    unless ($found_127_reverse) {
        print_warn('Resolver: ');
        print_warning('No full reverse path for "127.0.0.1" found! ( 127.0.0.1 -> localhost -> 127.0.0.1 )');
        $print_check = 1;
    }
    if ($print_check) {
        print_warn('Resolver: ');
        print_warning('Check /etc/{hosts,host.conf,nsswitch.conf,resolv.conf} for sanity.  Localhost resolution problems could cause errant behavior.');
    }
}

sub _resolve {
    my ( $addr, $report_errors, $timeout ) = @_;
    $report_errors = ( defined $report_errors && $report_errors ne "0" ) ? 1 : 0;
    $timeout = defined $timeout ? $timeout : 3;
    my @results;
    my $addrinfo = eval {    # Perl 5.14+
        Socket->import(qw(getaddrinfo getnameinfo NI_NAMEREQD NI_NUMERICHOST NIx_NOSERV SOCK_RAW));
        1;
    };

    local $SIG{'ALRM'} = sub {
        if ($report_errors) {
            print_warn('Resolver: ');
            print_warning( 'Timed out (' . $timeout . ' seconds) resolving "' . $addr . '"' );
        }
        return;
    };
    alarm $timeout;

    if ($addrinfo) {
        no strict 'subs';    # Prevent compile-time warnings on older versions of Perl for the NI_* constants which are loaded at run-time.
        my $getnameinfo_flags = ( $addr =~ /^\d+\.\d+\.\d+\.\d+$/ ) ? Socket::NI_NAMEREQD : Socket::NI_NUMERICHOST;    # If looking up IP address we require name resolution, otherwise we want the IP address returned.
        my ( $err, @socks ) = getaddrinfo( $addr, "", { socktype => SOCK_RAW } );
        if ( $report_errors && $err ) {
            print_warn('Resolver: ');
            print_warning( 'getaddrinfo() failed to resolve "' . $addr . '": ' . $err );
        }
        foreach my $sock (@socks) {
            my ( $err, $result ) = getnameinfo( $sock->{addr}, $getnameinfo_flags, Socket::NIx_NOSERV );
            if ( $report_errors && $err ) {
                print_warn('Resolver: ');
                print_warning( 'getnameinfo() failed to resolve "' . $addr . '": ' . $err );
                next;
            }
            push @results, $result;
        }
    }
    else {    # Fall back to older (deprecated) Socket functions
        my %h_errno = (
            '1' => 'HOST_NOT_FOUND',
            '2' => 'TRY_AGAIN',
            '3' => 'NO_RECOVERY',
            '4' => 'NO_DATA'
        );
        if ( $addr =~ /^\d+\.\d+\.\d+\.\d+$/ ) {
            my $packed = inet_aton($addr);
            return unless defined $packed;
            my $result = gethostbyaddr( $packed, AF_INET );
            my $error = $? ? "h_errno " . ( exists $h_errno{$?} ? $h_errno{$?} : $? ) : 0;
            if ( $report_errors && $error ) {
                print_warn('Resolver: ');
                print_warning( 'gethostbyaddr() failed to resolve "' . $addr . '": ' . $error );
                return;
            }
            push @results, $result;
        }
        else {
            my $packed_result = gethostbyname($addr);
            my $error = $? ? "h_errno " . ( exists $h_errno{$?} ? $h_errno{$?} : $? ) : 0;
            if ( $report_errors && $error ) {
                print_warn('Resolver: ');
                print_warning( 'gethostbyname() failed to resolve "' . $addr . '": ' . $error );
            }
            if ( defined $packed_result ) {
                my $result = inet_ntoa($packed_result);
                push @results, $result;
            }
        }
    }
    alarm 0;
    return @results;
}

sub check_for_empty_or_missing_files {
    my $var_cpanel_users = '/var/cpanel/users';
    return if !-d $var_cpanel_users;
    return unless opendir( my $dir_fh, $var_cpanel_users );
    my @dir_contents = grep { !/^(\.\.?|cp\d+[a-z]+)$/ } readdir $dir_fh;
    closedir $dir_fh;

    # if there are no users on the box, don't warn about userdatadomains
    return if scalar @dir_contents == 0;

    my $userdatadomains = '/etc/userdatadomains';

    if ( !-e $userdatadomains ) {
        print_warn('Missing file: ');
        print_warning("$userdatadomains (new server with no accounts, perhaps)");
    }
    elsif ( -f $userdatadomains and -z $userdatadomains ) {
        print_warn('Empty file: ');
        print_warning("$userdatadomains (generate it with /scripts/updateuserdatacache --force)");
    }
}

sub check_for_apache_listen_host_is_localhost {
    return if not defined $CPCONF{'apache_port'};

    my $apache_setting = $CPCONF{'apache_port'};
    $apache_setting =~ s/:.*//g;

    if ( $apache_setting eq '127.0.0.1' ) {
        print_warn('Apache listen host: ');
        print_warning('Apache may only be listening on 127.0.0.1');
    }
}

sub check_roundcube_mysql_pass_mismatch {
    return if ( defined $CPCONF{'roundcube_db'} and $CPCONF{'roundcube_db'} ne 'mysql' );

    my $roundcubepass;
    my $rc_mysql_pass;

    if ( open my $rc_pass_fh, '<', '/var/cpanel/roundcubepass' ) {
        while (<$rc_pass_fh>) {
            chomp( $roundcubepass = $_ );
        }
        close $rc_pass_fh;
    }
    else {
        return;
    }

    if ( open my $db_inc_fh, '<', '/usr/local/cpanel/base/3rdparty/roundcube/config/db.inc.php' ) {
        while (<$db_inc_fh>) {
            if (m{ \A \$rcmail_config\['db_dsnw'\] \s = \s 'mysql://roundcube:(.*)\@(?:.*)/roundcube';  }xms) {
                $rc_mysql_pass = $1;
            }
        }
        close $db_inc_fh;
    }
    else {
        return;
    }

    if ( !$roundcubepass or !$rc_mysql_pass ) {
        return;
    }

    if ( $roundcubepass ne $rc_mysql_pass ) {
        print_warn('RoundCube: ');
        print_warning('password mismatch [/var/cpanel/roundcubepass] [/usr/local/cpanel/base/3rdparty/roundcube/config/db.inc.php]');
    }
}

sub check_for_hooks_from_var_cpanel_hooks_yaml {
    my $hooks_yaml = '/var/cpanel/hooks.yaml';
    my ( @hooks_tmp, @hooks );

    if ( open my $file_fh, '<', $hooks_yaml ) {
        while (<$file_fh>) {
            if (/hook: (.*)/) {

                # Ignore default Attracta hooks
                next if ( $1 =~ m{ \A ( /usr/local/cpanel/3rdparty/attracta/scripts/pkgacct-restore | /usr/local/cpanel/Cpanel/ThirdParty/Attracta/Hooks/pkgacct-restore ) \z }xms );
                push @hooks_tmp, "$1 ";
            }
        }
        close $file_fh;
    }

    for my $hook (@hooks_tmp) {
        if ( $hook =~ m/^\// ) {
            if ( -e $hook and !-z $hook ) {
                push @hooks, $hook;
            }
        }
        else {
            push @hooks, $hook;    # we don't check for the existence of all hooks since they could be anywhere in perl's @INC, I think?
        }
    }

    if ( scalar @hooks == 1 ) {
        print_warn('Hooks in /var/cpanel/hooks.yaml: ');
        print_warning(@hooks);
    }
    elsif ( scalar @hooks > 1 ) {
        print_warn("Hooks in /var/cpanel/hooks.yaml:\n");
        for my $hook (@hooks) {
            print_magenta("\t \\_ $hook");
        }
    }
}

sub get_mysql_error_log {
    if ( $MYSQL_CONF->{'LINES'} && $MYSQL_CONF->{'mysqld'}{'logerror'} ) {
        return $MYSQL_CONF->{'mysqld'}{'logerror'}[1];
    }
    else {
        return '/var/lib/mysql/' . $HOSTNAME . '.err';
    }
}

sub check_mysql_config {
    return if !$MYSQL_CONF->{'LINES'};

    # Example: 'optionwithoutdashesorunderscores' => { default => 'defaultvalue', check_missing => 1, orig_name => 'option_with_underscores-or-dashes', help => '- Help text' },
    # default, check_missing, and help are optional, but orig_name should be defined if check_missing is used so that its name can be properly printed
    # If check_missing exists, a warning is generated if the item is NOT in my.cnf and does not match the default (if given)

    my %mysqld_checks = (
        'datadir'             => { default => '/var/lib/mysql' },
        'innodbforcerecovery' => { default => '0', help => 'Makes all InnoDB databases read-only, will break MySQL upgrades.' },
        'logerror'            => { default => '/var/lib/mysql/' . $HOSTNAME . '.err' },
        'lowercasetablenames' => { default => '0', help => 'Will break space usage reporting of databases with mixed-case names. See CPANEL-8453.' },
        'skipnameresolve'     => { help    => 'Seeing "Can\'t find any matching row"? That may be why.' },
        'skipnetworking'      => { help    => 'Webmail or other MySQL related items not functioning properly? That may be why.' },
        'sqlmode'             => { help    => 'Seeing "Field \'ssl_cipher\' doesn\'t have a default value"? That may be why.' }
    );

    if ( cpanel_version_is(qw( >= 11.49.0.0 )) && cpanel_version_is(qw( < 11.50.0.11 )) ) {
        $mysqld_checks{'collationdatabase'} = { help => 'Did horde fail to convert to SQLite?  See FB-127529.' };
        $mysqld_checks{'collationserver'}   = { help => 'Did horde fail to convert to SQLite?  See FB-127529.' };
    }

    if ( defined( $MEMINFO->{memtotal} ) ) {
        my $mem_mb = int( $MEMINFO->{memtotal} / 1024 );

        # Systems w/2GB RAM report around 1800MB total after overhead, so 1700 should be a good tipping point
        if ( $mem_mb < 1700 && version_compare( $CPCONF{'mysql-version'}, qw( >= 5.6 ) ) ) {
            $mysqld_checks{'performanceschema'} = { default => '0', check_missing => 1, orig_name => "performance_schema", help => 'performance_schema is enabled by default in MySQL 5.6+ and could use a significant amount of memory, recommend "performance_schema = 0" with less than 2GB RAM [detected ' . $mem_mb . 'MB].' };
        }
    }

    for my $check ( sort( keys(%mysqld_checks) ) ) {
        $mysqld_checks{$check}->{default}       = "" unless defined( $mysqld_checks{$check}->{default} );
        $mysqld_checks{$check}->{check_missing} = 0  unless defined( $mysqld_checks{$check}->{check_missing} );
        $mysqld_checks{$check}->{help}          = "" unless defined( $mysqld_checks{$check}->{help} );
        my $help = $mysqld_checks{$check}->{help} ? ' - ' . $mysqld_checks{$check}->{help} : '';
        if ( defined( $MYSQL_CONF->{'mysqld'}{$check} ) && !( $MYSQL_CONF->{'mysqld'}{$check}[1] eq $mysqld_checks{$check}->{default} ) ) {
            print_warn('MySQL /etc/my.cnf: ');
            if ( $MYSQL_CONF->{'mysqld'}{$check}[1] eq "enabled" ) {
                print_warning( '[ ' . $MYSQL_CONF->{'mysqld'}{$check}[0] . ' ] found ' . $help );
            }
            else {
                print_warning( '[ ' . $MYSQL_CONF->{'mysqld'}{$check}[0] . ' = ' . $MYSQL_CONF->{'mysqld'}{$check}[1] . ' ] ' . $help );
            }
        }
        elsif ( $mysqld_checks{$check}->{check_missing} && !defined( $MYSQL_CONF->{'mysqld'}{$check} ) ) {
            my $optname = defined( $mysqld_checks{$check}->{orig_name} ) ? $mysqld_checks{$check}->{orig_name} : $check;
            print_warn('MySQL /etc/my.cnf: ');
            print_warning( '[ ' . $optname . ' ] not found ' . $help );
        }
    }
}

sub check_for_extra_mysql_config_files {

    # It's silly how many locations mysqld looks for a configuration file.
    # These locations are reported by mysqld --help and by looking through /usr/bin/mysqld_safe code
    my @extra_locations = qw(
      /etc/mysql/my.cnf
      /usr/my.cnf
      /usr/etc/my.cnf
      /var/lib/mysql/my.cnf
    );
    my @found_locations = ();

    for my $loc (@extra_locations) {
        push @found_locations, $loc if -f $loc;
    }

    return if !@found_locations;
    print_warn('MySQL - extra my.cnf files found: ');
    print_warning( '[ ' . join( " ", @found_locations ) . ' ]' );
    print_warning( "\t " . '\_ These may replace or be merged with /etc/my.cnf settings!' );
}

sub check_cpanel_config {
    return if !keys(%CPCONF);

    # Example: 'exact_option_name' => { default => 'defaultvalue', check_missing => 1, help => '- Help text' },
    # default, check_missing, and help are optional
    # If check_missing exists, a warning is generated if the item is NOT in cpanel.config and does not match the default (if given) or is empty

    my %cpanel_checks = (
        'enablecompileroptimizations' => { default       => '0', help => 'Tweak setting "Enable optimizations for the C compiler" enabled. If Sandy Bridge CPU, problems MAY occur (see ticket 3355885)' },
        'ftpserver'                   => { check_missing => 1 },
        'mailserver'                  => { check_missing => 1 },
        'mysql-version'               => { check_missing => 1 },
        'nativessl'                   => { default       => '1', help => 'Native SSL support for WHM/cPanel services is disabled' },
        'skiphttpauth'                => { default       => '1', help => 'HTTP auth enabled' },
    );

    if ( cpanel_version_is(qw( < 11.48.0.0 )) ) {
        $cpanel_checks{'use_safe_quotas'} = { default => '0', help => 'Suspend and unsuspend will be slow. Useless on RHEL/CentOS 5+. See FB-63646.' };
    }
    if ( defined $CPCONF{'maxmem'} && $CPCONF{'maxmem'} < 512 ) {
        $cpanel_checks{'maxmem'} = { default => '512', help => '< 512M, phpmyadmin may fail' };
    }
    if ( cpanel_version_is(qw( < 11.42.1.1 )) ) {
        $cpanel_checks{'cgihidepass'} = { default => '0', help => 'Tweak setting "Hide login password from cgi scripts" is enabled. Expired passwords can\'t be changed via WHM. See FB-87581' };
    }

    for my $check ( sort( keys(%cpanel_checks) ) ) {
        $cpanel_checks{$check}->{check_missing} = 0  unless defined( $cpanel_checks{$check}->{check_missing} );
        $cpanel_checks{$check}->{help}          = "" unless defined( $cpanel_checks{$check}->{help} );
        my $help = $cpanel_checks{$check}->{help} ? ' - ' . $cpanel_checks{$check}->{help} : '';
        if ( defined( $CPCONF{$check} ) && defined( $cpanel_checks{$check}->{default} ) && !( $CPCONF{$check} eq $cpanel_checks{$check}->{default} ) ) {
            print_warn('cpanel.config: ');
            print_warning( '[ ' . $check . '=' . $CPCONF{$check} . ' ]' . $help );
        }
        elsif ( $cpanel_checks{$check}->{check_missing} && ( !defined( $CPCONF{$check} ) || ( defined( $CPCONF{$check} ) && $CPCONF{$check} eq "" ) ) ) {
            print_warn('cpanel.config: ');
            print_warning( '[ ' . $check . ' ] not found or has empty value' . $help );
        }
    }
}

sub check_for_low_ulimit_for_root {
    my $ulimit_m = timed_run( 0, 'echo `ulimit -m`' );
    my $ulimit_v = timed_run( 0, 'echo `ulimit -v`' );

    chomp( $ulimit_m, $ulimit_v );

    if ( $ulimit_m =~ /\d+/ ) {
        $ulimit_m = sprintf( '%.0f', $ulimit_m / 1024 );
    }
    if ( $ulimit_v =~ /\d+/ ) {
        $ulimit_v = sprintf( '%.0f', $ulimit_v / 1024 );
    }

    if ( $ulimit_m =~ /\d+/ and $ulimit_m <= 256 or $ulimit_v =~ /\d+/ and $ulimit_v <= 256 ) {
        if ( $ulimit_m =~ /\d+/ ) {
            $ulimit_m .= 'MB';
        }
        if ( $ulimit_v =~ /\d+/ ) {
            $ulimit_v .= 'MB';
        }

        print_warn('ulimit: ');
        print_warning("-m [ $ulimit_m ] -v [ $ulimit_v ] Low ulimits can cause EA to fail when run via the shell");
    }
}

sub check_for_fork_bomb_protection {
    if ( -f '/etc/profile.d/limits.sh' or -f '/etc/profile.d/limits.csh' ) {
        print_warn('Fork Bomb Protection: ');
        print_warning('enabled!');
    }
}

# cPanel < 11.30.7.3 will get YAML::Syck from CPAN. If this causes any issues with
# Cpanel::TaskQueue, cPanel's position is to upgrade cPanel.
sub check_for_cPanel_lower_than_11_30_7_3 {
    return if cpanel_version_is(qw( >= 11.30.7.3 ));
    print_warn('cPanel: ');
    print_warning('versions < 11.30.7.3 use YAML::Syck from CPAN. If problems with Cpanel::TaskQueue, cPanel needs to be updated');
}

sub check_for_custom_exim_conf_local {
    my $exim_conf_local = '/etc/exim.conf.local';
    my $is_customized   = 0;

    if ( open my $file_fh, '<', $exim_conf_local ) {
        while ( my $line = <$file_fh> ) {
            chomp $line;
            if ( $line !~ m{ \A ( @ | $ ) }xms ) {
                $is_customized = 1;
                last;
            }
        }
        close $file_fh;
    }

    if ( $is_customized == 1 ) {
        print_warn('Exim: ');
        print_warning("$exim_conf_local contains customizations");
    }
}

sub check_for_maxclients_or_maxrequestworkers_reached {
    return if !$APACHE_VERSION;
    my $log            = '/usr/local/apache/logs/error_log';
    my $size           = ( stat($log) )[7];
    my $bytes_to_check = 20_971_520 / 2;                       # 10M limit of logs to check, may need adjusting, depending how much time it adds to SSP
    my $seek_position  = 0;
    my $log_data;
    my @logs;
    my $limit_last_hit_date;

    return if !$size;

    if ( $size > $bytes_to_check ) {
        $seek_position = ( $size - $bytes_to_check );
    }

    if ( open my $file_fh, '<', $log ) {
        seek $file_fh, $seek_position, 0;
        read $file_fh, $log_data, $bytes_to_check;
        close $file_fh;
    }
    if ( $log_data =~ m/(?:MaxClients|MaxRequestWorkers)/s ) {
        @logs = split /\n/, $log_data;
        undef $log_data;
        @logs = reverse @logs;
        for my $log_line (@logs) {
            if ( version_compare( $APACHE_VERSION, qw( < 2.3.0 ) ) ) {

                # [Wed Nov 14 05:55:04 2012] [error] server reached MaxClients setting, consider raising the MaxClients setting
                if ( $log_line =~ m{ \A \[ (\S+ \s+ \S+ \s+ \S+ \s+ \S+ \s+ \S+ ) \] \s+ \[error\] \s+ server \s+ reached \s+ MaxClients }xms ) {
                    $limit_last_hit_date = $1;
                    last;
                }
            }
            elsif ( version_compare( $APACHE_VERSION, qw( >= 2.4.0 ) ) ) {

                # [Fri Feb 08 09:58:45.875187 2013] [mpm_prefork:error] [pid 23220] AH00161: server reached MaxRequestWorkers
                if ( $log_line =~ m{ \A \[ (\S+ \s+ \S+ \s+ \S+ \s+ \S+ \s+ \S+ ) \] \s (.*) server \s reached \s MaxRequestWorkers }xms ) {
                    $limit_last_hit_date = $1;
                    last;
                }
            }
        }
    }

    if ($limit_last_hit_date) {
        if ( version_compare( $APACHE_VERSION, qw( < 2.3.0 ) ) ) {
            print_warn('Apache MaxClients: ');
        }
        elsif ( version_compare( $APACHE_VERSION, qw( >= 2.4.0 ) ) ) {
            print_warn('Apache MaxRequestWorkers: ');
        }

        print_warning("limit last reached at $limit_last_hit_date");
    }
}

sub check_for_non_default_umask {
    my $umask = timed_run( 0, 'echo `umask`' );

    return if !$umask;

    chomp $umask;

    if ( $umask !~ /2$/ ) {
        print_warn('umask: ');
        print_warning("Non-default value [$umask] (check FB-62683 if permissions error when running convert_roundcube_mysql2sqlite)");
    }
}

sub check_for_multiple_imagemagick_installs {
    if ( -x '/usr/bin/convert' and !-l '/usr/bin/convert' ) {
        if ( -x '/usr/local/bin/convert' and !-l '/usr/local/bin/convert' ) {
            print_warn('ImageMagick: ');
            print_warning('multiple "convert" binaries found [/usr/bin/convert] [/usr/local/bin/convert]');
        }
    }
}

sub check_for_kernel_headers_rpm {
    if ( !-f '/usr/include/linux/limits.h' ) {
        print_warn('Missing file: ');
        print_warning('/usr/include/linux/limits.h not found. This can cause problems with EA. kernel-headers RPM missing/broken?');
    }
    else {
        if ( @RPM_LIST && !grep( /^kernel-headers-/, @RPM_LIST ) ) {
            print_warn('kernel-headers RPM: ');
            print_warning('not found. This can cause problems with EA');
        }
    }
}

sub check_for_broken_rpm {
    return unless @RPM_LIST;
    my %rpms = (    # 'rpm name' => { check => ['check1', 'check2', ...], help => 'Additional info' } # Check types should be ordered by dependency, first failure skips other checks for that RPM.
        'cpuspeed' => { check => ['exists'], help => 'May cause yum to crash when updating kernel. Send "cpuspeed detected" predefined response.' }
    );

    if ($EA4) {
        $rpms{'ea-apache24-mod_lua'} = { check => ['exists'], help => 'Experimental. Potential security issues in shared hosting environments.' };
        $rpms{'httpd-tools'}         = { check => ['exists'], help => 'Conflicts with ea-apache24-tools, will break EA4.' };
    }
    else {
        $rpms{'cpp'} = { check => ['verify-fail'], help => 'Missing or modified files, may cause EasyApache to fail, verify with "rpm -V cpp"' };
    }

    my %rpm_checks = (
        'exists' => {
            help => 'RPM exists',
            run  => sub {           # Only care that the RPM exists.
                my $rpm = shift;
                return 1 if grep( /^${rpm}-/, @RPM_LIST );
                return 0;
            }
        },
        'missing' => {
            help => 'Missing RPM',
            run  => sub {            # Only care that the RPM is missing.
                my $rpm = shift;
                return 0 if grep( /^${rpm}-/, @RPM_LIST );
                return 1;
            }
        },
        'verify-fail' => {
            help => 'Verify Failed',
            run  => sub {              # Only performs check if the RPM exists.
                my $rpm = shift;
                return 0 if !grep( /^${rpm}-/, @RPM_LIST );
                my $output = timed_run( 0, 'rpm', '-V', $rpm );
                return 0 if $output eq "";
                return 1 if $output =~ m{ \A missing }xms;
                return 1 if $output =~ m{ \A ..5 }xms;
                return 0;
            }
        }
    );

    for my $rpm ( sort keys %rpms ) {
        for my $check ( @{ $rpms{$rpm}{check} } ) {
            if ( $rpm_checks{$check}{run}->($rpm) ) {
                my $additional_info = $rpms{$rpm}{help} ? ( "( " . $rpms{$rpm}{help} . " )" ) : '';
                print_warn('RPM check: ');
                print_warning( $rpm_checks{$check}{help} . " - [ " . $rpm . " ] " . $additional_info );
                last;
            }
        }
    }
}

sub check_for_ea4_mismatch {
    return unless $EA4;
    my $cp_count = 0;
    my $cl_count = 0;
    foreach (@RPM_LIST) {
        $cp_count++ if /^ea-.*\.cpanel/;
        $cl_count++ if /^ea-.*\.cloudlinux/;
    }
    if ($IS_CLOUDLINUX) {
        return unless $cp_count;
        print_warn('EA4 RPMs: ');
        print_warning( 'Found ' . $cp_count . ' "ea-*.cpanel" RPMs on a CloudLinux system!  Using wrong EA4 repo?' );
    }
    else {
        return unless $cl_count;
        print_warn('EA4 RPMs: ');
        print_warning( 'Found ' . $cl_count . ' "ea-*.cloudlinux" RPMs on a non-CloudLinux system!  Using wrong EA4 repo?' );
    }
}

sub check_for_custom_locales {
    return if cpanel_version_is(qw( >= 11.46.0.0 ));

    my $locale_dir = '/var/cpanel/locale.local';
    my $users_dir  = '/var/cpanel/users';

    return if !-d $locale_dir;
    return if !-d $users_dir;

    my ( @locale_dir_contents_tmp, @locale_dir_contents, @cpanel_users );
    my ( @users_locales, @users_with_custom_locales );

    opendir( my $locale_dir_fh, $locale_dir );
    @locale_dir_contents_tmp = grep { !/^\.\.?$/ } readdir $locale_dir_fh;
    closedir $locale_dir_fh;

    return if !@locale_dir_contents_tmp;

    for my $locale (@locale_dir_contents_tmp) {
        $locale =~ s/^en\.yaml//g;    # doesn't seem to be affected
        $locale =~ s/\.yaml$//g;
        push @locale_dir_contents, $locale;
    }

    return if !@locale_dir_contents;

    opendir( my $users_dir_fh, $users_dir );
    @cpanel_users = grep { !/^(\.\.?|root)$/ } readdir $users_dir_fh;
    closedir $users_dir_fh;

    return if !@cpanel_users;

    my $user_count = scalar @cpanel_users;

    if ( $user_count > 2000 ) {
        print_warn("cpusers: ");
        print_warning("Too many cpanel users to do locales check: $user_count");
        return;
    }

    for my $user (@cpanel_users) {
        if ( open my $user_fh, '<', "${users_dir}/${user}" ) {
            while (<$user_fh>) {
                if (/^LOCALE=(.*)/) {
                    push @users_locales, "${user}:${1}\n";
                    last;
                }
            }
            close $user_fh;
        }
    }

    return if !@users_locales;

    for my $user_and_locale (@users_locales) {
        my ( $user, $locale ) = split /:/, $user_and_locale;
        if ( grep { m{ \A $locale \z }xms } @locale_dir_contents ) {
            push @users_with_custom_locales, $user;
            last;
        }
    }

    return if !@users_with_custom_locales;

    print_warn('locales: ');
    print_warning('Users with custom locales detected. Seeing "500 Internal Server Error" in cPanel? May be related, check FB-62119 and FB-107865');
}

sub check_eximstats_size {
    return if !-d $MYSQL_DATADIR;

    my $eximstats_dir = $MYSQL_DATADIR . 'eximstats/';
    my @dir_contents;
    my $size;

    if ( -d $eximstats_dir ) {
        opendir( my $dir_fh, $eximstats_dir );
        @dir_contents = grep { /(defers|failures|sends|smtp)\.(frm|MYI|MYD)$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    for my $file (@dir_contents) {
        $file = $eximstats_dir . $file;
        $size += ( stat($file) )[7];
    }

    if ( $size && $size > 5_000_000_000 ) {
        $size = sprintf( "%0.2fGB", $size / 1073741824 );
        print_warn('eximstats db: ');
        print_warning($size);
    }
}

sub check_eximstats_corrupt {
    return if !-f $MYSQL_ERROR_LOG;

    my $size           = ( stat($MYSQL_ERROR_LOG) )[7];
    my $bytes_to_check = 20_971_520;                      # 20M limit of logs to check
    my $seek_position  = 0;
    my $log_data;
    my @logs;
    my $eximstats_is_crashed;

    if ( $size > $bytes_to_check ) {
        $seek_position = ( $size - $bytes_to_check );
    }

    if ( open my $file_fh, '<', $MYSQL_ERROR_LOG ) {
        seek $file_fh, $seek_position, 0;
        read $file_fh, $log_data, $bytes_to_check;
        close $file_fh;
    }

    @logs = split /\n/, $log_data;
    undef $log_data;
    @logs = reverse @logs;

    for my $log_line (@logs) {

        # /usr/sbin/mysqld: Table './eximstats/smtp' is marked as crashed and should be repaired
        if ( $log_line =~ m{ /eximstats/ (.*) marked \s as \s crashed }xms ) {
            $eximstats_is_crashed = $log_line;
            last;
        }
    }

    if ($eximstats_is_crashed) {
        print_warn('eximstats: ');
        print_warning("latest crash: $eximstats_is_crashed");
    }
}

sub check_for_broken_mysql_tables {
    my %broken;
    for ( split /\n/, timed_run( 0, 'mysql', '-NBe', 'SELECT table_schema,table_name,engine,row_format,create_time FROM information_schema.tables WHERE ( table_schema=\'cphulkd\' OR table_schema=\'eximstats\' OR table_schema=\'horde\' OR table_schema=\'modsec\' OR table_schema=\'roundcube\' OR table_schema=\'whmxfer\' ) AND engine IS NULL' ) ) {
        my @line = split /\t/;
        $broken{ $line[0] }{ $line[1] } = 1;
    }
    for ( sort( keys(%broken) ) ) {
        print_warn('mysql: broken tables - ');
        my $tables = scalar keys( %{ $broken{$_} } ) > 4 ? 'More than 4!' : join( ' ', sort( keys( %{ $broken{$_} } ) ) );
        print_warning( $_ . ' [ ' . $tables . ' ]' );
    }
}

sub check_for_broken_mysql_horde {
    return if cpanel_version_is(qw ( >= 11.50.0.12 ));
    chomp( my $columns = timed_run( 0, 'mysql', '-NBe', 'SELECT COUNT(*) FROM information_schema.columns WHERE table_schema=\'horde\' AND table_name=\'horde_alarms\'' ) );
    return if !defined $columns;
    return unless $columns =~ m{ \A [0-9]+ \z }xms;
    $columns += 0;
    if ( $columns > 0 && $columns != 12 ) {
        print_warn('mysql: ');
        print_warning('horde.horde_alarms does not contain the expected 12 columns, this will prevent Horde conversion to SQLite in WHM 11.50.  See FB-189785.');
    }
}

sub check_for_clock_skew {
    ## last updated 2016-12-08
    ## we do this to avoid having to do the DNS lookup
    my @rdate_servers = qw(
      208.74.121.36
      208.74.121.43
      208.74.123.15
      208.74.123.23
    );

    my $localtime = time();
    my $rdate_time;
    my $clock_skew;

    my %months = qw(
      Jan 0   Feb 1   Mar 2   Apr 3   May 4   Jun 5
      Jul 6   Aug 7   Sep 8   Oct 9   Nov 10  Dec 11
    );

    for ( 1 .. 2 ) {
        my $num = int rand scalar @rdate_servers;
        $rdate_time = timed_run( 10, 'rdate', '-p', '-t', '3', $rdate_servers[$num] );
        next if $rdate_time =~ /timeout/;
        last if $rdate_time;
    }

    return if !$rdate_time;

    $rdate_time =~ s/\A rdate: \s \[[^\]]+\] \s+//gxms;

    if ( $rdate_time =~ m{ \A \S+ \s+ (\S+) \s+ (\d+) \s+ (\d+):(\d+):(\d+) \s+ (\d+) }xms ) {
        my ( $mon, $mday, $hour, $min, $sec, $year ) = ( $1, $2, $3, $4, $5, $6 );
        $mon = $months{$mon};

        $rdate_time = timelocal( $sec, $min, $hour, $mday, $mon, $year );
    }
    return if ( $rdate_time !~ /\d{10,}/ );

    $clock_skew = ( $rdate_time - $localtime );
    $clock_skew = abs $clock_skew;                # convert negative numbers to positive

    my $max_skew = 120;
    if ( defined $CPCONF{'SecurityPolicy::TwoFactorAuth'} && $CPCONF{'SecurityPolicy::TwoFactorAuth'} == 1 ) {
        $max_skew = 25;
    }

    return if ( $clock_skew < $max_skew );

    if ( $clock_skew >= 31536000 ) {
        $clock_skew = sprintf '%d', ( $clock_skew / 31536000 );
        $clock_skew .= ' year(s)';
    }
    elsif ( $clock_skew >= 86400 ) {
        $clock_skew = sprintf '%d', ( $clock_skew / 86400 );
        $clock_skew .= ' day(s)';
    }
    elsif ( $clock_skew >= 3600 ) {
        $clock_skew = sprintf '%d', ( $clock_skew / 3600 );
        $clock_skew .= ' hour(s)';
    }
    elsif ( $clock_skew >= 60 ) {
        $clock_skew = sprintf '%d', ( $clock_skew / 60 );
        $clock_skew .= ' minute(s)';
    }
    else {
        $clock_skew = sprintf '%d', ($clock_skew);
        $clock_skew .= ' seconds';
    }

    print_warn('Clock skew: ');
    print_warning("server time may be off by ${clock_skew}. A very large difference may cause SSL/TLS connection errors, and more than about 30 seconds can cause 2FA failure.");
}

sub check_for_zlib_h {
    if ( -f '/usr/local/include/zlib.h' ) {
        print_warn('/usr/local/include/zlib.h: ');
        print_warning('This file can cause EA to fail with libxml issues. You may need to mv it, run EA again');
    }
}

sub check_for_better_linux {
    return if ( !$#EXTENDED_RPM_LIST );

    foreach my $rpm_ref ( grep { $_->{'name'} =~ m/^kernel/ } @EXTENDED_RPM_LIST ) {
        if ( $rpm_ref->{'release'} =~ m/\.bl/ ) {
            print_warn("BetterLinux detected:\n");
            print_magenta("\t \\_ Branding problems? Possible CloakFS involvement. See FB-64368, ticket 4582511");
            print_magenta("\t \\_ ImageMagick segfaulting? See tickets 4185629, 4087003");
            last;
        }
    }
}

sub check_for_duplicate_rpms {
    return if ( !$#EXTENDED_RPM_LIST );

    my %SEEN_RPMS;
    my %DUP_RPMS;
    foreach my $rpm_ref (@EXTENDED_RPM_LIST) {
        push @{ $SEEN_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } }, $rpm_ref->{'version'} . '-' . $rpm_ref->{'release'};
        if ( scalar @{ $SEEN_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } } > 1 ) {
            $DUP_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } = 1;
        }

    }

    foreach my $dup_rpm ( sort keys %DUP_RPMS ) {
        next if ( $dup_rpm =~ m{^(?:gpg-pubkey|kernel)} );

        print_warn('DUPLICATE RPM: ');
        print_warning( "$dup_rpm has multiple versions: " . join( " ", @{ $SEEN_RPMS{$dup_rpm} } ) );

    }
}

sub check_for_percona_rpms {
    return if !@RPM_LIST;

    my $has_percona = 0;

    for my $rpm (@RPM_LIST) {
        if ( $rpm =~ /^Percona-/i ) {
            $has_percona = 1;
            last;
        }
    }

    if ( $has_percona == 1 ) {
        print_warn("Percona RPMs found:\n");
        print_magenta("\t \\_ EA failing with \"Cannot find libmysqlclient\"? libmysqlclient.so missing? see FB-93349");
        print_magenta("\t \\_ If Exim is segfaulting after STARTTLS, this may be why. See ticket 3658929");
        print_magenta("\t \\_ If Apache with PHP DSO is segfaulting after restart, this may be why. See ticket 5525179");
    }
}

sub check_if_httpdconf_ipaddrs_exist {
    my $httpdconf = '/usr/local/apache/conf/httpd.conf';
    my @vhost_ipaddrs;
    my @unbound_ipaddrs;

    return if !-f $httpdconf;

    if ( open my $httpdconf_fh, '<', $httpdconf ) {
        local $/ = undef;
        my $httpdconf_txt = readline($httpdconf_fh);
        close $httpdconf_fh;
        while ( $httpdconf_txt =~ m/<VirtualHost\s+(\d+\.\d+\.\d+\.\d+):(?:\d+)>/sig ) {
            push @vhost_ipaddrs, $1;
        }
    }

    # uniq IP addrs only
    @vhost_ipaddrs = do {
        my %seen;
        grep { !$seen{$_}++ } @vhost_ipaddrs;
    };

    for my $vhost_ipaddr (@vhost_ipaddrs) {
        my $is_bound = 0;
        for my $local_ipaddr (@LOCAL_IPADDRS_LIST) {
            if ( $vhost_ipaddr eq $local_ipaddr ) {
                $is_bound = 1;
                last;
            }
        }
        if ( $is_bound == 0 ) {
            push @unbound_ipaddrs, $vhost_ipaddr;
        }
    }

    if (@unbound_ipaddrs) {
        print_warn('Apache: ');
        print_warning('httpd.conf has VirtualHosts for these IP addrs, which aren\'t bound to the server:');

        for my $unbound_ipaddr (@unbound_ipaddrs) {
            print_magenta("\t \\_ $unbound_ipaddr");
        }
    }
}

sub check_distcache_and_libapr {
    my $last_success_profile           = '/var/cpanel/easy/apache/profile/_last_success.yaml';
    my $has_distcache                  = 0;
    my $httpd_not_linked_to_system_apr = 0;

    if ( open my $profile_fh, '<', $last_success_profile ) {
        while (<$profile_fh>) {
            if (/Distcache:/) {
                $has_distcache = 1;
                last;
            }
        }
        close $profile_fh;
    }

    if ( $has_distcache == 1 ) {
        my @ldd = split /\n/, timed_run( 0, 'ldd', '/usr/local/apache/bin/httpd' );
        for my $line (@ldd) {
            if ( $line =~ m{ libapr(?:.*) \s+ => \s+ (\S+) }xms ) {
                if ( $1 !~ m{ \A /usr/local/apache/lib/libapr }xms ) {
                    $httpd_not_linked_to_system_apr = 1;
                    last;
                }
            }
        }
    }

    if ( $httpd_not_linked_to_system_apr == 1 ) {
        print_warn('Apache: ');
        print_warning('httpd linked to system APR, not APR in /usr/local/apache/lib/ (see EAL-2551)');
    }
}

sub check_for_custom_postgres_repo {
    my $yum_repos_dir = '/etc/yum.repos.d/';
    my @dir_contents;
    my $has_postgres_repo = 0;

    return if !-d $yum_repos_dir;

    opendir( my $dir_fh, $yum_repos_dir );
    @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
    closedir $dir_fh;

    for my $repos (@dir_contents) {
        if ( $repos =~ m{ \A pgdg-(\d+)-centos\.repo }xms ) {
            $has_postgres_repo = 1;
            last;
        }
    }

    if ( $has_postgres_repo == 1 ) {
        print_warn('PostgreSQL: ');
        print_warning('custom Postgres repo (pgdg-*) found in /etc/yum.repos.d/ . See tickets 3690445, 3568781');
    }
}

sub check_for_rpm_overrides {
    my $rpm_override_dir = '/var/cpanel/rpm.versions.d/';
    my $local_versions   = '/var/cpanel/rpm.versions.d/local.versions';
    my $easy_versions    = '/var/cpanel/rpm.versions.d/easy.versions';
    my $cloud_versions   = '/var/cpanel/rpm.versions.d/cloudlinux.versions';
    my $md5_local;
    my $md5_easy;
    my $md5_cloud;
    my $local_is_default = 0;
    my $easy_is_default  = 0;
    my $cloud_is_default = 0;

    return if !-d $rpm_override_dir;

    if ( -f $local_versions ) {
        $md5_local = timed_run( 0, 'md5sum', $local_versions );
    }

    if ( -f $easy_versions ) {
        $md5_easy = timed_run( 0, 'md5sum', $easy_versions );
    }

    if ( -f $cloud_versions ) {
        $md5_cloud = timed_run( 0, 'md5sum', $cloud_versions );
    }

    ## these are checksums for default files. we ignore them to prevent needless output from SSP
    if (
           $md5_local
        && $md5_local =~ m{ \A (
                                 1d9f5d246ef2c9ab29f33cf00a3af9a5
                               | 352969216e1673edfa8d4ecf189043dc
                               | 41894ce9a0721ed61db14d5e96e630d0
                               | 57baebe121bcd5ab9752dd63f60ecd81
                               | 94f54ec9f5fecf733f0d27b87e5a6c29
                               | a89257469792a846e8db72edd6d29919
                               | a8eca141eda7464bc7c12f3607f5511c
                               | c79a35d2f9633bce58f66b0f1549f4d3
                               | c9da54d8761c2a35f6b93cad4e5f6eac
                               | dd86be82414adad88ada72e791c2fee5
                               | fab8a718f7e3a1ff9c9d04fb4e8c94c4
                               | fd3f270edda79575343e910369b75ab7
                                ) \s }xms
      ) {
        $local_is_default = 1;
    }

    if (
           $md5_easy
        && $md5_easy =~ m{ \A (
                                  350e47b97efd4b75563837b6b3502d71
                                | 5818611cb4c0bf4086806aced5669f25
                                | 600ff436e5939656a5645c6139cc0228
                                | 657d59cc9627d30a95d0b84ef4245185
                                | 89d631ef7c1d43475c20d7be7b7290ff
                                | d56abe76c47853eceb706f0855e642a7
                                | eed54b4202d0b2655f37a5c1edfa0853
                                ) \s }xms
      ) {
        $easy_is_default = 1;
    }

    if (
           $md5_cloud
        && $md5_cloud =~ m{ \A (
                                  956e6d177a790389572c7fcc8b33f8c5
                                | cf40c6ac1543464a937b8c39c4ad1da6
                                ) \s }xms
      ) {
        $cloud_is_default = 1;
    }

    opendir( my $dir_fh, $rpm_override_dir );
    my @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
    closedir $dir_fh;

    if ( $local_is_default == 1 ) {
        @dir_contents = grep { $_ ne 'local.versions' } @dir_contents;
    }

    if ( $easy_is_default == 1 ) {
        @dir_contents = grep { $_ ne 'easy.versions' } @dir_contents;
    }

    if ( $cloud_is_default == 1 ) {
        @dir_contents = grep { $_ ne 'cloudlinux.versions' } @dir_contents;
    }

    ## if the only items in rpm.versions.d/ were defaults that we can ignore, return
    if ( !@dir_contents ) {
        return;
    }

    if (@dir_contents) {
        print_warn('RPM override: ');
        print_warning("$rpm_override_dir contains entries, manually review. More info: http://go.cpanel.net/rpmversions");

        if ( -r $local_versions ) {
            eval { local $SIG{__DIE__}; local $SIG{__WARN__}; require YAML::Syck; };
            if ( !$@ ) {
                my $ref = YAML::Syck::LoadFile($local_versions);
                if ( $ref && $ref->{'target_settings'} ) {
                    foreach my $package ( keys %{ $ref->{'target_settings'} } ) {
                        if ( $ref->{'target_settings'}{$package} =~ m{uninstalled} ) {
                            unless ( $package eq 'easy-tomcat7' ) {    # cPanel lists easy-tomcat7 as uninstalled by default
                                print_warn("$package is listed as uninstalled in $local_versions");
                                print_warning('');
                            }
                        }
                    }
                }
            }
        }
    }
}

sub check_var_cpanel_immutable_files {
    my $immutable_files = '/var/cpanel/immutable_files';

    if ( -e $immutable_files and !-z $immutable_files ) {
        print_warn('immutable files: ');
        print_warning("$immutable_files is not empty!");
    }
}

sub check_for_noxsave_in_grub_conf {
    my $grub_conf   = '/boot/grub/grub.conf';
    my $has_noxsave = 0;

    return if !-f $grub_conf;

    if ( open my $grub_fh, '<', $grub_conf ) {
        while (<$grub_fh>) {
            if (/noxsave/) {
                $has_noxsave = 1;
                last;
            }
        }
        close $grub_fh;
    }

    if ( $has_noxsave == 1 ) {
        print_warn('noxsave: ');
        print_warning("found in ${grub_conf}. kernel panics? segfaults? see ticket 3689211");
    }
}

sub check_for_rpm_dist_ver_unknown {
    my $sysinfo_config = '/var/cpanel/sysinfo.config';
    my $is_broken      = 0;

    return if !-f $sysinfo_config;

    if ( open my $file_fh, '<', $sysinfo_config ) {
        while (<$file_fh>) {
            if (/^rpm_dist_ver=unknown$/) {
                $is_broken = 1;
                last;
            }
        }
        close $file_fh;
    }

    if ( $is_broken == 1 ) {
        print_warn("${sysinfo_config}: ");
        print_warning("contains 'rpm_dist_ver=unknown'. Try running '/scripts/gensysinfo' to fix");
    }
}

sub check_for_homeloader_php_extension {
    return if $EA4;
    return if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER ne 'dso' );

    if ( grep { m# \A ([\s\t]+)? extension ([\s\t]+)? = ([\s\t]+)? ["']? homeloader\.so ['"]? #xms } @PHPINI ) {
        print_warn('/usr/local/lib/php.ini: ');
        print_warning("homeloader.so extension found. This can cause errors. See FB-4471 and FB-63838");
    }
}

sub check_for_networkmanager {
    return if version_compare( $OS_VERSION, qw( >= 7 ) );
    my $networkmanager_running;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A root (?:.*) NetworkManager }xms ) {
            $networkmanager_running = 1;
            last;
        }
    }

    if ( $networkmanager_running && $networkmanager_running == 1 ) {
        print_warn('NetworkManager: ');
        print_warning('found in the process list - see "DisableNetworkManager" wiki article');
    }
}

sub check_for_dhclient {
    my $dhclient_running;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A root (?:.*) dhclient }xms ) {
            $dhclient_running = 1;
            last;
        }
    }

    if ( $dhclient_running && $dhclient_running == 1 ) {
        print_warn('dhclient: ');
        print_warning('found in the process list');
    }
}

sub check_for_var_cpanel_roundcube_install {
    my $install = '/var/cpanel/roundcube/install';

    if ( -f $install and -x $install ) {
        print_warn('RoundCube: ');
        print_warning("$install exists. /u/l/c/b/update-roundcube won't fully run (by design - see the docs)");
    }
}

sub check_for_missing_etc_localtime {
    stat('/etc/localtime');
    if ( !-f _ or !-s _ ) {
        print_warn('/etc/localtime: ');
        print_warning('Missing or empty! Can break many things including upcp and stats (see tickets 3811269, 7092613, 7124961)');
    }
}

sub check_for_perl_env_var {
    if ( exists( $ENV{'PERL5LIB'} ) ) {
        print_warn('PERL5LIB env var: ');
        print_warning('exists! This can break cPanel\'s perl or EasyApache. See FB-64265');
    }
    if ( exists( $ENV{'PERL_MB_OPT'} ) ) {
        print_warn('PERL_MB_OPT env var: ');
        print_warning('exists! This can break cPanel\'s perl or EasyApache.');
    }
    if ( exists( $ENV{'PERL_MM_OPT'} ) ) {
        print_warn('PERL_MM_OPT env var: ');
        print_warning('exists! This can break cPanel\'s perl or EasyApache.');
    }
}

sub check_for_disabled_services {
    my %disabled_services;
    my $disabled;

    my %touchfiles = (
        '/etc/antirelayddisable'                                 => 'antirelayd',
        '/var/cpanel/ssl/disable_auto_hostname_certificate'      => 'auto_hostname_certificate',
        '/etc/rrdtooldisable'                                    => 'rrdtool',
        '/var/run/chkservd.suspend'                              => 'chksrvd',
        '/etc/clamddisable'                                      => 'clamd',
        '/etc/cppopdisable'                                      => 'courier',
        '/etc/popdisable'                                        => 'courier',
        '/etc/cpanellogddisable'                                 => 'cpanellogd',
        '/etc/cpdavddisable'                                     => 'cpdavd',
        '/etc/cpsrvdddisable'                                    => 'cpsrvd',
        '/etc/eximdisable'                                       => 'exim',
        '/etc/exiscandisable'                                    => 'exiscan',
        '/etc/disablehackcheck'                                  => 'hackcheck',
        '/etc/ftpddisable'                                       => 'ftpd',
        '/etc/ftpserverdisable'                                  => 'ftpd',
        '/etc/apachedisable'                                     => 'httpd',
        '/etc/httpddisable'                                      => 'httpd',
        '/etc/httpdisable'                                       => 'httpd',
        '/etc/httpdisevil'                                       => 'httpd',
        '/etc/cpimapdisable'                                     => 'imapd',
        '/etc/imapddisable'                                      => 'imapd',
        '/etc/imapdisable'                                       => 'imapd',
        '/etc/ipaliasesdisable'                                  => 'ipaliases',
        '/etc/mailmandisable'                                    => 'mailman',
        '/etc/mydnsdisable'                                      => 'mydns',
        '/etc/mysqldisable'                                      => 'mysql',
        '/etc/binddisable'                                       => 'named',
        '/etc/dnsdisable'                                        => 'named',
        '/etc/nameddisable'                                      => 'named',
        '/etc/nsddisable'                                        => 'nsd',
        '/etc/postgresdisable'                                   => 'postgresql',
        '/etc/postgresqldisable'                                 => 'postgresql',
        '/etc/postmasterdisable'                                 => 'postgresql',
        '/etc/proftpddisable'                                    => 'proftpd',
        '/etc/pureftpddisable'                                   => 'pureftpd',
        '/etc/pure-ftpddisable'                                  => 'pureftpd',
        '/etc/queueprocddisable'                                 => 'queueprocd',
        '/etc/rsyslogdisable'                                    => 'rsyslogd',
        '/var/cpanel/version/securetmp_disabled'                 => 'securetmp',
        '/var/cpanel/ssl/disable_service_certificate_management' => 'checkallsslcerts',
        '/etc/spamddisable'                                      => 'spamd',
        '/etc/spamdisable'                                       => 'spamd',
        '/etc/sshddisable'                                       => 'sshd',
        '/etc/syslogdisable'                                     => 'syslogd',
        '/etc/tailwatchddisable'                                 => 'tailwatchd',
        '/etc/tomcatdisable'                                     => 'tomcat',
    );

    my %cpconfcheck = (
        'skipcpbandwd'  => 'cpbandwd',
        'skipchkservd'  => 'chkservd',
        'skipeximstats' => 'eximstats',
        'skipmailman'   => 'mailman',
        'skipmodseclog' => 'modseclog',
    );

    while ( my ( $touchfile, $service ) = each(%touchfiles) ) {
        if ( -e $touchfile ) {
            $disabled_services{$service} = 1;
        }
    }

    while ( my ( $skip, $service ) = each(%cpconfcheck) ) {
        if ( $CPCONF{$skip} ) {
            $disabled_services{$service} = 1;
        }
    }

    return if !%disabled_services;

    print_warn('Disabled services: ');
    print_warning( '[ ' . join( ' ', sort( keys(%disabled_services) ) ) . ' ]' );
}

sub check_for_license_info {
    my $host       = 'verify.cpanel.net';
    my $helper_url = "http://" . $host;
    my %license;

    if ( defined($EXTERNAL_IP_ADDRESS) ) {
        my $url = '/?ip=' . $EXTERNAL_IP_ADDRESS;
        $helper_url .= $url;
        my $sock = IO::Socket::INET->new(
            PeerAddr => $host,
            PeerPort => 80,
            Proto    => 'tcp',
            Timeout  => 5,
        ) or return;

        local $SIG{'ALRM'} = sub { return (); };

        alarm 5;
        print $sock "GET ${url} HTTP/1.1\r\nHost: ${host}\r\n\r\n";
        read $sock, my $buffer, 50_000;
        alarm 0;
        close $sock;

        if ( $buffer =~ /alt="cPanel\/WHM"/ ) {
            $license{'cpanel'} = "cPanel";
        }

        if ( $buffer =~ /alt="CloudLinux"/ ) {
            $license{'cloudlinux'} = "CloudLinux";
        }

        if ( $buffer =~ /alt="KernelCare"/ ) {
            $license{'kernelcare'} = "KernelCare";
        }

        if ( $buffer =~ /ONE TIME FEE/ ) {
            $license{'onetime'} = "One-Time";
        }
    }

    if ( my $licenses = join " ", map { "[" . $license{$_} . "]" } sort keys %license ) {
        print_info('License: ');
        print_normal( $EXTERNAL_IP_ADDRESS . ' has ' . $licenses );
    }
    else {
        print_info('License: ');
        print_normal("Not detected - verify at ${helper_url}");
    }

    if ( exists( $license{'onetime'} ) ) {
        print_warn('License: ');
        print_warning("may be a one-time cPanel license -- manually verify at [ ${helper_url} ]");
    }

    if ( ( defined($EXTERNAL_IP_ADDRESS) && defined($EXTERNAL_LICENSE_ADDRESS) ) && !( $EXTERNAL_IP_ADDRESS eq $EXTERNAL_LICENSE_ADDRESS ) ) {
        print_crit('License: ');
        print_critical("external IP detected via port 80 [ ${EXTERNAL_IP_ADDRESS} ] does not match IP detected via port 2089 [ ${EXTERNAL_LICENSE_ADDRESS} ] which can result in unexpected cPanel license update behavior.");
    }

    if ( $IS_CLOUDLINUX && !exists( $license{'cloudlinux'} ) ) {
        print_warn('CloudLinux: ');
        print_warning("MAY NOT BE LICENSED! - verify at ${helper_url} - use \"LICENSE - CloudLinux Not Licensed through cPanel\" if relevant");
    }

    if ( $IS_KERNELCARE && !exists( $license{'kernelcare'} ) ) {
        print_warn('KernelCare: ');
        print_warning("MAY NOT BE LICENSED! - verify at ${helper_url} - use \"LICENSE - CloudLinux Not Licensed through cPanel\" if relevant");
    }

}

# Yes, this actually happened...
sub check_for_cpbackup_exclude_everything {
    my $conf = '/etc/cpbackup-exclude.conf';
    return if ( !-f $conf );

    my $excluding_everything = 0;

    open my $conf_fh, '<', $conf or return;
    while (<$conf_fh>) {
        chomp;
        if (/^\*$/) {
            $excluding_everything = 1;
            last;
        }
    }
    close $conf_fh;

    if ( $excluding_everything == 1 ) {
        print_warn('Backups: ');
        print_warning("'*' exists by itself in $conf . This can cause 0 byte backups");
    }
}

sub check_for_usr_local_include_jpeglib_h {
    my $jpeglib = '/usr/local/include/jpeglib.h';
    if ( -f $jpeglib ) {
        print_warn("$jpeglib: ");
        print_warning('Seeing "Wrong JPEG library version"? This file may be the cause. See ticket 4159697');
    }
}

sub check_for_bw_module_and_more_than_1024_vhosts {
    my $httpdconf = '/usr/local/apache/conf/httpd.conf';
    return if !-f $httpdconf;

    return if ( !grep { /^\sbw_module\s/ } @APACHE_MODULES_OUTPUT );

    my $num_vhosts = 0;

    open my $httpdconf_fh, '<', $httpdconf or return;
    while (<$httpdconf_fh>) {
        if (m{ \A (?:\s+)? <VirtualHost \s }xms) {
            $num_vhosts++;
        }
    }
    close $httpdconf_fh;

    if ( $num_vhosts and $num_vhosts > 1024 ) {
        print_warn('bw_module: ');
        print_warning("loaded, and httpd.conf has >1024 VirtualHosts ($num_vhosts). Apache failing to start? See FB-69121");
    }
}

sub check_for_uppercase_chars_in_hostname {
    if ( $HOSTNAME =~ /[A-Z]/ ) {
        print_warn('Hostname: ');
        print_warning('contains UPPERCASE characters. Seeing incorrect info at cPanel >> Configure Email Client? See ticket 4231465');
    }
}

sub check_for_harmful_php_mode_600_cron {
    return if !-d '/etc/cron.daily';

    my @dir_contents;
    my $has_harmful_cron = 0;
    my $cron_file;

    opendir( my $dir_fh, '/etc/cron.daily' ) or return;
    @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
    closedir $dir_fh;

    for my $file (@dir_contents) {
        $file = '/etc/cron.daily/' . $file;
        open my $file_fh, '<', $file or next;
        while (<$file_fh>) {
            if (/^mytmpfile=\/tmp\/php-mode-/) {
                $has_harmful_cron = 1;
                $cron_file        = $file;
                last;
            }
        }
    }

    if ( $has_harmful_cron == 1 ) {
        print_warn('harmful cron: ');
        print_warning("${cron_file}! Breaks webmail, phpMyAdmin, and more! See tickets 4225765, 4237465, 4099807, 4231469, 4231473. Vendor: http://whmscripts.net/misc/2013/apache-symlink-security-issue-fixpatch/");
    }
}

sub check_for_bad_permissions_on_named_ca {
    my $namedca = '/var/named/named.ca';
    if ( !-e $namedca ) {
        print_warn("${namedca}: ");
        print_warning('missing. named may not start without it');
        return;
    }

    my ( $mode, $uid, $gid ) = ( stat('/var/named/named.ca') )[ 2, 4, 5 ];
    my $world_readable_bit = $mode & 007;
    my $user               = getpwuid($uid);
    my $group              = getgrgid($gid);

    if ( ( $user ne 'named' and $group ne 'named' ) and ( $world_readable_bit == 0 ) ) {
        print_warn("${namedca}: ");
        print_warning('may not be readable to the \'named\' user, causing named to not restart');
    }
}

sub check_for_use_compiled_dnsadmin {
    return if ( defined $CPCONF{'disable_compiled_dnsadmin'} and $CPCONF{'disable_compiled_dnsadmin'} == 1 );

    my $has_custom_dnsadmin_modules;
    my ( @setup_modules, @remote_modules );
    my $setup_modules_dir  = '/usr/local/cpanel/Cpanel/NameServer/Remote';
    my $remote_modules_dir = '/usr/local/cpanel/Cpanel/NameServer/Setup/Remote';

    # http://documentation.cpanel.net/display/SDK/How+to+Write+Setup+Modules
    if ( -d $setup_modules_dir ) {
        opendir( my $dir_fh, $setup_modules_dir );
        @setup_modules = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    # http://documentation.cpanel.net/display/SDK/How+to+Write+Remote+Modules
    if ( -d $remote_modules_dir ) {
        opendir( my $dir_fh, $remote_modules_dir );
        @remote_modules = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    @setup_modules  = grep { !/^(cPanel\.pm|SoftLayer\.pm|VPSNET\.pm)/ } @setup_modules;
    @remote_modules = grep { !/^(cPanel\.pm|SoftLayer\.pm|VPSNET\.pm)/ } @remote_modules;

    # return if there are no custom dnsadmin modules being used
    return if ( scalar @setup_modules == 0 and scalar @remote_modules == 0 );

    print_warn('dnsadmin: ');
    print_warning('Tweak Settings >> Use compiled dnsadmin: On. If problems with custom dnsadmin modules, see if disabling helps (see ticket 4279965)');
}

sub check_for_mysql_root_pass_with_single_quote {
    my $mycnf = '/root/.my.cnf';
    return if !-f $mycnf;

    my $has_single_quote = 0;

    open my $mycnf_fh, '<', $mycnf or return;
    while (<$mycnf_fh>) {
        chomp;
        if (/^(?:[\s\t]?)+pass(?:[^"']+)?=(?:[\s\t]?)+(?:["']?)(.*)(?:["']+)$/) {
            if ( $1 =~ /'/ ) {
                $has_single_quote = 1;
                last;
            }
        }
    }
    close $mycnf_fh;

    if ( $has_single_quote && $has_single_quote == 1 ) {
        print_warn('mysql root user: ');
        print_warning('pass has single quote. This breaks mysql_upgrade! mysql.proc issues? See FB-73533');
    }
}

sub check_for_jailshell_additional_mounts_trailing_slash {
    my $mounts_file = '/var/cpanel/jailshell-additional-mounts';
    return if ( !-f $mounts_file );

    my $has_slash = 0;

    if ( open my $file_fh, '<', $mounts_file ) {
        while (<$file_fh>) {
            chomp;
            if (m#/(?:[\s\t]+)?\z#) {
                $has_slash = 1;
                last;
            }
        }
        close $file_fh;
    }
    else {
        return;
    }

    if ( $has_slash == 1 ) {
        print_warn("$mounts_file: ");
        print_warning('contains trailing slashes! Server may become unstable. See FB-71613');
    }
}

sub check_for_allow_query_localhost {
    my $named_conf = '/etc/named.conf';
    return if !-f $named_conf;

    my $allow_query_localhost = 0;

    my $namedconf_contents;
    if ( open my $named_conf_fh, '<', $named_conf ) {
        local $/;
        $namedconf_contents = <$named_conf_fh>;
        close $named_conf_fh;
    }
    else {
        return;
    }

    if ( $namedconf_contents =~ m#allow-query ([\s\t\r\n]+)? { ([\s\t]+)? ( localhost | 127\. )#xms ) {
        $allow_query_localhost = 1;
    }

    if ( $allow_query_localhost == 1 ) {
        print_warn('named.conf: ');
        print_warning('allow-query is restricted to localhost. Remote DNS queries may not work');
    }
}

sub check_for_nocloudlinux_touchfile {
    if ( -e '/var/cpanel/nocloudlinux' ) {
        print_warn('/var/cpanel/nocloudlinux: ');
        print_warning('exists! CloudLinux cannot be installed when this file is present.');
    }
}

sub check_for_mysql_upgrade_touchfile {
    return if cpanel_version_is(qw( >= 11.46.1.0 ));
    if ( -e '/var/cpanel/mysql_upgrade_in_progress' ) {
        print_warn('/var/cpanel/mysql_upgrade_in_progress: ');
        print_warning('exists! See FB-113349.');
    }
}

sub check_for_stupid_touchfile {
    return if !-e '/etc/allowstupidstuff';
    print_warn('/etc/allowstupidstuff: ');
    print_warning('exists! Can allow usernames to be created that begin with digits.');
}

sub check_for_dev_sandbox {
    return if !-e '/var/cpanel/dev_sandbox';
    print_warn('/var/cpanel/dev_sandbox: ');
    print_warning('exists! Should NEVER exist on production servers.');
}

sub check_for_jail_owner {
    return if !-e '/jail_owner';
    print_warn('/jail_owner: ');
    print_warning('exists! Should NEVER exist outside of jailshell.  Will cause Exim mail delivery issues.');
}

sub check_for_phphandler_and_opcode_caching_incompatibility {
    return if $EA4;
    return if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER ne 'suphp' );

    my $message;

    if ( grep { m# \A ([\s\t]+)? extension ([\s\t]+)? = ([\s\t]+)? ["']? eaccelerator\.so ['"]? #xms } @PHPINI ) {
        $message .= '[eAccelerator] ';
    }
    if ( grep { m# \A ([\s\t]+)? extension ([\s\t]+)? = ([\s\t]+)? ["']? xcache\.so ['"]? #xms } @PHPINI ) {
        $message .= '[XCache] ';
    }
    if ( grep { m# \A ([\s\t]+)? extension ([\s\t]+)? = ([\s\t]+)? ["']? apc\.so ['"]? #xms } @PHPINI ) {
        $message .= '[APC] ';
    }

    if ($message) {
        print_warn('PHP: ');
        print_warning("suPHP enabled, but the following installed opcode cachers are not suPHP compatible: $message");
    }
}

sub check_for_invalid_HOMEDIR {
    my $wwwacctconf = '/etc/wwwacct.conf';

    return if !-f $wwwacctconf;

    my $homedir;

    if ( open my $file_fh, '<', $wwwacctconf ) {
        while (<$file_fh>) {
            if (/\AHOMEDIR[\s\t]+([^\s]+)/) {
                $homedir = $1;
                last;
            }
        }
        close $file_fh;
    }

    if ( !$homedir ) {
        print_warn("$wwwacctconf: ");
        print_warning('HOMEDIR value not found!');
    }
    else {
        if ( !-d $homedir ) {
            print_warn("$wwwacctconf: ");
            print_warning("the directory that is specified as the HOMEDIR does not exist! ($homedir)");
        }
    }
}

sub check_for_unsupported_options_in_phpini {    # FB-75397
    return if $EA4;
    return if !$EA3_PHP5VERSION;

    my ( undef, $php5minor ) = split /\./, $EA3_PHP5VERSION;
    return if ( !$php5minor || $php5minor <= 3 );

    my $unsupported_options;

    ## http://www.php.net/manual/en/migration54.ini.php
    ## apparently "safe_mode = off" won't trigger 75397, but "safe_mode = on" will.
    ## some items like "y2k_compliance = On" don't appear to trigger the issue
    if ( grep { m# \A (?:[\s\t]+)? register_globals (?:[\s\t]+)? = (?:[\s\t]+)? ["']? on ['"]? #ixms } @PHPINI ) {
        $unsupported_options .= "[register_globals] ";
    }

    if ( grep { m# \A (?:[\s\t]+)? safe_mode (?:[\s\t]+)? = (?:[\s\t]+)? ["']? on ['"]? #ixms } @PHPINI ) {
        $unsupported_options .= "[safe_mode] ";
    }

    if ($unsupported_options) {
        $unsupported_options =~ s/\s$//g;
        print_warn('/usr/local/lib/php.ini: ');
        print_warning("PHP $EA3_PHP5VERSION does not support $unsupported_options, but found enabled in php.ini. See FB-75397");
    }
}

sub check_for_suphp_but_no_fileprotect {
    return if $EA4;
    if ( $EA3_PHP5HANDLER and $EA3_PHP5HANDLER eq 'suphp' ) {
        if ( !-e '/var/cpanel/fileprotect' ) {
            print_warn('suPHP: ');
            print_warning("enabled, but /var/cpanel/fileprotect not found. New users' public_htmls will be user:user");
        }
    }
}

sub check_for_assp_hates_appconfig_cron {
    return if !-f '/var/spool/cron/root';

    my $has_bad_assp_cron = 0;

    open my $cron_fh, '<', '/var/spool/cron/root';
    while (<$cron_fh>) {
        if (m{ /usr/local/cpanel/3rdparty/bin/php-cgi \s /usr/local/assp/deluxe/ex_localdomains.php }xms) {
            $has_bad_assp_cron = 1;
            last;
        }
    }
    close $cron_fh;

    if ( $has_bad_assp_cron == 1 ) {
        print_warn('ASSP: ');
        print_warning('this software uses a cron job which breaks cPanel\'s AppConfig. See 4394109, 4392691. Complain to vendor (grscripts.com)');
    }
}

sub check_for_missing_var_cpanel_dynamicui_ftp {
    if ( !-e '/etc/ftpddisable' and !-e '/etc/ftpserverdisable' and !-e '/var/cpanel/dynamicui/ftp' ) {
        print_warn('FTP: ');
        print_warning('touchfile /v/c/dynamicui/ftp appears to be missing. FTP options may not appear in cPanel. See FB-83193');
    }
}

sub check_if_backup_dir_is_nfs {
    my $old_backups_dir;
    my $new_backups_dir;
    my $cpbackup_conf;
    my $config;
    my $old_backups_dir_nfs = 0;
    my $new_backups_dir_nfs = 0;

    if ( -e '/etc/cpbackup.conf' ) {
        open my $file_fh, '<', '/etc/cpbackup.conf';
        while (<$file_fh>) {
            local $/;
            $cpbackup_conf = <$file_fh>;
        }
        close $file_fh;
    }

    if ( -e '/var/cpanel/backups/config' ) {
        open my $file_fh, '<', '/var/cpanel/backups/config';
        while (<$file_fh>) {
            local $/;
            $config = <$file_fh>;
        }
        close $file_fh;
    }

    if ( $cpbackup_conf and $cpbackup_conf =~ /BACKUPENABLE yes/ and $cpbackup_conf =~ /BACKUPDIR (.*)/ ) {
        $old_backups_dir = $1;
    }

    if ( $config and $config =~ /BACKUPENABLE: 'yes'/ and $config =~ /BACKUPDIR: (.*)/ ) {
        $new_backups_dir = $1;
    }

    my @mount;

    open my $mount_fh, '-|', '/bin/mount' or return;
    while (<$mount_fh>) {
        chomp;
        push @mount, $_;
    }
    close $mount_fh;

    for my $mount (@mount) {
        if ($old_backups_dir) {
            if ( $mount =~ /$old_backups_dir type nfs / ) {
                $old_backups_dir_nfs = 1;
            }
        }
        if ($new_backups_dir) {
            if ( $mount =~ /$new_backups_dir type nfs / ) {
                $new_backups_dir_nfs = 1;
            }
        }
    }

    if ( $old_backups_dir_nfs == 1 ) {
        print_warn('Backups: ');
        print_warning("$old_backups_dir is NFS (used by old backup system)");
    }
    if ( $new_backups_dir_nfs == 1 ) {
        print_warn('Backup: ');
        print_warning("$new_backups_dir is NFS (used by new backup system)");
    }
}

sub check_if_hostname_missing_from_localdomains {
    my $hostname_check = 0;

    open my $localdomains_fh, '<', '/etc/localdomains';
    while (<$localdomains_fh>) {
        if (/^${HOSTNAME}$/) {
            $hostname_check = 1;
            last;
        }
    }
    close $localdomains_fh;

    if ( $hostname_check == 0 ) {
        print_warn('Hostname: ');
        print_warning('not found in /etc/localdomains. This can cause "lowest numbered MX record points to local host"');
    }
}

sub check_for_eximstats_newline {
    my $eximstatspass = '/var/cpanel/eximstatspass';
    my $has_newline   = 0;

    if ( !-e $eximstatspass ) {
        print_warn("$eximstatspass: ");
        print_warning('missing!');
    }
    else {
        if ( open my $eximstatspass_fh, '<', $eximstatspass ) {
            while (<$eximstatspass_fh>) {
                if (/\n/) {
                    $has_newline = 1;
                    last;
                }
            }
            close $eximstatspass_fh;
        }
    }

    if ( $has_newline == 1 ) {
        print_warn("$eximstatspass: ");
        print_warning('contains a newline. Breaks Mail Delivery Reports / eximstats');
    }

}

sub check_for_nfs {
    my $has_nfs = 0;

    open my $mount_fh, '-|', '/bin/mount' or return;
    while (<$mount_fh>) {
        if (m{ type[ \t] nfs [ \t] }xms) {
            $has_nfs = 1;
            last;
        }
    }
    close $mount_fh;

    if ( $has_nfs == 1 ) {
        print_warn('NFS: ');
        print_warning('filesystem(s) with NFS detected. This can cause cPanel to load slowly (see ticket 4380977, FB-79549)');
    }
}

sub check_for_processes_killed_by_lfd {
    my $log = '/var/log/lfd.log';
    return if !-e $log;

    my $size = ( stat($log) )[7];
    return if !$size;

    my $bytes_to_check = 20_971_520 / 2;    # 10M
    my $seek_position  = 0;
    my $log_data;
    my @logs;
    my $count = 0;
    my @killed_by_lfd;

    if ( $size > $bytes_to_check ) {
        $seek_position = ( $size - $bytes_to_check );
    }

    open my $file_fh, '<', $log or return;
    seek $file_fh, $seek_position, 0;
    read $file_fh, $log_data, $bytes_to_check;
    close $file_fh;

    if ( $log_data =~ /\sKill:1\s/ ) {
        @logs = split /\n/, $log_data;
        undef $log_data;
        @logs = reverse @logs;

        for my $line (@logs) {
            if ( $line =~ /(.*?)[ \t]+\*User Processing\*[ \t]+(.*?)[ \t]+CMD:(.*)/ ) {
                my $header   = $1;
                my %keypairs = map { ( split( m{:}, $_, 2 ) )[ 0, 1 ] } split( m{[ \t]+}, $2 );
                my $cmd      = $3;
                next if $keypairs{"Kill"} == "0";
                push @killed_by_lfd, "[$header] " . join( " ", ( map { "[$_: $keypairs{$_}]" } sort keys %keypairs ) ) . " [cmd: $cmd]\n";
                $count++;
            }
            last if $count >= 20;
        }
    }

    if (@killed_by_lfd) {
        chomp @killed_by_lfd;
        print_warn("Last 20 processes killed by 3rd party software \"LFD\" (\"grep Kill:1 /var/log/lfd.log\"):\n");
        for my $killed_process (@killed_by_lfd) {
            print_magenta("\t \\_ $killed_process");
        }
    }
}

sub check_for_processes_killed_by_oom {
    my $log = "/var/log/messages";
    return unless -e $log;
    my $bytes_to_check = 10485760;
    my $size           = ( stat($log) )[7];
    return unless defined $size;
    my $seek_position = 0;
    if ( $size > $bytes_to_check ) {
        $seek_position = ( $size - $bytes_to_check );
    }
    my $log_data = undef;
    my @logs;
    my $count         = 0;
    my @killed_by_oom = ();

    open my $file_fh, '<', $log or return;
    seek $file_fh, $seek_position, 0;
    read $file_fh, $log_data, $bytes_to_check;
    close $file_fh;

    if ( $log_data =~ /[Kk]illed process/ ) {
        @logs = split /\n/, $log_data;
        undef $log_data;
        @logs = reverse @logs;

        for my $line (@logs) {

            # CloudLinux 6 LVE OOM, Virtuozzo + CentOS 6 OOM
            if ( $line =~ /([[:alpha:]]{3}(?: \d\d|  \d) \d\d:\d\d:\d\d) (?:.*) kernel: \[ *\d*\.\d{6}\] Out of memory in UB (\d*): OOM killed process (\d*) \((.*)\) score \d* vm:(\d*)kB, rss:(\d*)kB, swap:(\d*)kB/ ) {
                push @killed_by_oom, "[$1] [pid: $3] [cmd: $4] [LVE ID: $2] [vm: $5 kB] [rss: $6 kB] [swap: $7 kB]";
                $count++;
                last if $count >= 10;
            }

            if ( $line =~ /([[:alpha:]]{3}(?: \d\d|  \d) \d\d:\d\d:\d\d) (?:.*?) kernel: \[ *\d*\.\d{6}\] Out of memory: OOM killed process (\d*?) \((.*?)\) score \d* vm:(\d*)kB, rss:(\d*)kB, swap:(\d*)kB/ ) {
                push @killed_by_oom, "[$1] [pid: $2] [cmd: $3] [vm: $4 kB] [rss: $5 kB] [swap: $6 kB]";
                $count++;
                last if $count >= 10;
            }

            # CentOS 6
            if ( $line =~ /([[:alpha:]]{3}(?: \d\d|  \d) \d\d:\d\d:\d\d) (?:.*) kernel: \[ *\d*\.\d{6}\] Killed process (\d+) \((.*?)\) total-vm:(\d+)kB, anon-rss:(\d+)kB, file-rss:(\d+)kB/ ) {
                push @killed_by_oom, "[$1] [pid: $2] [cmd: $3] [vm: $4 kB] [rss: $5 kB] [swap: $6 kB]";
                $count++;
                last if $count >= 10;
            }

            # CentOS 7
            if ( $line =~ /([[:alpha:]]{3}(?: \d\d|  \d) \d\d:\d\d:\d\d) (?:.*?) kernel: Killed process (\d*) \((.*)\) total-vm:(\d*?)kB, anon-rss:(\d*?)kB, file-rss:(\d*?)kB/ ) {
                push @killed_by_oom, "[$1] [pid: $2] [cmd: $3] [vm: $4 kB] [rss: $5 kB] [swap: $6 kB]";
                $count++;
                last if $count >= 10;
            }

            # CloudLinux 7
            # Feb  6 08:52:43 lin02 kernel: Killed process 22541 (php) in VE "0" total-vm:357304kB, anon-rss:77080kB, file-rss:11116kB
            if ( $line =~ /([[:alpha:]]{3} (?:\d\d| \d) \d\d:\d\d:\d\d) (?:.*?) kernel: Killed process (\d*) \((.*?)\) in VE "(\d*)" total-vm:(\d*)kB, anon-rss:(\d*)kB, file-rss:(\d*)kB$/ ) {
                push @killed_by_oom, "[$1] [pid: $2] [cmd: $3] [LVE ID: $4] [vm: $5 kB] [rss: $6 kB] [swap: $7 kB]";
                $count++;
                last if $count >= 10;
            }
        }

        if (@killed_by_oom) {
            print_warn("Last $count processes killed by Linux Out of memory killer (grep -i \"Out of memory\" /var/log/messages):\n");
            for my $killed_process (@killed_by_oom) {
                print_magenta("\t \\_ $killed_process");
            }
        }
    }
}

sub check_for_processes_killed_by_prm {
    my @logfiles = qw( /usr/local/prm/prm_log /usr/local/prm/log_prm /usr/local/prm/logs/prm.log );
    for my $log (@logfiles) {
        next if -l $log;
        next if !-f $log;
        my $size = ( stat($log) )[7];
        next if !$size;

        my $bytes_to_check = 10485760;    # 10M
        my $seek_position  = 0;
        my $log_data       = undef;
        my @logs;
        my $count         = 0;
        my @killed_by_prm = ();

        if ( $size > $bytes_to_check ) {
            $seek_position = ( $size - $bytes_to_check );
        }

        open my $file_fh, '<', $log or return;
        seek $file_fh, $seek_position, 0;
        read $file_fh, $log_data, $bytes_to_check;
        close $file_fh;

        if ( $log_data =~ /\sKILLED\s/ ) {
            @logs = split /\n/, $log_data;
            undef $log_data;
            @logs = reverse @logs;

            for my $line (@logs) {
                if ( $line =~ /(\S+\s\d+\s\S+)\s(?:\S+)\s(?:\S+) proc pid:(?:\d+) \{user:(\S+) cmd:(\S+)\}.+(MAX_.+) KILLED/ ) {
                    push @killed_by_prm, "[$1] [user: $2] [cmd: $3] [$4]";
                    $count++;
                }

                last if $count >= 10;
            }
        }
        if (@killed_by_prm) {
            print_warn( "Last 10 processes killed by 3rd party software \"PRM\" (\"grep KILLED " . $log . "\"):\n" );
            for my $killed_process (@killed_by_prm) {
                print_magenta("\"\t \\_ $killed_process\"");
            }
        }
    }
}

sub check_for_broken_userdatadomains {
    return if !-f '/etc/userdatadomains';

    my $is_broken = 0;

    open my $userdatadomains_fh, '<', '/etc/userdatadomains' or return;
    while (<$userdatadomains_fh>) {
        if (/^:/) {
            $is_broken = 1;
            last;
        }
    }
    close $userdatadomains_fh;

    if ( $is_broken == 1 ) {
        print_warn('/etc/userdatadomains: ');
        print_warning('contains a line that begins with ":". Check the following for accuracy (see 4416539 for examples):');
        print_magenta("\t \\_ /etc/userdatadomains");
        print_magenta("\t \\_ /var/cpanel/users/USER (check the ^DNS= lines)");
        print_magenta("\t \\_ /var/cpanel/userdata/USER/main (check for things like '')");
        print_magenta("\t \\_ /var/cpanel/userdata/USER/DOMAIN (check serveralias line)");
        print_magenta("\t \\_ /var/cpanel/userdata/USER/cache (userdatadomains uses this)");
        print_magenta("\t \\_ /usr/local/apache/conf/httpd.conf (may need rebuilding after fixing userdata)");
    }
}

sub check_ssl_db_perms {
    my $ssldb = '/var/cpanel/ssl/installed/ssl.db';
    return if !-e $ssldb;

    my ( $uid, $gid ) = ( stat($ssldb) )[ 4, 5 ];
    if ( $uid != 0 or $gid != 0 ) {
        print_warn("$ssldb: ");
        print_warning('not owned by the root user and/or group. This can prevent pkgacct from completing. See ticket 4422237');
    }
}

sub check_for_nat_plus_mod_evasive {
    my $cpnat = '/var/cpanel/cpnat';
    return if !-e $cpnat;
    return if ( stat($cpnat) )[7] == 0;

    my $has_mod_evasive = 0;

    for my $module (@APACHE_MODULES_OUTPUT) {
        if ( $module =~ /evasive20_module/ ) {    # Apache 1.x = evasive_module :: Apache 2.x = evasive20_module
            $has_mod_evasive = 1;
            last;
        }
    }

    if ( $has_mod_evasive == 1 ) {
        print_warn('mod_evasive: ');
        print_warning('this 3rd party Apache module is loaded, and the server is using NAT. May cause random 403s. See ticket 4416847');
    }
}

sub check_for_stray_index_php {
    my $indexphp = '/usr/local/cpanel/base/index.php';
    if ( -e $indexphp ) {
        print_warn("$indexphp: ");
        print_warning("exists! Errors when logging into cPanel? See ticket 4421775");
    }
}

sub check_for_port_80_not_apache {
    my ( $filename, $pid, $cmdline );
    my $unknown_httpd = 0;

    return if !@LSOF_80;
    return if scalar @LSOF_80 < 2;

    for my $line (@LSOF_80) {
        if ( $line =~ m{ \A (\S+) \s+ (\d+) (?:.*) \(LISTEN\) }xms ) {
            ( $filename, $pid ) = ( $1, $2 );
            last;
        }
    }

    return if !$filename or !$pid;

    my $exe = readlink "/proc/${pid}/exe" or return;
    my $cwd = readlink "/proc/${pid}/cwd" or return;

    if ( $exe ne '/usr/local/apache/bin/httpd' && $exe ne '/usr/sbin/httpd' ) {
        $unknown_httpd = 1;

        open my $file_fh, '<', "/proc/${pid}/cmdline" or return;
        $cmdline = readline $file_fh;
        close $file_fh;

        return if !$cmdline;
        $cmdline =~ s/\0/ /g;
        $cmdline =~ s/(\s+)$//g;
    }

    return if !$unknown_httpd;

    my $ipcs = timed_run( 0, 'ipcs', '-m' );

    print_warn('Port 80: ');

    print_warning("something other than Apache is running:");
    print_magenta("\t \\_ file [$filename]");
    print_magenta("\t \\_ exe  [$exe]");
    print_magenta("\t \\_ cmd  [$cmdline]");
    print_magenta("\t \\_ cwd  [$cwd]");

    if ( $ipcs =~ /nobody/ ) {
        print_magenta($ipcs);
    }
}

sub check_for_missing_groups {
    my @groups = qw(
      cpanel
      cpaneleximfilter
      cpaneleximscanner
      cpanellogin
      cpanelphpmyadmin
      cpanelphppgadmin
      cpanelroundcube
      mail
      mailman
      mailnull
      mailtrap
      mysql
      named
      nobody
      root
      sshd
      wheel
    );

    push @groups, 'cpses'           if cpanel_version_is(qw( >= 11.39.0.0 ));    # Added in 11.40?
    push @groups, 'cpanellogaholic' if cpanel_version_is(qw( < 11.47.0.0 ));     # Removed in 11.48
    push @groups, 'cpanelhorde'     if cpanel_version_is(qw( < 11.49.0.0 ));     # Removed in 11.50

    my $missing_groups;

    for my $group (@groups) {
        my $gid = getgrnam($group);
        next if ( defined $gid and $gid =~ /^\d+$/ );
        $missing_groups .= "[$group] ";
    }

    if ($missing_groups) {
        print_warn('Missing groups: ');
        print_warning($missing_groups);
    }
}

sub check_for_noquotafs {
    my $noquotafs = '/var/cpanel/noquotafs';
    return if !-f $noquotafs or -z $noquotafs;

    print_warn("$noquotafs: ");
    print_warning('exists. quota issues? See https://documentation.cpanel.net/pages/viewpage.action?pageId=1507750');
}

sub check_for_mod_rpaf {
    if ( grep { /rpaf_module/ } @APACHE_MODULES_OUTPUT ) {
        print_warn('mod_rpaf: ');
        print_warning('loaded. May prevent .htaccess from denying access. See 4422297');
    }
}

sub check_for_mod_spdy {
    if ( grep { /spdy_module/ } @APACHE_MODULES_OUTPUT ) {
        print_warn('mod_spdy: ');
        print_warning('loaded. May break proxy subdomains. See 4973361');
    }
}

sub check_for_mod_http2 {
    if ( version_compare( $APACHE_VERSION, qw ( == 2.4.25 ) ) && grep { /http2_module/ } @APACHE_MODULES_OUTPUT ) {
        print_warn('mod_http2: ');
        print_warning('is loaded and causes segfaults in Apache 2.4.25, see EAL-3153.');
    }
}

sub check_for_roundcube_overlay {
    my $rcdir = '/var/cpanel/roundcube';
    return if !-d $rcdir;

    opendir( my $dh, $rcdir );
    my @contents = grep { !/^\.\.?$/ } readdir $dh;
    close $dh;

    if ( grep { /^overlay/ } @contents ) {
        print_warn('Roundcube overlay: ');
        print_warning("found an overlay file in $rcdir . Login issues? See ticket 4542785.");
    }
}

sub check_for_hostname_park_zoneexists {
    if ( -f "/var/named/${HOSTNAME}.db" and ( not defined $CPCONF{'allowparkonothers'} or $CPCONF{'allowparkonothers'} != 1 ) ) {
        print_warn('Parking: ');
        print_warning('since zone of hostname exists, "Allow domain parking across accounts" must be ON to park on the hostname');
    }
}

sub check_for_pgpass_colon_in_password_field {
    my $pgpass = '/root/.pgpass';
    return if !-f $pgpass;

    my $has_colon = 0;

    if ( open my $fh, '<', $pgpass ) {
        while (<$fh>) {
            if (/^\*:\*:\*:postgres:(.*)/) {
                if ( $1 =~ /:/ ) {
                    $has_colon = 1;
                    last;
                }
            }
        }
        close $fh;
    }

    if ( $has_colon == 1 ) {
        print_warn("$pgpass: ");
        print_warning('password field contains a colon. Seeing Postgres auth issues? See FB-89093');
    }
}

sub check_for_dirs_that_break_ea {
    my @dirs = qw(
      /usr/local/cpanel/cgi-sys/php5
      /var/cpanel/conf/apache/wrappers/php5
    );

    for my $dir (@dirs) {
        if ( -d $dir ) {
            print_warn("$dir: ");
            print_warning('is a directory! This can cause EA issues. See ticket 4537779.');
        }
    }
}

sub check_for_extra_uid_0_user {
    my $uid_0_user;

    open my $file_fh, '<', '/etc/passwd' or die $!;
    while (<$file_fh>) {
        if (m{ \A ([^:]+) :x:0: }xms) {
            next if $1 =~ m{ \A root \z }xms;
            $uid_0_user = $1;
            last;
        }
    }
    close $file_fh;

    if ( defined($uid_0_user) ) {
        my $uid_0_user_info = "non-root UID 0 user found: [ " . $uid_0_user . " ]";
        for my $pid ( keys(%$PROCESS_REF) ) {
            if ( $PROCESS_REF->{$pid}->{CMD} =~ m{bin/nscd(\s|$)} ) {
                print_warn($uid_0_user_info);
                print_warning(" -- and nscd is running! This can break things. See CPANEL-2360.");
                return;
            }
        }
        print_warn( $uid_0_user_info . "\n" );
    }
}

sub check_for_easyparams_attributes {
    my $easyparams = '/scripts/easyparams';
    return if !-e $easyparams;

    my $attributes = timed_run( 0, 'lsattr', $easyparams );
    if ( $attributes =~ m/^-[-]*(?:a|i)/ ) {
        print_warn("$easyparams: ");
        print_warning('is immutable or append only. This should never be done, and can break EasyApache!');
    }
}

sub check_for_stale_backup_pidfile {
    return if cpanel_version_is(qw( >= 11.50.1 ));    # FB-82849
    my @pidfiles = qw(
      /var/cpanel/backuprunning
      /var/cpanel/new_backuprunning
    );

    my $found_pid     = 0;
    my $found_process = 0;

    for my $pidfile (@pidfiles) {
        my $pid;

        if ( -s $pidfile ) {
            open my $fh, '<', $pidfile or return;
            chomp( $pid = readline $fh );
            close $fh;

            for my $process (@PROCESS_LIST) {
                if ( $process =~ / \A [^ ]+ \s+ $pid \s+ (.*) /xms ) {
                    $found_pid = 1;
                    if ( ( $pidfile eq '/var/cpanel/backuprunning' ) && ( $process =~ m# (/usr/local/cpanel)?/scripts/cpbackup(\s|$)# ) ) {
                        $found_process = 1;
                        last;
                    }
                    if ( ( $pidfile eq '/var/cpanel/new_backuprunning' ) && ( $process =~ m# /usr/local/cpanel/bin/backup(\s|$)# ) ) {
                        $found_process = 1;
                        last;
                    }
                }
            }

            if ( $found_pid == 1 and $found_process == 0 ) {
                print_warn('Backups: ');
                print_warning("pid $pid from $pidfile does not match a valid backup process");
            }
        }
    }
}

sub check_for_allow_update_in_named_conf {
    my $namedconf = '/etc/named.conf';
    return if !-e $namedconf;

    my $has_allow_update = 0;

    if ( open my $fh, '<', $namedconf ) {
        while (<$fh>) {
            if (/allow-update/i) {
                $has_allow_update = 1;
                last;
            }
        }
        close $fh;
    }

    if ( $has_allow_update == 1 ) {
        print_warn('named.conf: ');
        print_warning('allow-update found. This can possibly prevent rndc from reloading. See ticket 4717591');
    }
}

sub check_for_mpm_itk_and_suexec {
    return if $EA4;
    return unless $APACHE_PER_USER eq "itk";
    return unless $EA3_SUEXEC;

    print_warn('MPM ITK: ');
    print_warning('enabled with suEXEC. This can break redirects like /cpanel. See FB-83405.');
}

sub check_for_modruid2_warnings {
    if ( $APACHE_PER_USER eq "ruid2" ) {
        if ( defined $CPCONF{'jailapache'} && $CPCONF{'jailapache'} == 1 ) {
            print_warn('Mod Ruid2: ');
            print_warning('is enabled with Jail Apache Virtual Hosts tweak, this might break Mailman, see FB-84393, FB-104017, and tickets 5015613, 5227891');
            if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER eq 'suphp' ) {
                print_warn('Mod Ruid2: ');
                print_warning('is enabled with Jail Apache Virtual Hosts tweak and suPHP handler, these are NOT COMPATIBLE, see FB-70561, FB-105901');
            }
        }
        if ($LSWS_FULL_VERSION) {
            print_warn('Mod Ruid2: ');
            print_warning('could cause file permission problems when using LiteSpeed Web Server (see ticket 5154193)');
        }
    }
}

sub check_for_modsec2_stage_files {
    return if ( !-e "/usr/local/apache/conf/modsec2.user.conf.STAGE" );
    print_warn('Mod Security: ');
    print_warning('/usr/local/apache/conf/modsec2.user.conf.STAGE exists -- This may prevent editing of rules in WHM ModSecurity Tools.');
}

sub check_for_cron_allow {
    my $warn       = 0;
    my $cron_allow = "/etc/cron.allow";
    my $cron_deny  = "/etc/cron.deny";

    $warn = 1 if -e $cron_allow;
    if ( -s $cron_deny ) {

        # By default /etc/cron.deny can contain the "nobody" user.  Checking the contents can be expensive, size will do.
        my $cron_deny_size     = ( stat($cron_deny) )[7];
        my $cron_deny_max_size = 8;
        if ( $cron_deny_size > $cron_deny_max_size ) {
            print_warn('crontab: ');
            print_warning( $cron_deny . ' is > ' . $cron_deny_max_size . ' bytes, may contain users other than "nobody".  A user listed here cannot see or edit cron jobs in the cPanel UI.' );
        }
    }

    if ( -e $cron_allow ) {
        print_warn('crontab: ');
        print_warning('/etc/cron.allow exists. Any user NOT listed cannot see or edit cron jobs in the cPanel UI.');
    }
}

sub check_for_openssl_heartbleed_bug {
    return if !$OPENSSL_RPM_CHANGELOG;
    my $sysinfo_config = '/var/cpanel/sysinfo.config';
    return if !-f $sysinfo_config;

    my $rpm_dist_ver;

    open my $fh, '<', $sysinfo_config or return;
    while (<$fh>) {
        if (/^rpm_dist_ver=(\d+)$/) {
            $rpm_dist_ver = $1;
            last;
        }
    }
    close $fh or return;

    return if !$rpm_dist_ver;
    return if ( $rpm_dist_ver <= 5 );    # RHEL/CentOS 5 not vuln: http://cpanel.net/heartbleed-vulnerability-information/

    chomp( my $openssl_ver = timed_run( 0, 'openssl', 'version' ) );
    return if !$openssl_ver;

    # only 1.0.1[a-f] is vuln (and 1.0.2-beta which no one should be using)
    if ( $openssl_ver =~ /^OpenSSL (\d+)\.(\d+)\.(\d+)[a-f]/ ) {
        my ( $maj, $min, $patch ) = ( $1, $2, $3 );
        return if $maj != 1;
        return if $min != 0;
        return if $patch != 1;
    }
    else {
        return;
    }

    return if $OPENSSL_RPM_CHANGELOG =~ m{ \sCVE-2014-0160\s }xms;

    print_critical();
    print_crit('Heartbleed: ');
    print_critical('Send customer this premade: SECURITY - OpenSSL Heartbleed Vulnerability - Discovery');
    print_critical('The following check was used: rpm -q --changelog openssl | grep \' CVE-2014-0160 \'');
    print_critical('!! VERIFY THE CHECK USING THE COMMAND ABOVE BEFORE SENDING THE PREMADE !!');
    print_critical('This check does NOT take corrupt RPM dbs into account, and CAN report false-positive results if corrupt');
    print_critical();
}

sub check_for_openssl_secadv_20140605 {
    return if !$OPENSSL_RPM_CHANGELOG;
    my $sysinfo_config = '/var/cpanel/sysinfo.config';
    return if !-f $sysinfo_config;

    my $rpm_dist_ver;

    open my $fh, '<', $sysinfo_config or return;
    while (<$fh>) {
        if (/^rpm_dist_ver=(\d+)$/) {
            $rpm_dist_ver = $1;
            last;
        }
    }
    close $fh or return;

    return if !$rpm_dist_ver;
    return if ( $rpm_dist_ver < 5 || $rpm_dist_ver > 6 );    # Only RHEL/CentOS 5 and 6 need apply

    chomp( my $openssl_ver = timed_run( 0, 'openssl', 'version' ) );
    return if !$openssl_ver;

    # fixed in openssl 1.0.1h, 1.0.0m, and 0.9.8za
    if ( $openssl_ver =~ /^OpenSSL (\d+)\.(\d+)\.(\d+)([a-z])([a-z]?)/ ) {
        my ( $maj, $min, $patch ) = ( $1, $2, $3 );

        # If we map the alphas into a number and sum the values the version will be compatible with version_compare() and save us a lot of trouble, i.e. h=8, m=13, and za=27
        my %al2num = map { ( "a" .. "z" )[ $_ - 1 ] => $_ } ( 1 .. 26 );    # Isn't there a better way to do this?
        my $sub = 0;
        if ($4) { $sub += $al2num{ lc($4) } }
        if ($5) { $sub += $al2num{ lc($5) } }
        my $ver = join( '.', $maj, $min, $patch, $sub );
        return if version_compare( $ver, qw( >= 1.0.1.8 ) );                # If > 1.0.1h we're done.
        return if ( version_compare( $ver, qw( < 1.0.1.0 ) ) && version_compare( $ver, qw( >= 1.0.0.13 ) ) );    # If < 1.0.1 and >= 1.0.0m we're done.
        return if ( version_compare( $ver, qw( < 0.9.9.0 ) ) && version_compare( $ver, qw( >= 0.9.8.27 ) ) );    # If < 0.9.9 and >= 0.9.8za we're done.
    }

    return if ( $OPENSSL_RPM_CHANGELOG =~ m{ \sCVE-2014-0224\s }xms );

    print_critical();
    print_crit('OpenSSL RPM missing secadv_20140605 patches: ');
    print_critical('CVE-2014-0224');
    print_critical('Send customer this premade: "SECURITY - OpenSSL advisory 2014-06-05 - Discovery"');
    print_critical('!! BEFORE SENDING PREMADE VERIFY THE MISSING CVE PATCHES WITH: rpm -q --changelog openssl | egrep \' CVE-201(0|4)-\'');
    print_critical('This check does NOT take corrupt RPM dbs into account, and CAN report false-positive results if corrupt');
    print_critical();
}

sub check_for_bash_secadv_20140924 {
    chomp( my $bash_output = timed_run( 0, 'env x=\'() { :;}; echo vulnerable\' bash -c ""' ) );
    return if !( $bash_output =~ m{ vulnerable }xms );

    print_critical();
    print_crit('Installed \'bash\' shell is vulnerable to remote code injection.  Verify by running the following at a shell prompt, it should return "vulnerable":');
    print_critical();
    print_critical('    env x=\'() { :;}; echo vulnerable\' bash -c ""');
    print_critical('Send customer this premade: "SECURITY - Bash advisory 2014-09-24 - Discovery"');
    print_critical();
}

sub check_for_broken_mysqldump {
    my $md = '/usr/bin/mysqldump';

    if ( !-f $md ) {
        print_warn("$md: ");
        print_warning('not found!');
        return;
    }

    my $pid = IPC::Open3::open3( '</dev/null', '>/dev/null', my $stderr, $md, );
    waitpid( $pid, 0 );
    my $exit_status = $? >> 8;

    # when running mysqldump with no args, the exit status is 1. anything other than 1 should indicate unexpected behavior.
    #
    # $ mysqldump
    # [...]
    # $ echo $?
    # 1
    #
    # tested via MySQL55-client
    if ( $exit_status && $exit_status != 1 ) {
        print_warn("$md: ");
        print_warning('may be broken (exit status != 1). This can cause eximstats and other issues. See FB-98477');
    }
}

sub check_for_exim_cve_2016_1531 {
    my $eximbin = '/usr/sbin/exim';
    return if !-x $eximbin;
    my $eximver;

    chomp( my $exim_out = timed_run( 0, $eximbin, '--version' ) );
    return if !$exim_out;

    if ( $exim_out =~ m{version (\d+\.\d+(?:[._](\d+))?)}ms ) {
        $eximver = $1;
    }

    my $expected_version = "4.86_1";
    if ( cpanel_version_is(qw( < 11.52 )) ) {
        $expected_version = "4.85_1";
    }

    if ( $eximver && version_compare( $eximver, '<', $expected_version ) ) {
        print_critical();
        print_crit('Exim ');
        print_critical( 'may be vulnerable to CVE-2016-1531 (detected version ' . $eximver . ')' );
        print_critical('         \_ Send customer this premade: "SECURITY - EXIM CVE-2016-1531 - DISCOVERY"');
        print_critical();
    }
}

sub check_exim_log_sanity {
    my @logs = qw( /var/log/exim_mainlog /var/log/exim_paniclog /var/log/exim_rejectlog );

    for my $log (@logs) {
        if ( !-f $log ) {
            print_warn("$log: ");
            print_warning('is missing!');
        }
        else {
            my $uid  = ( stat($log) )[4];
            my $user = getpwuid($uid);
            if ( $user ne 'mailnull' ) {
                print_warn("$log: ");
                print_warning('is not owned by "mailnull"');
            }
        }
    }
}

sub check_for_readonly_filesystems {
    open my $fh, '<', '/proc/mounts' or return;
    my @read_only_fs = ();
    while (<$fh>) {
        if ( my @fs = split(' ') ) {
            next if grep( m{ / (virtfs|cagefs-skeleton|machine-id) / }x, $fs[1] );
            next if "/sys/fs/cgroup" eq $fs[1] and version_compare( $OS_VERSION, qw( >= 7 ) );
            if ( grep( m{ (^|,) ro (,|$) }x, $fs[3] ) ) {
                push( @read_only_fs, $fs[1] );
            }
        }
    }
    if ( scalar @read_only_fs ) {
        print_warn('Read-only filesystems: ');
        print_warning( join( " ", @read_only_fs ) );
    }
    close($fh);
}

sub check_for_unsupported_php {
    return if $EA4;
    return if !$EA3_PHPVERSION;
    return if $EA3_PHPVERSION >= 6;
    my $min_php5 = '5.3.0';
    if ( $EA3_PHPVERSION == 4 ) {
        return if !$EA3_PHP4VERSION;
    }
    if ( $EA3_PHPVERSION == 5 ) {
        return if !$EA3_PHP5VERSION;
        return if !version_compare( $EA3_PHP5VERSION, '<', $min_php5 );
    }
    print_critical();
    print_crit('!! RUNNING A VERSION OF PHP THAT IS NO LONGER SUPPORTED BY EASYAPACHE !! ');
    print_critical();
    print_critical('Do not run EasyApache without confirmation that this will replace PHP with a supported PHP version!');
    if ($EA3_PHP4VERSION) {
        print_critical( 'PHP4: ' . $EA3_PHP4VERSION );
    }
    if ( $EA3_PHP5VERSION && version_compare( $EA3_PHP5VERSION, '<', $min_php5 ) ) {
        print_critical( 'PHP5: ' . $EA3_PHP5VERSION );
    }
    print_critical();
}

sub check_for_cl_unsupported_memory_limits {
    return unless $IS_CLOUDLINUX;

    # See ticket # 5557825 - Several memory limits are not imposed: URL: https://helpdesk.cloudlinux.com/index.php?/Knowledgebase/Article/View/69/3/memory-limits-are-not-working
    # Per Igor:
    # CL 5 - doesn't support memory limits for: mod_php, mod_ruid2, MPM ITK & LiteSpeed.
    # CL 6 - doesn't support memory limits for: mod_php & mod_ruid2
    if ( $LSWS_FULL_VERSION && version_compare( $OS_VERSION, qw( < 6 ) ) ) {
        print_warn('LiteSpeed: ');
        print_warning('in use on CL5 or earlier. CloudLinux memory limits not imposed on Apache processes.');
    }
    if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER eq "dso" && version_compare( $OS_VERSION, qw( < 6 ) ) ) {
        print_warn('PHP DSO: ');
        print_warning('in use on CL 5 or earlier. CloudLinux memory limits not imposed on Apache processes.');
    }
    if ( $APACHE_PER_USER eq "ruid2" ) {
        print_warn('Mod Ruid2: ');
        print_warning('in use. CloudLinux memory limits not imposed on Apache processes.');
    }
    if ( $APACHE_PER_USER eq "itk" ) {
        print_warn('MPM ITK: ');
        print_warning('in use. CloudLinux memory limits not imposed on Apache processes.');
    }
}

sub check_for_eblockers {
    return if ( !-e "/var/cpanel/update_blocks.config" );
    open my $blocker_fh, '<', '/var/cpanel/update_blocks.config' or return;
    print_warn("WHM Update Blocker found:\n");
    while (<$blocker_fh>) {
        chomp;
        next if /^$/;
        print_magenta("\t \\_ $_");
    }
    close $blocker_fh;
}

sub check_for_frontpage_rpms {
    return if ( !-e '/usr/local/frontpage/version5.0/bin/owsadm.exe' );
    if ( !grep( m{frontpage}, @RPM_LIST ) ) {
        print_warn('FrontPage: ');
        print_warning('RPM not installed, but /usr/local/frontpage/version5.0/bin/owsadm.exe exists -- will prevent upgrade to 11.46');
    }
}

sub check_for_prelink {
    if ( grep( m{prelink}, @RPM_LIST ) ) {
        if ( open my $file_fh, '<', '/etc/sysconfig/prelink' ) {
            while (<$file_fh>) {
                if (m{ \A PRELINKING= \s* yes }x) {
                    print_warn('Prelink: ');
                    print_warning('RPM installed and enabled. Recommend disabling to customer by setting PRELINKING=no in /etc/sysconfig/prelink. See case CPANEL-4332.');
                    last;
                }
            }
            close $file_fh;
        }
    }
}

sub check_for_php_selector_incompatibilities {
    return unless $IS_CLOUDLINUX;

    # http://docs.cloudlinux.com/php_selector.html - not compatible with MPM ITK, Mod RUID2, DSO
    my $php_selector_conf     = '/usr/local/cpanel/base/frontend/x3/dynamicui/dynamicui_lvephpsel.conf';
    my $php_selector_disabled = 0;
    if ( -f $php_selector_conf ) {
        if ( open my $file_fh, '<', $php_selector_conf ) {
            while (<$file_fh>) {
                if (/^file=>lvephpsel,skipobj=>1/) {
                    $php_selector_disabled = 1;
                    last;
                }
            }
            close $file_fh;
        }
    }
    return if $php_selector_disabled;

    if ( $APACHE_PER_USER eq "itk" ) {
        print_warn('MPM ITK: ');
        print_warning('is enabled but not compatible with PHP Selector - http://docs.cloudlinux.com/php_selector.html');
    }

    if ( $APACHE_PER_USER eq "ruid2" ) {
        print_warn('Mod Ruid2: ');
        print_warning('is enabled but not compatible with PHP Selector - http://docs.cloudlinux.com/php_selector.html');
    }

    if ( $EA3_PHP5HANDLER && $EA3_PHP5HANDLER eq 'dso' ) {
        print_warn('DSO PHP handler: ');
        print_warning('is enabled but not compatible with PHP Selector - http://docs.cloudlinux.com/php_selector.html');
    }
}

sub check_for_missing_cloudlinux_files {
    return unless $IS_CLOUDLINUX;
    if ( !-x "/usr/sbin/lvectl" ) {
        print_warn('CloudLinux: ');
        print_warning('missing or non-executable /usr/sbin/lvectl - check/repair lve-utils RPM');
    }
    if ( !-x "/usr/sbin/lveinfo" ) {
        print_warn('CloudLinux: ');
        print_warning('missing or non-executable /usr/sbin/lveinfo - check/repair lve-stats RPM');
    }
    if ( !-x "/usr/sbin/spacewalk-channel" ) {
        print_warn('CloudLinux: ');
        print_warning('missing or non-executable /usr/sbin/spacewalk-channel - check/repair rhn-setup RPM');
    }
    if ( !-x "/usr/bin/python" ) {
        print_warn('CloudLinux: ');
        print_warning('missing or non-executable /usr/bin/python - check/repair python RPM');
    }
    if ( -e "/var/.cagefs" ) {
        print_warn('CloudLinux: ');
        print_warning('/var/.cagefs - EXISTS! Should never exist outside of CageFS, will break many things.');
    }
}

sub check_for_UMBREON_rootkit {
    my $dir = '/usr/local/__UMBREON__';
    if ( chdir $dir ) {
        print_generic_hack_predef('UMBREON ROOTKIT');
        print_critical('The following directory was found:');
        print_critical( "\t" . $dir );
        print_critical("\tL3: use \"L3 - Jynx2 Predef [L3 Only]\"");
        print_critical();
    }
}

sub check_for_libms_rootkit {
    my $dir = '/lib/udev/x.modules';
    if ( chdir $dir ) {
        print_generic_hack_predef('LIBMS ROOTKIT');
        print_critical('The following directory was found:');
        print_critical( "\t" . $dir );
        print_critical("\tL3: see ticket 7488621\"");
        print_critical();
    }
}

sub check_for_jynx2_rootkit {
    my $dir = '/usr/bin64';
    if ( chdir $dir ) {
        my @found_jynx2_files = ();
        my @jynx2_files       = qw( 3.so 4.so );
        for (@jynx2_files) {
            my $file = $dir . "/" . $_;
            if ( -e $file ) {
                push( @found_jynx2_files, $file );
            }
        }
        return if ( ( scalar @found_jynx2_files ) == 0 );
        print_generic_hack_predef('Jynx 2 ROOTKIT');
        print_critical('The following files were found:');
        print_critical( "\t" . join( " ", @found_jynx2_files ) );
        print_critical("\tL3: use \"L3 - Jynx2 Predef [L3 Only]\"");
        print_critical();
    }
}

sub check_for_bg_botnet {
    my @found_bg_files = ();

    # /bin/ps, /bin/netstat, and /usr/sbin/lsof have also been found to be modified
    # This one is causing some rare false-positives:
    # /root/aa
    my @bg_files = qw(
      /boot/pro
      /boot/proh
      /etc/atdd
      /etc/atddd
      /etc/cupsdd
      /etc/cupsddd
      /etc/dsfrefr
      /etc/fdsfsfvff
      /etc/ferwfrre
      /etc/gdmorpen
      /etc/gfhddsfew
      /etc/gfhjrtfyhuf
      /etc/ksapd
      /etc/ksapdd
      /etc/kysapd
      /etc/kysapdd
      /etc/rewgtf3er4t
      /etc/sdmfdsfhjfe
      /etc/sfewfesfs
      /etc/sfewfesfsh
      /etc/sksapd
      /etc/sksapdd
      /etc/skysapd
      /etc/skysapdd
      /etc/smarvtd
      /etc/whitptabil
      /etc/xfsdx
      /etc/xfsdxd
      /etc/rc.d/init.d/DbSecuritySpt
      /etc/rc.d/init.d/selinux
      /usr/bin/.sshd
      /usr/bin/bsd-port/getty
      /usr/bin/pojie
      /usr/lib/libamplify.so
      /var/.lug.txt
    );

    # Because tmp, we must check that these are owned by root. Leaving "/tmp/notify.file" out of this list due to potential false-positives.
    my @root_bg_files = qw(
      /tmp/bill.lock
      /tmp/gates.lock
      /tmp/moni.lock
      /tmp/fdsfsfvff
      /tmp/gdmorpen
      /tmp/gfhjrtfyhuf
      /tmp/rewgtf3er4t
      /tmp/sfewfesfs
      /tmp/smarvtd
      /tmp/whitptabil
    );

    for my $file (@bg_files) {
        if ( -e $file ) {
            push( @found_bg_files, $file );
        }
    }
    for my $file (@root_bg_files) {
        if ( -e $file && ( stat $file )[4] eq 0 ) {
            push( @found_bg_files, $file );
        }
    }
    return unless ( scalar @found_bg_files );
    print_generic_hack_predef('BG BOTNET');
    print_critical('The following files were found:');
    print_critical( "\t" . join( " ", @found_bg_files ) );
    print_critical("\tL3: use \"L3 - BG Botnet Predef [L3 Only]\"");
    print_critical();
}

sub check_for_dragnet {
    if ( open my $fh, '<', '/proc/self/maps' ) {
        while (<$fh>) {
            if (m{ (\s|\/) libc\.so\.0 (\s|$) }x) {
                print_generic_hack_predef('DRAGNET ROOTKIT');
                print_critical("\t\\_ 'libc.so.0' found in process maps");
                print_critical();
                last;
            }
        }
        close($fh);
    }
}

sub check_for_xor_ddos {
    my @libs = qw(
      /lib/libgcc.so
      /lib/libgcc.so.bak
      /lib/libgcc4.4.so
      /lib/libgcc4.so
      /lib/libudev.so
    );

    my @matched;
    for my $lib (@libs) {
        next if -l $lib;
        push @matched, $lib if -f $lib;
    }

    if (@matched) {
        print_generic_hack_predef('Linux/XOR.DDoS');
        print_critical('The following file(s) were found:');
        print_critical( "\t" . join( "\n\t", @matched ) );
        print_critical();
    }
}

sub check_for_shellbot {
    my @libs = qw(
      /lib/libgrubd.so
    );

    my @matched;
    for my $lib (@libs) {
        next if -l $lib;
        push @matched, $lib if -f $lib;
    }

    if (@matched) {
        print_generic_hack_predef('ShellBot');
        print_critical('The following file(s) were found:');
        print_critical( "\t" . join( "\n\t", @matched ) );
        print_critical("\tL3: use \"L3 - ShellBot Predef [L3 Only]\"");
        print_critical();
    }
}

sub check_updatelog {
    my $log = '/var/cpanel/updatelogs/last';
    return if !-e $log;

    my $size = ( stat($log) )[7];
    return if !$size;
    my $bytes_to_read = 10485760;    # 10M
    $bytes_to_read = $size if $bytes_to_read > $size;

    my $log_data = undef;

    open my $file_fh, '<', $log or return;
    read $file_fh, $log_data, $bytes_to_read;
    close $file_fh;

    my $found_rpm_needs_space;

    foreach ( split( "\n", $log_data ) ) {
        $found_rpm_needs_space = 1 if m{ installing .+ needs .+ on .+ filesystem }x;
    }

    undef $log_data;

    if ($found_rpm_needs_space) {
        print_warn("WHM update: ");
        print_warning( $log . ' contains errors which indicate that RPM installation had insufficient free disk space available' );
    }
}

##############################
#  END [WARN] CHECKS
##############################

##############################
#  BEGIN [3RDP] CHECKS
##############################

sub check_smtp_processes {
    my $assp_running = 0;

    return if scalar keys(%$PORT_REF) == 0;
    if ( !defined( $PORT_REF->{"25"} ) && !-f '/etc/eximdisable' ) {
        print_warn('Exim: ');
        print_warning('not disabled and does not appear to be up -- nothing listening on port 25');
    }

    return if !defined( $PORT_REF->{"25"} );

    for my $href ( @{ $PORT_REF->{"25"} } ) {
        my $pid = $href->{PID};
        my $cmd = $PROCESS_REF->{$pid}{CMD};
        if ( $href->{PROTO} eq "TCP" && !( $cmd =~ m{ \A /usr/sbin/exim \b }xms ) ) {
            print_3rdp('SMTP: ');
            print_3rdp2( 'a process other than exim is listening on port 25 [' . $href->{IPV} . ' ' . $href->{IP} . '] [USER: ' . $href->{USER} . '] [CMD: ' . $cmd . '] [PID: ' . $pid . ']' );
        }
        if ( $cmd =~ m{ /assp\.pl \b }xms ) {
            $assp_running = $pid;
        }
    }

    if ($assp_running) {
        print_3rdp('ASSP: ');
        print_3rdp2( 'assp.pl is listening on port 25 [PID: ' . $assp_running . '] Vendor: http://assp.sourceforge.net' );
    }
}

sub check_for_varnish {
    my @port_80_processes;

    return if !@LSOF_80;

    for my $line (@LSOF_80) {
        if ( $line =~ m{ (\S+) \s+ (?:.*) \s TCP (?:.*):http \s \(LISTEN\) }xms ) {
            push( @port_80_processes, $1 );
        }
    }

    if ( grep { m{ \A varnish }xms } @port_80_processes ) {
        print_3rdp('Varnish: ');
        print_3rdp2('varnish is listening on port 80, known to break proxy subdomains. See "RareIssues" wiki article');
    }
}

sub check_for_nginx {
    my $nginx = 0;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A (root|nobody) (?:.*) nginx(:?) }xms ) {
            $nginx = 1;
            last;
        }
    }

    if ( $nginx == 1 ) {
        print_3rdp('nginx: ');
        print_3rdp2('is running');
    }
}

sub check_for_mailscanner {
    my $mailscanner = 0;

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A mailnull (?:.*) MailScanner }xms ) {
            $mailscanner = 1;
            last;
        }
    }

    if ( $mailscanner == 1 ) {
        print_3rdp('MailScanner: ');
        print_3rdp2('is running');
    }
}

sub check_for_apf {
    my $chkconfig_apf = timed_run( 0, 'chkconfig', '--list', 'apf' );
    if ($chkconfig_apf) {
        if ( $chkconfig_apf =~ /3:on/ ) {
            print_3rdp('APF: ');
            print_3rdp2('installed, may be enabled.');
        }
    }
}

sub check_for_csf {
    my $lfd = 0;
    my $csf = timed_run( 0, 'whereis', 'csf' );

    if ( $csf =~ /\// ) {
        print_3rdp('CSF: ');
    }
    else {
        return;
    }

    for my $line (@PROCESS_LIST) {
        if ( $line =~ m{ \A root (?:.*) lfd }xms ) {
            $lfd = 1;
            last;
        }
    }

    if ($lfd) {
        print_3rdp2('installed, LFD is running');
    }
    else {
        print_3rdp2('installed, LFD is not running');
    }
}

sub check_for_prm {
    if ( -e '/usr/local/prm' ) {
        print_3rdp('PRM: ');
        print_3rdp2('PRM exists at /usr/local/prm');
    }
}

sub check_for_les {
    if ( -e '/usr/local/sbin/les' ) {
        print_3rdp('LES: ');
        print_3rdp2('Linux Environment Security is installed at /usr/local/sbin/les');
    }
}

sub check_for_1h {
    my $one_h = 0;
    my ( $hive_module, $guardian );

    if ( -d '/usr/local/1h' ) {
        $one_h = 1;
        if (@APACHE_MODULES_OUTPUT) {
            for my $line (@APACHE_MODULES_OUTPUT) {
                if ( $line =~ /hive_module / ) {
                    $hive_module = 'loaded';
                    last;
                }
                else {
                    $hive_module = 'not active';
                }
            }
        }
        else {
            $hive_module = 'status unknown';
        }

        if ( -x '/usr/local/1h/sbin/guardian' ) {
            for my $line (@PROCESS_LIST) {
                if ( $line =~ /Guardian/ ) {
                    $guardian = 'running';
                }
                else {
                    $guardian = 'not running';
                }
            }
        }
        else {
            $guardian = 'not running';
        }
    }

    if ( $one_h == 1 ) {
        print_3rdp('1H Software: ');
        print_3rdp2("/usr/local/1h exists. hive apache module: [ $hive_module ] Guardian process: [ $guardian ]");
    }
}

sub check_for_webmin {
    my @lsof_10000 = split /\n/, timed_run( 0, 'lsof', '-n', '-i', 'tcp:10000' );

    if (@lsof_10000) {
        print_3rdp('Webmin: ');
        print_3rdp2('Port 10000 is listening, webmin may be running');
    }
}

sub check_for_symantec {
    my $symantec = 0;

    for my $process (@PROCESS_LIST) {
        if ( $process =~ m{ \A root (?:.*) /opt/Symantec/symantec_antivirus }xms ) {
            $symantec = 1;
            last;
        }
    }

    if ( $symantec == 1 ) {
        print_3rdp('Symantec: ');
        print_3rdp2('found /opt/Symantec/symantec_antivirus in process list');
    }
}

sub check_for_haproxy {
    my $haproxy = 0;

    for my $process (@PROCESS_LIST) {
        if ( $process =~ m{ \A haproxy (?:.*) haproxy }xms ) {
            $haproxy = 1;
            last;
        }
    }

    if ( $haproxy == 1 ) {
        print_3rdp('HAProxy: ');
        print_3rdp2('found haproxy in process list');
    }
}

sub check_for_newrelic {
    my $has_newrelic = 0;

    for my $process (@PROCESS_LIST) {
        if ( $process =~ /newrelic-daemon/ ) {
            $has_newrelic = 1;
            last;
        }
    }

    if ( $has_newrelic == 1 ) {
        print_3rdp('newrelic-daemon: ');
        print_3rdp2('found in process list. Caused server stability issues in 4396009');
    }

}

sub check_for_zamfoo {
    my $has_zamfoo = 0;

    if ( -f '/scripts/prekillacct' ) {
        open my $file_fh, '<', '/scripts/prekillacct' or return;
        while (<$file_fh>) {
            if (/zamfoo/i) {
                $has_zamfoo = 1;
                last;
            }
        }
        close $file_fh;
    }

    if ( $has_zamfoo == 1 ) {
        print_3rdp('Zamfoo: ');
        print_3rdp2('is installed. Multi-level reseller setups are not supported!');
    }
}

sub check_for_whmreseller {
    if ( -d '/usr/local/cpanel/whostmgr/docroot/cgi/whmreseller' ) {
        print_3rdp('WHMReseller: ');
        print_3rdp2('is installed. Multi-level reseller setups are not supported!');
    }
}

sub check_for_whmphp {
    if ( -d '/usr/local/cpanel/whostmgr/docroot/cgi/whmphp' ) {
        print_3rdp('WHMPHP: ');
        print_3rdp2('is installed. Multi-level reseller setups are not supported!');
    }
}

sub check_for_cpremote {
    return if !-e '/var/spool/cron/root';

    my $has_cpremote = 0;

    open my $file_fh, '<', '/var/spool/cron/root' or return;
    while (<$file_fh>) {
        if (m#/scripts/cpremotebackup#) {
            $has_cpremote = 1;
            last;
        }
    }
    close $file_fh;

    if ( $has_cpremote == 1 ) {
        print_3rdp('cpremote: ');
        print_3rdp2('installed. third party backup software (cron job found for root)');
    }
}

sub check_for_els {
    my $els = '/usr/local/els/els.sh';
    return if !-e $els;

    print_3rdp('ELS: ');
    print_3rdp2("$els found. See http://www.servermonkeys.com/els.php");
}

sub check_for_whmxtra {
    my $ionsh = '/usr/local/cpanel/whostmgr/docroot/themes/x/xtra/functions/ion.sh';
    return if !-f $ionsh;

    print_3rdp('WHMXtra: ');
    print_3rdp2("$ionsh exists. 'cPanel PHP loader' Tweak Settings or php.ini settings reverted? See 4622167, 4628203");
}

sub check_for_usr_local_mis {
    my $dir = '/usr/local/mis';
    return if !-d $dir;

    print_3rdp("$dir: ");
    print_3rdp2('found! This can prevent EA from completing. See ticket 4822059');
}

sub check_for_opt_gsi_tools {
    my $dir = '/opt/gsi-tools';
    return if !-d $dir;

    print_3rdp("$dir: ");
    print_3rdp2('found! These admin scripts have been known to automatically lock user accounts. See ticket 6122361.');
}

##############################
#  END [3RDP] CHECKS
##############################

sub build_libkeyutils_file_list {
    my @dirs = qw( /lib /lib64 );
    my @libkeyutils_files;

    for my $dir (@dirs) {
        next if !-e $dir;
        opendir( my $dir_fh, $dir );
        while ( my $file = readdir($dir_fh) ) {
            if ( $file =~ /^libkeyutils\.so\.(?:[\.\d]+)?$/ ) {
                if ( $dir eq '/lib' ) {
                    push @libkeyutils_files, "/lib/$file\n";
                }
                elsif ( $dir eq '/lib64' ) {
                    push @libkeyutils_files, "/lib64/$file\n";
                }
            }
        }
        closedir $dir_fh;
    }

    chomp @libkeyutils_files;
    return \@libkeyutils_files;
}

## BEGIN malware checks

sub print_generic_hack_predef {
    my $name = shift;
    print_critical();
    print_crit( '!! [ ' . $name . ' ] !! ' );
    print_critical('Escalate this ticket to L3 using "ESCALATE - Hacked Server Response for L1/L2->L3 ( All Analysts )"');
}

sub print_ebury_cdorked_predef {
    my $name = shift;
    print_generic_hack_predef($name);
    print_critical("\tL3: use \"L3 - eBury / CDorked - Free Migration [L3 only]\"");
}

sub check_for_cdorked_A {
    my $apache_bin   = '/usr/local/apache/bin/httpd';
    my $max_bin_size = 10_485_760;                      # avoid slurping too much mem
    return if ( !-f $apache_bin );
    return if ( ( stat($apache_bin) )[7] > $max_bin_size );

    my $has_cdorked = 0;
    my $signature;
    my @apache_bins = ();
    push @apache_bins, $apache_bin;

    for my $process (@PROCESS_LIST) {
        if ( $process =~ m{ \A root \s+ (\d+) [^\d]+ $apache_bin }xms ) {
            my $pid          = $1;
            my $proc_pid_exe = "/proc/" . $pid . "/exe";
            if ( -l $proc_pid_exe && readlink($proc_pid_exe) =~ m{ \(deleted\) }xms ) {
                next if ( ( stat($proc_pid_exe) )[7] > $max_bin_size );
                push @apache_bins, $proc_pid_exe;
            }
        }
    }

    for my $check_bin (@apache_bins) {
        my $httpd;
        if ( open my $fh, '<', $check_bin ) {
            local $/;
            $httpd = <$fh>;
            close $fh;
        }

        next if !$httpd;

        if ( $httpd =~ /(open_tty|hangout|ptsname|Qkkbal)/ ) {
            $signature   = $check_bin . ": \"" . $1 . "\"";
            $has_cdorked = 1;
            last;
        }
    }

    if ( $has_cdorked == 1 ) {
        print_ebury_cdorked_predef('CDORKED');
        print_critical("\tString found in $signature (see ticket 4482347)");
        print_critical();
    }
}

sub check_for_cdorked_B {
    my $has_cdorked_b = 0;
    my @files = ( '/usr/sbin/arpd ', '/usr/sbin/tunelp ', '/usr/bin/s2p ' );
    my $cdorked_files;

    for my $file (@files) {
        if ( -e $file ) {
            $has_cdorked_b = 1;
            $cdorked_files .= "[$file] ";
        }
    }

    if ( $has_cdorked_b == 1 ) {
        print_ebury_cdorked_predef('CDORKED');
        print_critical("\tThe following files were found (note the spaces at the end of the files):");
        print_critical("\t$cdorked_files");
        print_critical();
    }
}

sub check_for_libkeyutils_filenames {
    my $bad_libs;
    my @dirs  = qw( /lib /lib64 );
    my @files = qw(
      libkeyutils.so.1.9
      libkeyutils-1.2.so.0
      libkeyutils-1.2.so.2
      libkeyutils.so.1.3.0
      libkeyutils.so.1.3.2
      libns2.so
      libns5.so
      libpw3.so
      tls/libkeyutils.so.1
      tls/libkeyutils.so.1.5
    );

    for my $dir (@dirs) {
        next if !-e $dir;
        for my $file (@files) {
            if ( -f "${dir}/${file}" and !-z "${dir}/${file}" ) {
                $bad_libs .= "\t${dir}/${file}\n";
            }
        }
    }

    if ($bad_libs) {
        print_ebury_cdorked_predef('EBURY');
        print_critical('The following file(s) were found:');
        print_critical($bad_libs);
        print_critical();
    }
}

sub check_sha1_sigs_libkeyutils {
    return if !$LIBKEYUTILS_FILES_REF;

    my $trojaned_lib;

    # p67 http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf
    my @checksums = qw(
      09c8af3be4327c83d4a7124a678bbc81e12a1de4
      1a9aff1c382a3b139b33eeccae954c2d65b64b90
      267d010201c9ff53f8dc3fb0a48145dc49f9de1e
      2e571993e30742ee04500fbe4a40ee1b14fa64d7
      2fc132440bafdbc72f4d4e8dcb2563cc0a6e096b
      39ec9e03edb25f1c316822605fe4df7a7b1ad94a
      3c5ec2ab2c34ab57cba69bb2dee70c980f26b1bf
      471ee431030332dd636b8af24a428556ee72df37
      58f185c3fe9ce0fb7cac9e433fb881effad31421
      5d3ec6c11c6b5e241df1cc19aa16d50652d6fac0
      74aa801c89d07fa5a9692f8b41cb8dd07e77e407
      7adb38bf14e6bf0d5b24fa3f3c9abed78c061ad1
      899b860ef9d23095edb6b941866ea841d64d1b26
      8daad0a043237c5e3c760133754528b97efad459
      8f75993437c7983ac35759fe9c5245295d411d35
      9bb6a2157c6a3df16c8d2ad107f957153cba4236
      9e2af0910676ec2d92a1cad1ab89029bc036f599
      a7b8d06e2c0124e6a0f9021c911b36166a8b62c5
      adfcd3e591330b8d84ab2ab1f7814d36e7b7e89f
      b8508fc2090ddee19a19659ea794f60f0c2c23ff
      bbce62fb1fc8bbed9b40cfb998822c266b95d148
      bf1466936e3bd882b47210c12bf06cb63f7624c0
      d552cbadee27423772a37c59cb830703b757f35e
      e14da493d70ea4dd43e772117a61f9dbcff2c41c
      e2a204636bda486c43d7929880eba6cb8e9de068
      f1ada064941f77929c49c8d773cbad9c15eba322
    );

    for my $lib (@$LIBKEYUTILS_FILES_REF) {
        next unless my $checksum = timed_run( 0, 'sha1sum', "$lib" );
        chomp $checksum;
        $checksum =~ s/\s.*//g;
        if ( grep { /$checksum/ } @checksums ) {
            $trojaned_lib = "$lib\n\tSHA-1 checksum: $checksum";
            last;
        }
    }

    if ($trojaned_lib) {
        print_ebury_cdorked_predef('EBURY');
        print_critical('The following file(s) were found:');
        print_critical( "\t" . $trojaned_lib );
        print_critical("\tReference: http://www.welivesecurity.com/2014/02/21/an-in-depth-analysis-of-linuxebury/");
        print_critical();
    }
}

sub check_for_unowned_libkeyutils_files {
    return if !$LIBKEYUTILS_FILES_REF;

    my @unowned_libs;

    for my $lib (@$LIBKEYUTILS_FILES_REF) {
        chomp( my $rpm_check = timed_run( 0, 'rpm', '-qf', "$lib" ) );
        if ( $rpm_check =~ /owned/ ) {
            push @unowned_libs, $lib;
        }
    }

    return if !@unowned_libs;

    print_ebury_cdorked_predef('EBURY');
    print_critical("\tThe following libkeyutils files do not belong to a package (checked via 'rpm -qf'):");
    for my $file (@unowned_libs) {
        print_critical( "\t" . $file );
    }
    print_critical();
}

sub check_sha1_sigs_httpd {
    my $httpd = '/usr/local/apache/bin/httpd';
    return if !-e $httpd;
    my $infected = 0;
    return unless my $sha1sum = timed_run( 0, 'sha1sum', $httpd );
    if ( $sha1sum =~ m{ \A (\S+) \s }xms ) {
        $sha1sum = $1;
    }

    my @sigs = qw(
      0004b44d110ad9bc48864da3aea9d80edfceed3f
      03592b8147e2c84233da47f6e957acd192b3796a
      0eb1108a9d2c9fe1af4f031c84e30dcb43610302
      10c6ce8ee3e5a7cb5eccf3dffd8f580e4fb49089
      149cf77d2c6db226e172390a9b80bc949149e1dc
      1972616a731c9e8a3dbda8ece1072bd16c44aa35
      24e3ebc0c5a28ba433dfa69c169a8dd90e05c429
      4f40bb464526964ba49ed3a3b2b2b74491ea89a4
      5b87807b4a1796cfb1843df03b3dca7b17995d20
      62c4b65e0c4f52c744b498b555c20f0e76363147
      78c63e9111a6701a8308ad7db193c6abb17c65c4
      858c612fe020fd5089a05a3ec24a6577cbeaf7eb
      9018377c0190392cc95631170efb7d688c4fd393
      a51b1835abee79959e1f8e9293a9dcd8d8e18977
      a53a30f8cdf116de1b41224763c243dae16417e4
      ac96adbe1b4e73c95c28d87fa46dcf55d4f8eea2
      dd7846b3ec2e88083cae353c02c559e79124a745
      ddb9a74cd91217cfcf8d4ecb77ae2ae11b707cd7
      ee679661829405d4a57dbea7f39efeb526681a7f
      fc39009542c62a93d472c32891b3811a4900628a
      fdf91a8c0ff72c9d02467881b7f3c44a8a3c707a
    );

    for my $sig (@sigs) {
        if ( $sha1sum eq $sig ) {
            $infected = 1;
            last;
        }
    }

    if ( $infected == 1 ) {
        print_ebury_cdorked_predef('CDORKED');
        print_critical( "\t" . $httpd . " has a SHA-1 signature of " . $sha1sum );
        print_critical("\tReference: p67-68 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf");
        print_critical();
    }
}

sub check_sha1_sigs_named {
    my $named = '/usr/sbin/named';
    return if !-e $named;
    my $infected = 0;
    return unless my $sha1sum = timed_run( 0, 'sha1sum', $named );
    if ( $sha1sum =~ m{ \A (\S+) \s }xms ) {
        $sha1sum = $1;
    }

    my @sigs = qw(
      42123cbf9d51fb3dea312290920b57bd5646cefb
      ebc45dd1723178f50b6d6f1abfb0b5a728c01968
    );

    for my $sig (@sigs) {
        if ( $sha1sum eq $sig ) {
            $infected = 1;
            last;
        }
    }

    if ( $infected == 1 ) {
        print_ebury_cdorked_predef('CDORKED');
        print_critical( "\t" . $named . " has a SHA-1 signature of " . $sha1sum );
        print_critical("\tReference: p67-68 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf");
    }
}

sub check_sha1_sigs_ssh {
    my $ssh = '/usr/bin/ssh';
    return if !-e $ssh;
    my $infected = 0;
    return unless my $sha1sum = timed_run( 0, 'sha1sum', $ssh );
    if ( $sha1sum =~ m{ \A (\S+) \s }xms ) {
        $sha1sum = $1;
    }

    my @sigs = qw(
      c4c28d0372aee7001c44a1659097c948df91985d
      fa6707c7ef12ce9b0f7152ca300ebb2bc026ce0b
    );

    for my $sig (@sigs) {
        if ( $sha1sum eq $sig ) {
            $infected = 1;
            last;
        }
    }

    if ( $infected == 1 ) {
        print_ebury_cdorked_predef('EBURY');
        print_critical( "\t" . $ssh . " has a SHA-1 signature of " . $sha1sum );
        print_critical("\tReference: p67-68 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf");
        print_critical();
    }
}

sub check_sha1_sigs_ssh_add {
    my $ssh_add = '/usr/bin/ssh-add';
    return if !-e $ssh_add;
    my $infected = 0;
    return unless my $sha1sum = timed_run( 0, 'sha1sum', $ssh_add );
    if ( $sha1sum =~ m{ \A (\S+) \s }xms ) {
        $sha1sum = $1;
    }

    my @sigs = qw(
      575bb6e681b5f1e1b774fee0fa5c4fe538308814
    );

    for my $sig (@sigs) {
        if ( $sha1sum eq $sig ) {
            $infected = 1;
            last;
        }
    }

    if ( $infected == 1 ) {
        print_ebury_cdorked_predef('EBURY');
        print "\t$ssh_add has a SHA-1 signature of $sha1sum\n";
        print "\tReference: p67-68 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf\n";
    }
}

sub check_sha1_sigs_sshd {
    my $sshd = '/usr/sbin/sshd';
    return if !-e $sshd;
    my $infected = 0;
    return unless my $sha1sum = timed_run( 0, 'sha1sum', $sshd );
    if ( $sha1sum =~ m{ \A (\S+) \s }xms ) {
        $sha1sum = $1;
    }

    my @sigs = qw(
      0daa51519797cefedd52864be0da7fa1a93ca30b
      4d12f98fd49e58e0635c6adce292cc56a31da2a2
      7314eadbdf18da424c4d8510afcc9fe5fcb56b39
      98cdbf1e0d202f5948552cebaa9f0315b7a3731d
    );

    for my $sig (@sigs) {
        if ( $sha1sum eq $sig ) {
            $infected = 1;
            last;
        }
    }

    if ( $infected == 1 ) {
        print_ebury_cdorked_predef('EBURY');
        print_critical( "\t" . $sshd . " has a SHA-1 signature of " . $sha1sum );
        print_critical("\tReference: p67-68 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf");
        print_critical();
    }
}

sub check_for_ebury_ssh_G {
    my $ssh = '/usr/bin/ssh';
    return if !-e $ssh;
    return if !-f _;
    return if !-x _;
    return if -z _;

    my $ssh_version = timed_run_trap_stderr( 0, $ssh, '-V' );
    return if $ssh_version !~ m{ \A OpenSSH_5 }xms;

    my $ssh_G = timed_run_trap_stderr( 0, $ssh, '-G' );
    if ( $ssh_G !~ /illegal|unknown/ ) {
        print_ebury_cdorked_predef('EBURY');
        print_critical( "\t'" . $ssh . " -G' did not return either 'illegal' or 'unknown'" );
        print_critical("\tReference: http://www.welivesecurity.com/2014/02/21/an-in-depth-analysis-of-linuxebury/");
        print_critical();
    }
}

sub check_for_ebury_ssh_banner {
    my ( $host, $port, $ssh_banner );
    my $ssh_connection = $ENV{'SSH_CONNECTION'};
    return if !$ssh_connection;

    if ( $ssh_connection =~ m{ \s (\d+\.\d+\.\d+\.\d+) \s (\d+) \z }xms ) {
        ( $host, $port ) = ( $1, $2 );
    }

    return if !$host;
    return if !$port;

    my $sock = IO::Socket::INET->new(
        PeerAddr => $host,
        PeerPort => $port,
        Proto    => 'tcp',
        Timeout  => 5,
    ) or return;

    $ssh_banner = readline $sock;
    close $sock;
    return if !$ssh_banner;
    chomp $ssh_banner;

    if ( $ssh_banner =~ m{ \A SSH-2\.0-[0-9a-f]{22,46} }xms ) {
        print_ebury_cdorked_predef('EBURY');
        print_critical( "\tsshd banner matches known signature from ebury infected machines: " . $ssh_banner );
        print_critical("\tReference: http://www.welivesecurity.com/2014/02/21/an-in-depth-analysis-of-linuxebury/");
        print_critical();
    }
}

sub check_for_ebury_ssh_shmem {

    # As far as we know, sshd sholudn't be using shared memory at all, so any usage is a strong sign of ebury.
    return if !defined( $IPCS_REF->{root}{mp} );

    for my $href ( @{ $IPCS_REF->{root}{mp} } ) {
        my $shmid = $href->{shmid};
        my $cpid  = $href->{cpid};
        if ( $PROCESS_REF->{$cpid}{CMD} && $PROCESS_REF->{$cpid}{CMD} =~ m{ \A /usr/sbin/sshd \b }x ) {
            print_ebury_cdorked_predef('EBURY');
            print_critical("\tShared memory segment created by sshd process exists:");
            print_critical( "\t\tsshd PID: " . $cpid );
            print_critical( "\t\tshmid: " . $shmid );
            print_critical("\tReference: http://www.welivesecurity.com/2014/02/21/an-in-depth-analysis-of-linuxebury/");
            print_critical( timed_run( 0, "echo --- ps -p ${cpid} uww ---;ps -p ${cpid} uww; echo --- ipcs -m -i ${shmid} ---; ipcs -m -i ${shmid}; echo ---" ) );
            last;
        }
    }
}

sub check_for_ebury_root_file {
    my $file = '/home/ ./root';

    if ( -e $file ) {
        print_ebury_cdorked_predef('EBURY');
        print_critical( "\tFound file: " . $file );
        print_critical("\tReference: p24 from http://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf");
        print_critical();
    }
}

sub check_for_ebury_3_digit_rpms {
    #### check for the existence if illegitimate rpms, like these:
    #
    #  openssh-4.3p2-721.el5_61.65
    #  openssh-5.3p1-209.el6_10.41.x86_64
    #
    #  openssh-clients-4.3p2-721.el5_61.65
    #  openssh-clients-5.3p1-209.el6_10.41.x86_64
    #
    #  openssh-server-4.3p2-721.el5_61.65
    #  openssh-server-5.3p1-209.el6_10.41.x86_64

    my $bad_rpms;

    for my $rpm (@RPM_LIST) {
        if ( $rpm =~ m{ \A openssh-(clients|server|\d)(.*)-(\d){3}\. }xms ) {
            $bad_rpms .= "\t$rpm\n";
        }
    }

    if ($bad_rpms) {
        print_ebury_cdorked_predef('EBURY');
        print_critical("The following rpm(s) were found:");
        print_critical($bad_rpms);
        print_critical();
    }
}

sub check_for_ebury_socket {
    return unless my $netstat_out = timed_run( 0, 'netstat', '-nap' );
    for my $line ( split( '\n', $netstat_out ) ) {
        if ( $line =~ m{@/proc/udevd} ) {
            print_ebury_cdorked_predef('EBURY');
            print_critical('"netstat -nap" output contains:');
            print_critical($line);
            print_critical();
            last;
        }
    }
}

sub check_for_ncom_filenames {
    my @bad_libs;
    my @dirs  = qw( /lib /lib64 );
    my @files = qw(
      libnano.so.4
      libncom.so.4.0.1
      libselinux.so.4
    );

    for my $dir (@dirs) {
        next if !-e $dir;
        for my $file (@files) {
            my $fullpath = $dir . "/" . $file;
            stat $fullpath;
            if ( -f _ and !-z _ ) {
                push @bad_libs, $fullpath;
            }
        }
    }

    if (@bad_libs) {
        print_generic_hack_predef('NCOM ROOTKIT');
        print_critical('The following files were found:');
        print_critical( "\t" . join( " ", @bad_libs ) );
        print_critical("\tL3: use \"L3 - Ncom Rootkit Predef [L3 Only]\"");
        print_critical("\tL3: check /etc/ld.so.preload");
        print_critical();
    }
}

sub check_for_cpro {
    my @bad_paths;
    my @paths = qw(
      /usr/bin/clnupdate
      /usr/bin/yasin
      /usr/local/cpanel/license/update_cpanelv2
      /usr/local/cpanel/whostmgr/cgi/check.php
    );
    for my $path (@paths) {

        if ( -e $path ) {
            push @bad_paths, $path;
        }
    }
    if (@bad_paths) {
        print_generic_hack_predef('C.PRO');
        print_critical('The following files were found:');
        print_critical( "\t" . join( " ", @bad_paths ) );
        print_critical("\tL3: See ticket 7790559 for reference.");
        print_critical();
    }
}

## END malware checks

sub build_rpm_list {
    return if @EXTENDED_RPM_LIST;    # already did this, don't do it again

    local $OPT_TIMEOUT = $OPT_TIMEOUT ? $OPT_TIMEOUT : 25;

    print_info2("RPM check (running \"rpm -qa ...\"). This will timeout after $OPT_TIMEOUT seconds.");

    my $rpm_list = timed_run( $OPT_TIMEOUT, 'rpm', '-qa', '--queryformat', q{%{ARCH}\t%{NAME}\t%{VERSION}\t%{RELEASE}\n} );
    return if !$rpm_list;

    @EXTENDED_RPM_LIST = map {
        my ( $arch, $name, $version, $release ) = split( /\t/, $_ );
        {
            'name'    => $name,
            'arch'    => $arch,
            'version' => $version,
            'release' => $release
        }
    } split( /\n/, $rpm_list );

    if ( $#EXTENDED_RPM_LIST > 1 ) {
        @RPM_LIST = map { $_->{'name'} . '-' . $_->{'version'} . '-' . $_->{'release'} } @EXTENDED_RPM_LIST;
    }
}

sub build_openssl_rpm_changelog {
    return if $OPENSSL_RPM_CHANGELOG;    # don't do it again if it's already done

    local $OPT_TIMEOUT = $OPT_TIMEOUT ? $OPT_TIMEOUT : 15;

    print_info2("RPM query OpenSSL changelog (running \"rpm -q ...\"). This will timeout after $OPT_TIMEOUT seconds.");

    $OPENSSL_RPM_CHANGELOG = timed_run( $OPT_TIMEOUT, qw( rpm -q --changelog openssl ) );
}

sub check_for_cloudlinux_mysql_gov {
    if ( my @cl_mysql_rpms = grep ( m{^cl-MySQL-}, @RPM_LIST ) ) {
        print_warn("CloudLinux MySQL (see FB-64017): ");
        print_warning( join( " ", @cl_mysql_rpms ) );
    }
}

sub check_pure_ftpd_conf_for_upload_script_and_dead {
    return unless defined( $CPCONF{'ftpserver'} ) && $CPCONF{'ftpserver'} eq 'pure-ftpd';
    if ( defined( $PUREFTPDCONF->{'calluploadscript'} ) && $PUREFTPDCONF->{'calluploadscript'}->{value} eq 'yes' ) {
        if ( !-e '/var/run/pure-ftpd.upload.pipe' ) {
            print_warn("/etc/pure-ftpd.conf: ");
            print_warning("CallUploadScript set to yes, /var/run/pure-ftpd.upload.pipe is missing [might be broken ConfigServer's cxs ( http://configserver.com/cp/cxs.html )]");
        }
        else {
            my $out = timed_run( 0, 'lsof', '-n', '/var/run/pure-ftpd.upload.pipe' );
            if ( !$out ) {
                print_warn("/etc/pure-ftpd.conf: ");
                print_warning("CallUploadScript set to yes, and /var/run/pure-ftpd.upload.pipe does not seem to have anything listening on it. [might be broken ConfigServer's cxs ( http://configserver.com/cp/cxs.html )]");
            }
        }
    }
}

sub check_cpanel_config_for_bad_root {    # Separate from check_cpanel_config because those don't apply to DNSONLY
    if ( defined $CPCONF{'root'} && $CPCONF{'root'} ne '/usr/local/cpanel' ) {    # The default is used if it is missing, so only need to check if it is set
        print_warn("/var/cpanel/cpanel.config: ");
        print_warning( "root set to \"" . $CPCONF{'root'} . "\"" );
        print_warning("\t \\_ Default is \"/usr/local/cpanel\"");
        print_warning("\t \\_ An invalid root setting can cause WHM to fail to start.  See ticket 5463121.");
    }
}

sub get_ea4_php_fpm_status {
    return 0 unless $EA4;
    my $running = 0;

    while ( my ( $pid, $ref ) = each(%$PROCESS_REF) ) {
        if ( $ref->{COMM} =~ /php\-fpm/ ) {
            $running = 1;
            last;
        }
    }

    keys %$PROCESS_REF;    # reset iterator

    return $running;
}

# Examines the system for EasyApache4 PHP FPM, if it exists.
# It then examines the setup with the following sanity checks
#   1. Only user pools are in-use (as opposed to a global)
#   2. Only UNIX sockets are in-use (as opposed to net socket)
#   3. UNIX sockets have correct perms
sub check_ea4_php_fpm {
    return unless $EA4;
    return unless $EA4_PHP_FPM;
    my @running;

    # gather up a list of running php-fpm process
    while ( my ( $pid, $ref ) = each(%$PROCESS_REF) ) {
        next unless $ref->{COMM} =~ /php\-fpm/;
        push @running, { PID => $pid, %$ref };
    }

    my ( %shared, %port, %perms );

    # run through each process, checking for bad stuff
    for my $ref (@running) {
        my @lsof = split /\n/, timed_run( 0, 'lsof', '-nbP', '-p', $ref->{PID} );

        # e.g. php-fpm 26622 cgi64    0u  unix 0xffff880068acce80      0t0 9183680 /home/cgi64/php-fpm/run/ea-php55.sock
        # e.g. httpd   26012 nobody   3u  IPv4 9175485                 0t0     TCP *:http (LISTEN)
        for my $line (@lsof) {
            my ( $proc, $pid, $user, $fd, $type, $device, $size, $node, $name, $listen ) = split( /\s+/, $line );
            next unless $proc =~ /php\-fpm/i;    # verify in case it changed between runs

            $shared{$pid} = { user => $user } if ( !$shared{$pid} && ( $user =~ /^apache$/ || $user =~ /^nobody$/ ) );

            if ( $type eq 'unix' && $name =~ /^\// ) {
                next if $perms{$name};
                my $mode = ( stat($name) )[2];

                unless ($mode) {
                    print_warn('EA4 php-fpm: ');
                    print_warning("Unable to determine UNIX socket permissions (pid:$pid, path:$name)");
                    next;
                }

                $perms{$name} = { pid => $pid, user => $user } if $mode & S_IRWXO;
            }
            elsif ( $type =~ /^ipv\d+/i && $listen =~ /LISTEN/i ) {
                $name =~ s/^.*?:(\d+).*/$1/;
                $port{$name} = { pid => $pid, user => $user, type => $type } unless $port{$name};
            }
        }
    }

    if ( keys %shared ) {
        print_warn('EA4 php-fpm: ');
        my @ports = sort keys %shared;
        print_warning("Found shared pool(s), instead of dedicated per-user pools (pid:@ports)");
    }

    if ( keys %perms ) {
        print_warn('EA4 php-fpm: ');
        my @paths = sort keys %perms;
        print_warning("Invalid filesystem permission on UNIX socket(s). Remove 'world' bits: @paths");
    }

    if ( keys %port ) {
        print_warn('EA4 php-fpm: ');
        my @ports = keys %port;
        print_warning("php-fpm should not be listening on port(s): @ports");
    }

    return 1;
}

sub check_for_missing_fstab {
    return if -e "/etc/fstab";
    print_warn('Filesystem: ');
    print_warning("/etc/fstab may be missing. Can cause /scripts/fixquotas to fail. See case CPANEL-6082.");
}

sub get_external_ip {
    my ($port) = @_;
    die "get_external_ip port number not specified" if !$port;

    # myip.cpanel.net supports HTTP ports 80, 2089 and HTTPS port 443.
    my $host = 'myip.cpanel.net';
    my $path = '/v1.0/';
    my $ip;
    my $reply;

    my $count = 0;
    for ( 1 .. 2 ) {
        local $SIG{'ALRM'} = sub {
            $count++;
            print_warn("External IP detection via ${host} port ${port} timed out: ");
            print_warning("attempt ${count} of 2");
        };

        alarm 5;

        my $sock = IO::Socket::INET->new(
            PeerAddr => $host,
            PeerPort => $port,
            Proto    => 'tcp',
            Timeout  => 5,
        );

        my $header_host = ( $port != 80 ) ? $host . ":" . $port : $host;

        if ($sock) {
            print $sock "GET ${path} HTTP/1.1\r\nUser-Agent: SSP/" . $VERSION . "\r\nHost: ${header_host}\r\n\r\n";
            sysread $sock, $reply, 1500;
            close $sock;
        }

        alarm 0;

        if ( defined($reply) && $reply =~ m{ ^ \s* ([0-9]+.[0-9]+.[0-9]+.[0-9]+) \s* $ }xms ) {
            $ip = $1;
            chomp $ip;
            return $ip;
        }
    }
    return undef;
}

sub print_bug_report {
    my $version     = $CPANEL_VERSION            ? $CPANEL_VERSION            : 'Unknown';
    my $os          = $OS_RELEASE                ? $OS_RELEASE                : 'Unknown';
    my $kernel      = $HOSTINFO->{'kernel'}      ? $HOSTINFO->{'kernel'}      : 'Unknown';
    my $arch        = $HOSTINFO->{'hardware'}    ? $HOSTINFO->{'hardware'}    : 'Unknown';
    my $environment = $HOSTINFO->{'environment'} ? $HOSTINFO->{'environment'} : 'Unknown';
    my $cpu         = $CPUINFO->{'model'}        ? $CPUINFO->{'model'}        : 'Unknown';
    my $cores       = $CPUINFO->{'numcores'}     ? $CPUINFO->{'numcores'}     : 'Unknown';
    my $ticket      = "";
    if ( $ENV{HISTFILE} =~ /ticket.(\d+)$/ ) {
        $ticket = $1;
    }

    print <<END_OF_TEMPLATE
==== BEGIN COPY BELOW ====
----------------------------------------------
   1. Detailed Explanation
----------------------------------------------


----------------------------------------------
   2. Step-by-Step Instructions
----------------------------------------------


----------------------------------------------
   3. Suggested Resolution / Expected Behavior
----------------------------------------------


----------------------------------------------
   4. Known work around(s)
----------------------------------------------


==== END COPY ABOVE ====

Useful Information:

Ticket Number: $ticket
cPanel Version: $version
OS: $os
Kernel: $kernel
Arch: $arch
Environment: $environment
CPU: $cpu w/ $cores core(s)

END_OF_TEMPLATE
}

package main;

use strict;
use warnings;

unless ( caller() ) {
    SSP::init();
    SSP::run();
}
